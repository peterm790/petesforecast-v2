import{a7 as at,l as N,ai as Kt,Y as ne,ad as Ve,a9 as Xt,ac as Zt,aj as Yt,S as Qt,ab as Jt,$ as en,aa as tn,ak as nn,q as xt,al as sn,p as rn,L as an,r as on}from"./deep-equal-D6CKYaOP.js";class Ie extends at{static defaultProps={...at.defaultProps,shader:void 0,entryPoint:void 0,constants:{},shaderLayout:void 0};get[Symbol.toStringTag](){return"ComputePipeline"}hash="";shaderLayout;constructor(e,t){super(e,t,Ie.defaultProps),this.shaderLayout=t.shaderLayout}}const un={f32:{type:"f32",components:1},i32:{type:"i32",components:1},u32:{type:"u32",components:1},"vec2<f32>":{type:"f32",components:2},"vec3<f32>":{type:"f32",components:3},"vec4<f32>":{type:"f32",components:4},"vec2<i32>":{type:"i32",components:2},"vec3<i32>":{type:"i32",components:3},"vec4<i32>":{type:"i32",components:4},"vec2<u32>":{type:"u32",components:2},"vec3<u32>":{type:"u32",components:3},"vec4<u32>":{type:"u32",components:4},"mat2x2<f32>":{type:"f32",components:4},"mat2x3<f32>":{type:"f32",components:6},"mat2x4<f32>":{type:"f32",components:8},"mat3x2<f32>":{type:"f32",components:6},"mat3x3<f32>":{type:"f32",components:9},"mat3x4<f32>":{type:"f32",components:12},"mat4x2<f32>":{type:"f32",components:8},"mat4x3<f32>":{type:"f32",components:12},"mat4x4<f32>":{type:"f32",components:16}};function ln(c){return un[c]}function cn(c,e){switch(e){case 1:return c;case 2:return c+c%2;default:return c+(4-c%4)%4}}function fn(c){return ArrayBuffer.isView(c)&&!(c instanceof DataView)}function Te(c){return Array.isArray(c)?c.length===0||typeof c[0]=="number":fn(c)}const ot=1024;class hn{layout={};byteLength;constructor(e){let t=0;for(const[s,r]of Object.entries(e)){const a=ln(r),{type:i,components:o}=a;t=cn(t,o);const l=t;t+=o,this.layout[s]={type:i,size:o,offset:l}}t+=(4-t%4)%4;const n=t*4;this.byteLength=Math.max(n,ot)}getData(e){const t=Math.max(this.byteLength,ot),n=Kt(t),s={i32:new Int32Array(n),u32:new Uint32Array(n),f32:new Float32Array(n),f16:new Uint16Array(n)};for(const[r,a]of Object.entries(e)){const i=this.layout[r];if(!i){N.warn(`Supplied uniform value ${r} not present in uniform block layout`)();continue}const{type:o,size:l,offset:u}=i,h=s[o];if(l===1){if(typeof a!="number"&&typeof a!="boolean"){N.warn(`Supplied value for single component uniform ${r} is not a number: ${a}`)();continue}h[u]=Number(a)}else{if(!Te(a)){N.warn(`Supplied value for multi component / array uniform ${r} is not a numeric array: ${a}`)();continue}h.set(a,u)}}return new Uint8Array(n)}has(e){return!!this.layout[e]}get(e){return this.layout[e]}}function pn(c,e,t=16){if(c!==e)return!1;const n=c,s=e;if(!Te(n))return!1;if(Te(s)&&n.length===s.length){for(let r=0;r<n.length;++r)if(s[r]!==n[r])return!1}return!0}function dn(c){return Te(c)?c.slice():c}class mn{name;uniforms={};modifiedUniforms={};modified=!0;bindingLayout={};needsRedraw="initialized";constructor(e){if(this.name=e?.name||"unnamed",e?.name&&e?.shaderLayout){const t=e?.shaderLayout.bindings?.find(s=>s.type==="uniform"&&s.name===e?.name);if(!t)throw new Error(e?.name);const n=t;for(const s of n.uniforms||[])this.bindingLayout[s.name]=s}}setUniforms(e){for(const[t,n]of Object.entries(e))this._setUniform(t,n),this.needsRedraw||this.setNeedsRedraw(`${this.name}.${t}=${n}`)}setNeedsRedraw(e){this.needsRedraw=this.needsRedraw||e}getAllUniforms(){return this.modifiedUniforms={},this.needsRedraw=!1,this.uniforms||{}}_setUniform(e,t){pn(this.uniforms[e],t)||(this.uniforms[e]=dn(t),this.modifiedUniforms[e]=!0,this.modified=!0)}}class _n{uniformBlocks=new Map;uniformBufferLayouts=new Map;uniformBuffers=new Map;constructor(e){for(const[t,n]of Object.entries(e)){const s=t,r=new hn(n.uniformTypes||{});this.uniformBufferLayouts.set(s,r);const a=new mn({name:t});a.setUniforms(n.defaultUniforms||{}),this.uniformBlocks.set(s,a)}}destroy(){for(const e of this.uniformBuffers.values())e.destroy()}setUniforms(e){for(const[t,n]of Object.entries(e))this.uniformBlocks.get(t)?.setUniforms(n);this.updateUniformBuffers()}getUniformBufferByteLength(e){return this.uniformBufferLayouts.get(e)?.byteLength||0}getUniformBufferData(e){const t=this.uniformBlocks.get(e)?.getAllUniforms()||{};return this.uniformBufferLayouts.get(e)?.getData(t)}createUniformBuffer(e,t,n){n&&this.setUniforms(n);const s=this.getUniformBufferByteLength(t),r=e.createBuffer({usage:ne.UNIFORM|ne.COPY_DST,byteLength:s}),a=this.getUniformBufferData(t);return r.write(a),r}getManagedUniformBuffer(e,t){if(!this.uniformBuffers.get(t)){const n=this.getUniformBufferByteLength(t),s=e.createBuffer({usage:ne.UNIFORM|ne.COPY_DST,byteLength:n});this.uniformBuffers.set(t,s)}return this.uniformBuffers.get(t)}updateUniformBuffers(){let e=!1;for(const t of this.uniformBlocks.keys()){const n=this.updateUniformBuffer(t);e||=n}return e&&N.log(3,`UniformStore.updateUniformBuffers(): ${e}`)(),e}updateUniformBuffer(e){const t=this.uniformBlocks.get(e);let n=this.uniformBuffers.get(e),s=!1;if(n&&t?.needsRedraw){s||=t.needsRedraw;const r=this.getUniformBufferData(e);n=this.uniformBuffers.get(e),n?.write(r);const a=this.uniformBlocks.get(e)?.getAllUniforms();N.log(4,`Writing to uniform buffer ${String(e)}`,r,a)()}return s}}function gn(c){const e=ArrayBuffer.isView(c)?c.constructor:c;switch(e){case Float32Array:return"float32";case Uint16Array:return"uint16";case Uint32Array:return"uint32";case Uint8Array:case Uint8ClampedArray:return"uint8";case Int8Array:return"sint8";case Int16Array:return"sint16";case Int32Array:return"sint32";default:throw new Error(e.constructor.name)}}function yn(c){switch(c){case"float32":return Float32Array;case"uint32":return Uint32Array;case"sint32":return Int32Array;case"uint16":case"unorm16":return Uint16Array;case"sint16":case"snorm16":return Int16Array;case"uint8":case"unorm8":return Uint8Array;case"sint8":case"snorm8":return Int8Array;default:throw new Error(c)}}function xn(c,e,t){if(!e||e>4)throw new Error(`size ${e}`);const n=e;let s=gn(c);if(s==="uint8"&&t&&n===1)return"unorm8-webgl";if(s==="uint8"&&t&&n===3)return"unorm8x3-webgl";if(s==="uint8"||s==="sint8"){if(n===1||n===3)throw new Error(`size: ${e}`);return t&&(s=s.replace("int","norm")),`${s}x${n}`}if(s==="uint16"||s==="sint16"){if(n===1||n===3)throw new Error(`size: ${e}`);return t&&(s=s.replace("int","norm")),`${s}x${n}`}return n===1?s:`${s}x${n}`}class Ne{bufferLayouts;constructor(e){this.bufferLayouts=e}getBufferLayout(e){return this.bufferLayouts.find(t=>t.name===e)||null}getAttributeNamesForBuffer(e){return e.attributes?e.attributes?.map(t=>t.attribute):[e.name]}mergeBufferLayouts(e,t){const n=[...e];for(const s of t){const r=n.findIndex(a=>a.name===s.name);r<0?n.push(s):n[r]=s}return n}getBufferIndex(e){const t=this.bufferLayouts.findIndex(n=>n.name===e);return t===-1&&N.warn(`BufferLayout: Missing buffer for "${e}".`)(),t}}function vn(c,e){const t=Object.fromEntries(c.attributes.map(s=>[s.name,s.location])),n=e.slice();return n.sort((s,r)=>{const a=s.attributes?s.attributes.map(u=>u.attribute):[s.name],i=r.attributes?r.attributes.map(u=>u.attribute):[r.name],o=Math.min(...a.map(u=>t[u])),l=Math.min(...i.map(u=>t[u]));return o-l}),n}class H{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}get isPointer(){return!1}getTypeName(){return this.name}}class ut{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class se extends H{constructor(e,t){super(e,t),this.members=[],this.align=0,this.startLine=-1,this.endLine=-1,this.inUse=!1}get isStruct(){return!0}}class re extends H{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}getTypeName(){return`array<${this.format.getTypeName()}, ${this.count}>`}}class Me extends H{constructor(e,t,n){super(e,n),this.format=t}get isPointer(){return!0}getTypeName(){return`&${this.format.getTypeName()}`}}class ae extends H{constructor(e,t,n,s){super(e,n),this.format=t,this.access=s}get isTemplate(){return!0}getTypeName(){let e=this.name;if(this.format!==null){if(e==="vec2"||e==="vec3"||e==="vec4"||e==="mat2x2"||e==="mat2x3"||e==="mat2x4"||e==="mat3x2"||e==="mat3x3"||e==="mat3x4"||e==="mat4x2"||e==="mat4x3"||e==="mat4x4"){if(this.format.name==="f32")return e+="f",e;if(this.format.name==="i32")return e+="i",e;if(this.format.name==="u32")return e+="u",e;if(this.format.name==="bool")return e+="b",e;if(this.format.name==="f16")return e+="h",e}e+=`<${this.format.name}>`}else if(e==="vec2"||e==="vec3"||e==="vec4")return e;return e}}var te;(c=>{c[c.Uniform=0]="Uniform",c[c.Storage=1]="Storage",c[c.Texture=2]="Texture",c[c.Sampler=3]="Sampler",c[c.StorageTexture=4]="StorageTexture"})(te||(te={}));class xe{constructor(e,t,n,s,r,a,i){this.name=e,this.type=t,this.group=n,this.binding=s,this.attributes=r,this.resourceType=a,this.access=i}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class bn{constructor(e,t){this.name=e,this.type=t}}class wn{constructor(e,t,n,s){this.name=e,this.type=t,this.locationType=n,this.location=s,this.interpolation=null}}class lt{constructor(e,t,n,s){this.name=e,this.type=t,this.locationType=n,this.location=s}}class kn{constructor(e,t,n,s){this.name=e,this.type=t,this.attributes=n,this.id=s}}class In{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n}}class Tn{constructor(e,t=null,n){this.stage=null,this.inputs=[],this.outputs=[],this.arguments=[],this.returnType=null,this.resources=[],this.overrides=[],this.startLine=-1,this.endLine=-1,this.inUse=!1,this.calls=new Set,this.name=e,this.stage=t,this.attributes=n}}class An{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}function Sn(c){var e=(32768&c)>>15,t=(31744&c)>>10,n=1023&c;return t==0?(e?-1:1)*Math.pow(2,-14)*(n/Math.pow(2,10)):t==31?n?NaN:1/0*(e?-1:1):(e?-1:1)*Math.pow(2,t-15)*(1+n/Math.pow(2,10))}const vt=new Float32Array(1),Ln=new Int32Array(vt.buffer),U=new Uint16Array(1);function En(c){vt[0]=c;const e=Ln[0],t=e>>31&1;let n=e>>23&255,s=8388607&e;if(n===255)return U[0]=t<<15|31744|(s!==0?512:0),U[0];if(n===0){if(s===0)return U[0]=t<<15,U[0];s|=8388608;let r=113;for(;!(8388608&s);)s<<=1,r--;return n=127-r,s&=8388607,n>0?(s=(s>>126-n)+(s>>127-n&1),U[0]=t<<15|n<<10|s>>13,U[0]):(U[0]=t<<15,U[0])}return n=n-127+15,n>=31?(U[0]=t<<15|31744,U[0]):n<=0?n<-10?(U[0]=t<<15,U[0]):(s=(8388608|s)>>1-n,U[0]=t<<15|s>>13,U[0]):(s>>=13,U[0]=t<<15|n<<10|s,U[0])}const He=new Uint32Array(1),bt=new Float32Array(He.buffer,0,1);function ct(c){const e=112+(c>>6&31)<<23|(63&c)<<17;return He[0]=e,bt[0]}function On(c,e,t,n,s,r,a,i,o){const l=n*(a>>=s)*(r>>=s)+t*a+e*i;switch(o){case"r8unorm":return[L(c,l,"8unorm",1)[0]];case"r8snorm":return[L(c,l,"8snorm",1)[0]];case"r8uint":return[L(c,l,"8uint",1)[0]];case"r8sint":return[L(c,l,"8sint",1)[0]];case"rg8unorm":{const u=L(c,l,"8unorm",2);return[u[0],u[1]]}case"rg8snorm":{const u=L(c,l,"8snorm",2);return[u[0],u[1]]}case"rg8uint":{const u=L(c,l,"8uint",2);return[u[0],u[1]]}case"rg8sint":{const u=L(c,l,"8sint",2);return[u[0],u[1]]}case"rgba8unorm-srgb":case"rgba8unorm":{const u=L(c,l,"8unorm",4);return[u[0],u[1],u[2],u[3]]}case"rgba8snorm":{const u=L(c,l,"8snorm",4);return[u[0],u[1],u[2],u[3]]}case"rgba8uint":{const u=L(c,l,"8uint",4);return[u[0],u[1],u[2],u[3]]}case"rgba8sint":{const u=L(c,l,"8sint",4);return[u[0],u[1],u[2],u[3]]}case"bgra8unorm-srgb":case"bgra8unorm":{const u=L(c,l,"8unorm",4);return[u[2],u[1],u[0],u[3]]}case"r16uint":return[L(c,l,"16uint",1)[0]];case"r16sint":return[L(c,l,"16sint",1)[0]];case"r16float":return[L(c,l,"16float",1)[0]];case"rg16uint":{const u=L(c,l,"16uint",2);return[u[0],u[1]]}case"rg16sint":{const u=L(c,l,"16sint",2);return[u[0],u[1]]}case"rg16float":{const u=L(c,l,"16float",2);return[u[0],u[1]]}case"rgba16uint":{const u=L(c,l,"16uint",4);return[u[0],u[1],u[2],u[3]]}case"rgba16sint":{const u=L(c,l,"16sint",4);return[u[0],u[1],u[2],u[3]]}case"rgba16float":{const u=L(c,l,"16float",4);return[u[0],u[1],u[2],u[3]]}case"r32uint":return[L(c,l,"32uint",1)[0]];case"r32sint":return[L(c,l,"32sint",1)[0]];case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return[L(c,l,"32float",1)[0]];case"rg32uint":{const u=L(c,l,"32uint",2);return[u[0],u[1]]}case"rg32sint":{const u=L(c,l,"32sint",2);return[u[0],u[1]]}case"rg32float":{const u=L(c,l,"32float",2);return[u[0],u[1]]}case"rgba32uint":{const u=L(c,l,"32uint",4);return[u[0],u[1],u[2],u[3]]}case"rgba32sint":{const u=L(c,l,"32sint",4);return[u[0],u[1],u[2],u[3]]}case"rgba32float":{const u=L(c,l,"32float",4);return[u[0],u[1],u[2],u[3]]}case"rg11b10ufloat":{const u=new Uint32Array(c.buffer,l,1)[0],h=(4192256&u)>>11,x=(4290772992&u)>>22;return[ct(2047&u),ct(h),(function(b){const k=112+(b>>5&31)<<23|(31&b)<<18;return He[0]=k,bt[0]})(x),1]}}return null}function L(c,e,t,n){const s=[0,0,0,0];for(let r=0;r<n;++r)switch(t){case"8unorm":s[r]=c[e]/255,e++;break;case"8snorm":s[r]=c[e]/255*2-1,e++;break;case"8uint":s[r]=c[e],e++;break;case"8sint":s[r]=c[e]-127,e++;break;case"16uint":s[r]=c[e]|c[e+1]<<8,e+=2;break;case"16sint":s[r]=(c[e]|c[e+1]<<8)-32768,e+=2;break;case"16float":s[r]=Sn(c[e]|c[e+1]<<8),e+=2;break;case"32uint":case"32sint":s[r]=c[e]|c[e+1]<<8|c[e+2]<<16|c[e+3]<<24,e+=4;break;case"32float":s[r]=new Float32Array(c.buffer,e,1)[0],e+=4}return s}function E(c,e,t,n,s){for(let r=0;r<n;++r)switch(t){case"8unorm":c[e]=255*s[r],e++;break;case"8snorm":c[e]=.5*(s[r]+1)*255,e++;break;case"8uint":c[e]=s[r],e++;break;case"8sint":c[e]=s[r]+127,e++;break;case"16uint":new Uint16Array(c.buffer,e,1)[0]=s[r],e+=2;break;case"16sint":new Int16Array(c.buffer,e,1)[0]=s[r],e+=2;break;case"16float":{const a=En(s[r]);new Uint16Array(c.buffer,e,1)[0]=a,e+=2;break}case"32uint":new Uint32Array(c.buffer,e,1)[0]=s[r],e+=4;break;case"32sint":new Int32Array(c.buffer,e,1)[0]=s[r],e+=4;break;case"32float":new Float32Array(c.buffer,e,1)[0]=s[r],e+=4}return s}const Be={r8unorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8snorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8uint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8sint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg8unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8snorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"rgba8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8snorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},bgra8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bgra8unorm-srgb":{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r16uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16float:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg16uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba16uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r32uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg32uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba32uint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32sint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32float:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rg11b10ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},stencil8:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!1,hasStencil:!0,channels:1},depth16unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},depth24plus:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,depthOnlyFormat:"depth32float",channels:1},"depth24plus-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,depthOnlyFormat:"depth32float",channels:1},depth32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},"depth32float-stencil8":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,stencilOnlyFormat:"depth32float",channels:1},rgb9e5ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},"bc1-rgba-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc1-rgba-unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc2-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc3-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc4-r-unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc4-r-snorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},"bc5-rg-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc5-rg-snorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},"bc6h-rgb-ufloat":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc6h-rgb-float":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"bc7-rgba-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgb8a1unorm-srgb":{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"etc2-rgba8unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"eac-r11unorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-r11snorm":{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},"eac-rg11unorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"eac-rg11snorm":{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},"astc-4x4-unorm":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-4x4-unorm-srgb":{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x4-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},"astc-5x5-unorm":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-5x5-unorm-srgb":{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x5-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},"astc-6x6-unorm":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-6x6-unorm-srgb":{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},"astc-8x5-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x5-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},"astc-8x6-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x6-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},"astc-8x8-unorm":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-8x8-unorm-srgb":{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},"astc-10x5-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x5-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},"astc-10x6-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x6-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},"astc-10x8-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x8-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},"astc-10x10-unorm":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-10x10-unorm-srgb":{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x10-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},"astc-12x12-unorm":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4},"astc-12x12-unorm-srgb":{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4}};class G{constructor(){this.id=G._id++,this.line=0}get isAstNode(){return!0}get astNodeType(){return""}search(e){e(this)}searchBlock(e,t){if(e){t(Ae.instance);for(const n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(Se.instance)}}constEvaluate(e,t){throw new Error("Cannot evaluate node")}constEvaluateString(e){return this.constEvaluate(e).toString()}}G._id=0;class Ae extends G{}Ae.instance=new Ae;class Se extends G{}Se.instance=new Se;const wt=new Set(["all","all","any","select","arrayLength","abs","acos","acosh","asin","asinh","atan","atanh","atan2","ceil","clamp","cos","cosh","countLeadingZeros","countOneBits","countTrailingZeros","cross","degrees","determinant","distance","dot","dot4U8Packed","dot4I8Packed","exp","exp2","extractBits","faceForward","firstLeadingBit","firstTrailingBit","floor","fma","fract","frexp","insertBits","inverseSqrt","ldexp","length","log","log2","max","min","mix","modf","normalize","pow","quantizeToF16","radians","reflect","refract","reverseBits","round","saturate","sign","sin","sinh","smoothStep","sqrt","step","tan","tanh","transpose","trunc","dpdx","dpdxCoarse","dpdxFine","dpdy","dpdyCoarse","dpdyFine","fwidth","fwidthCoarse","fwidthFine","textureDimensions","textureGather","textureGatherCompare","textureLoad","textureNumLayers","textureNumLevels","textureNumSamples","textureSample","textureSampleBias","textureSampleCompare","textureSampleCompareLevel","textureSampleGrad","textureSampleLevel","textureSampleBaseClampToEdge","textureStore","atomicLoad","atomicStore","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","atomicExchange","atomicCompareExchangeWeak","pack4x8snorm","pack4x8unorm","pack4xI8","pack4xU8","pack4x8Clamp","pack4xU8Clamp","pack2x16snorm","pack2x16unorm","pack2x16float","unpack4x8snorm","unpack4x8unorm","unpack4xI8","unpack4xU8","unpack2x16snorm","unpack2x16unorm","unpack2x16float","storageBarrier","textureBarrier","workgroupBarrier","workgroupUniformLoad","subgroupAdd","subgroupExclusiveAdd","subgroupInclusiveAdd","subgroupAll","subgroupAnd","subgroupAny","subgroupBallot","subgroupBroadcast","subgroupBroadcastFirst","subgroupElect","subgroupMax","subgroupMin","subgroupMul","subgroupExclusiveMul","subgroupInclusiveMul","subgroupOr","subgroupShuffle","subgroupShuffleDown","subgroupShuffleUp","subgroupShuffleXor","subgroupXor","quadBroadcast","quadSwapDiagonal","quadSwapX","quadSwapY"]);class B extends G{constructor(){super()}}class me extends B{constructor(e,t,n,s,r,a){super(),this.calls=new Set,this.name=e,this.args=t,this.returnType=n,this.body=s,this.startLine=r,this.endLine=a}get astNodeType(){return"function"}search(e){if(this.attributes)for(const t of this.attributes)e(t);e(this);for(const t of this.args)e(t);this.searchBlock(this.body,e)}}class Pn extends B{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class kt extends B{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class We extends B{constructor(e,t){super(),this.body=e,this.loopId=t}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class It extends B{constructor(e,t,n,s){super(),this.init=e,this.condition=t,this.increment=n,this.body=s}get astNodeType(){return"for"}search(e){var t,n,s;(t=this.init)===null||t===void 0||t.search(e),(n=this.condition)===null||n===void 0||n.search(e),(s=this.increment)===null||s===void 0||s.search(e),this.searchBlock(this.body,e)}}class ee extends B{constructor(e,t,n,s,r){super(),this.attributes=null,this.name=e,this.type=t,this.storage=n,this.access=s,this.value=r}get astNodeType(){return"var"}search(e){var t;e(this),(t=this.value)===null||t===void 0||t.search(e)}}class ze extends B{constructor(e,t,n){super(),this.attributes=null,this.name=e,this.type=t,this.value=n}get astNodeType(){return"override"}search(e){var t;(t=this.value)===null||t===void 0||t.search(e)}}class pe extends B{constructor(e,t,n,s,r){super(),this.attributes=null,this.name=e,this.type=t,this.storage=n,this.access=s,this.value=r}get astNodeType(){return"let"}search(e){var t;e(this),(t=this.value)===null||t===void 0||t.search(e)}}class be extends B{constructor(e,t,n,s,r){super(),this.attributes=null,this.name=e,this.type=t,this.storage=n,this.access=s,this.value=r}get astNodeType(){return"const"}constEvaluate(e,t){return this.value.constEvaluate(e,t)}search(e){var t;e(this),(t=this.value)===null||t===void 0||t.search(e)}}var le,fe,y,m;(c=>{c.increment="++",c.decrement="--"})(le||(le={})),(c=>{c.parse=function(e){const t=e;if(t=="parse")throw new Error("Invalid value for IncrementOperator");return c[t]}})(le||(le={}));class Tt extends B{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}(c=>{c.assign="=",c.addAssign="+=",c.subtractAssin="-=",c.multiplyAssign="*=",c.divideAssign="/=",c.moduloAssign="%=",c.andAssign="&=",c.orAssign="|=",c.xorAssign="^=",c.shiftLeftAssign="<<=",c.shiftRightAssign=">>="})(fe||(fe={})),(c=>{c.parse=function(e){const t=e;if(t=="parse")throw new Error("Invalid value for AssignOperator");return t}})(fe||(fe={}));class At extends B{constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return"assign"}search(e){this.variable.search(e),this.value.search(e)}}class Ge extends B{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}isBuiltin(){return wt.has(this.name)}search(e){for(const t of this.args)t.search(e);e(this)}}class St extends B{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}search(e){var t;this.searchBlock(this.body,e),(t=this.continuing)===null||t===void 0||t.search(e)}}class Lt extends B{constructor(e,t){super(),this.condition=e,this.cases=t}get astNodeType(){return"switch"}search(e){e(this);for(const t of this.cases)t.search(e)}}class Et extends B{constructor(e,t,n,s){super(),this.condition=e,this.body=t,this.elseif=n,this.else=s}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class Ot extends B{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;(t=this.value)===null||t===void 0||t.search(e)}}class Nn extends B{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class Bn extends B{constructor(e){super(),this.extensions=e}get astNodeType(){return"requires"}}class Pt extends B{constructor(e,t){super(),this.severity=e,this.rule=t}get astNodeType(){return"diagnostic"}}class Ke extends B{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class Fn extends B{constructor(){super()}get astNodeType(){return"discard"}}class Nt extends B{constructor(){super(),this.condition=null,this.loopId=-1}get astNodeType(){return"break"}}class Bt extends B{constructor(){super(),this.loopId=-1}get astNodeType(){return"continue"}}class v extends B{constructor(e){super(),this.attributes=null,this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}static maxFormatType(e){let t=e[0];if(t.name==="f32")return t;for(let n=1;n<e.length;++n){const s=v._priority.get(t.name);v._priority.get(e[n].name)<s&&(t=e[n])}return t.name==="x32"?v.i32:t}getTypeName(){return this.name}}v.x32=new v("x32"),v.f32=new v("f32"),v.i32=new v("i32"),v.u32=new v("u32"),v.f16=new v("f16"),v.bool=new v("bool"),v.void=new v("void"),v._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);class ft extends v{constructor(e){super(e)}}class Q extends v{constructor(e,t,n,s){super(e),this.members=t,this.startLine=n,this.endLine=s}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}search(e){for(const t of this.members)e(t)}}class g extends v{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"template"}getTypeName(){let e=this.name;if(this.format!==null){if(e==="vec2"||e==="vec3"||e==="vec4"||e==="mat2x2"||e==="mat2x3"||e==="mat2x4"||e==="mat3x2"||e==="mat3x3"||e==="mat3x4"||e==="mat4x2"||e==="mat4x3"||e==="mat4x4"){if(this.format.name==="f32")return e+="f",e;if(this.format.name==="i32")return e+="i",e;if(this.format.name==="u32")return e+="u",e;if(this.format.name==="bool")return e+="b",e;if(this.format.name==="f16")return e+="h",e}e+=`<${this.format.name}>`}else if(e==="vec2"||e==="vec3"||e==="vec4")return e;return e}}g.vec2f=new g("vec2",v.f32,null),g.vec3f=new g("vec3",v.f32,null),g.vec4f=new g("vec4",v.f32,null),g.vec2i=new g("vec2",v.i32,null),g.vec3i=new g("vec3",v.i32,null),g.vec4i=new g("vec4",v.i32,null),g.vec2u=new g("vec2",v.u32,null),g.vec3u=new g("vec3",v.u32,null),g.vec4u=new g("vec4",v.u32,null),g.vec2h=new g("vec2",v.f16,null),g.vec3h=new g("vec3",v.f16,null),g.vec4h=new g("vec4",v.f16,null),g.vec2b=new g("vec2",v.bool,null),g.vec3b=new g("vec3",v.bool,null),g.vec4b=new g("vec4",v.bool,null),g.mat2x2f=new g("mat2x2",v.f32,null),g.mat2x3f=new g("mat2x3",v.f32,null),g.mat2x4f=new g("mat2x4",v.f32,null),g.mat3x2f=new g("mat3x2",v.f32,null),g.mat3x3f=new g("mat3x3",v.f32,null),g.mat3x4f=new g("mat3x4",v.f32,null),g.mat4x2f=new g("mat4x2",v.f32,null),g.mat4x3f=new g("mat4x3",v.f32,null),g.mat4x4f=new g("mat4x4",v.f32,null),g.mat2x2h=new g("mat2x2",v.f16,null),g.mat2x3h=new g("mat2x3",v.f16,null),g.mat2x4h=new g("mat2x4",v.f16,null),g.mat3x2h=new g("mat3x2",v.f16,null),g.mat3x3h=new g("mat3x3",v.f16,null),g.mat3x4h=new g("mat3x4",v.f16,null),g.mat4x2h=new g("mat4x2",v.f16,null),g.mat4x3h=new g("mat4x3",v.f16,null),g.mat4x4h=new g("mat4x4",v.f16,null),g.mat2x2i=new g("mat2x2",v.i32,null),g.mat2x3i=new g("mat2x3",v.i32,null),g.mat2x4i=new g("mat2x4",v.i32,null),g.mat3x2i=new g("mat3x2",v.i32,null),g.mat3x3i=new g("mat3x3",v.i32,null),g.mat3x4i=new g("mat3x4",v.i32,null),g.mat4x2i=new g("mat4x2",v.i32,null),g.mat4x3i=new g("mat4x3",v.i32,null),g.mat4x4i=new g("mat4x4",v.i32,null),g.mat2x2u=new g("mat2x2",v.u32,null),g.mat2x3u=new g("mat2x3",v.u32,null),g.mat2x4u=new g("mat2x4",v.u32,null),g.mat3x2u=new g("mat3x2",v.u32,null),g.mat3x3u=new g("mat3x3",v.u32,null),g.mat3x4u=new g("mat3x4",v.u32,null),g.mat4x2u=new g("mat4x2",v.u32,null),g.mat4x3u=new g("mat4x3",v.u32,null),g.mat4x4u=new g("mat4x4",v.u32,null);class we extends v{constructor(e,t,n,s){super(e),this.storage=t,this.type=n,this.access=s}get astNodeType(){return"pointer"}}class de extends v{constructor(e,t,n,s){super(e),this.attributes=t,this.format=n,this.count=s}get astNodeType(){return"array"}get isArray(){return!0}}class he extends v{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"sampler"}}class X extends G{constructor(){super(),this.postfix=null}}class oe extends X{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}constEvaluateString(){return this.value}}class Z extends X{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}search(e){if(e(this),this.args)for(const t of this.args)t.search(e)}constEvaluate(e,t){return t&&(t[0]=this.type),e.evalExpression(this,e.context)}}class Xe extends X{constructor(e,t){super(),this.cachedReturnValue=null,this.name=e,this.args=t}get astNodeType(){return"callExpr"}setCachedReturnValue(e){this.cachedReturnValue=e}get isBuiltin(){return wt.has(this.name)}constEvaluate(e,t){return e.evalExpression(this,e.context)}search(e){for(const t of this.args)t.search(e);e(this)}}class j extends X{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this),this.postfix&&this.postfix.search(e)}constEvaluate(e,t){return e.evalExpression(this,e.context)}}class Ft extends X{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}constEvaluate(e,t){if(this.initializer){const n=e.evalExpression(this.initializer,e.context);return n!==null&&this.postfix?n.getSubData(e,this.postfix,e.context):n}return null}search(e){this.initializer.search(e)}}class $ extends X{constructor(e,t){super(),this.value=e,this.type=t}get astNodeType(){return"literalExpr"}constEvaluate(e,t){return t!==void 0&&(t[0]=this.type),this.value}get isScalar(){return this.value instanceof d}get isVector(){return this.value instanceof p||this.value instanceof T}get scalarValue(){return this.value instanceof d?this.value.value:(console.error("Value is not scalar."),0)}get vectorValue(){return this.value instanceof p||this.value instanceof T?this.value.data:(console.error("Value is not a vector or matrix."),new Float32Array(0))}}class Ct extends X{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class ce extends X{constructor(e){super(),this.index=e}search(e){this.index.search(e)}}class $t extends X{constructor(){super()}}class C extends $t{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}constEvaluate(e,t){return e.evalExpression(this,e.context)}search(e){this.right.search(e)}}class K extends $t{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return"binaryOp"}_getPromotedType(e,t){return e.name===t.name?e:e.name==="f32"||t.name==="f32"?v.f32:e.name==="u32"||t.name==="u32"?v.u32:v.i32}constEvaluate(e,t){return e.evalExpression(this,e.context)}search(e){this.left.search(e),this.right.search(e)}}class Dt extends G{constructor(e){super(),this.body=e}search(e){e(this),this.searchBlock(this.body,e)}}class ke extends X{constructor(){super()}get astNodeType(){return"default"}}class Ut extends Dt{constructor(e,t){super(t),this.selectors=e}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class Vt extends Dt{constructor(e){super(e)}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class ht extends G{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"argument"}}class Cn extends G{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class pt extends G{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"member"}}class Mt extends G{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}class z{constructor(e,t){this.parent=null,this.typeInfo=e,this.parent=t,this.id=z._id++}clone(){throw`Clone: Not implemented for ${this.constructor.name}`}setDataValue(e,t,n,s){console.error(`SetDataValue: Not implemented for ${this.constructor.name}`)}getSubData(e,t,n){return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`),null}toString(){return`<${this.typeInfo.getTypeName()}>`}}z._id=0;class Re extends z{constructor(){super(new H("void",null),null)}toString(){return"void"}}Re.void=new Re;class ue extends z{constructor(e){super(new Me("pointer",e.typeInfo,null),null),this.reference=e}clone(){return this}setDataValue(e,t,n,s){this.reference.setDataValue(e,t,n,s)}getSubData(e,t,n){return t?this.reference.getSubData(e,t,n):this}toString(){return`&${this.reference.toString()}`}}class d extends z{constructor(e,t,n=null){super(t,n),e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array?this.data=e:this.typeInfo.name==="x32"?e-Math.floor(e)!==0?this.data=new Float32Array([e]):this.data=e>=0?new Uint32Array([e]):new Int32Array([e]):this.typeInfo.name==="i32"||this.typeInfo.name==="bool"?this.data=new Int32Array([e]):this.typeInfo.name==="u32"?this.data=new Uint32Array([e]):this.typeInfo.name==="f32"||this.typeInfo.name==="f16"?this.data=new Float32Array([e]):console.error("ScalarData2: Invalid type",t)}clone(){if(this.data instanceof Float32Array)return new d(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new d(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new d(new Uint32Array(this.data),this.typeInfo,null);throw"ScalarData: Invalid data type"}get value(){return this.data[0]}set value(e){this.data[0]=e}setDataValue(e,t,n,s){if(n)return void console.error("SetDataValue: Scalar data does not support postfix",n);if(!(t instanceof d))return void console.error("SetDataValue: Invalid value",t);let r=t.data[0];this.typeInfo.name==="i32"||this.typeInfo.name==="u32"?r=Math.floor(r):this.typeInfo.name==="bool"&&(r=r?1:0),this.data[0]=r}getSubData(e,t,n){return t?(console.error("getSubData: Scalar data does not support postfix",t),null):this}toString(){return`${this.value}`}}function $n(c,e,t){const n=e.length;return n===2?t==="f32"?new p(new Float32Array(e),c.getTypeInfo("vec2f")):t==="i32"||t==="bool"?new p(new Int32Array(e),c.getTypeInfo("vec2i")):t==="u32"?new p(new Uint32Array(e),c.getTypeInfo("vec2u")):t==="f16"?new p(new Float32Array(e),c.getTypeInfo("vec2h")):(console.error(`getSubData: Unknown format ${t}`),null):n===3?t==="f32"?new p(new Float32Array(e),c.getTypeInfo("vec3f")):t==="i32"||t==="bool"?new p(new Int32Array(e),c.getTypeInfo("vec3i")):t==="u32"?new p(new Uint32Array(e),c.getTypeInfo("vec3u")):t==="f16"?new p(new Float32Array(e),c.getTypeInfo("vec3h")):(console.error(`getSubData: Unknown format ${t}`),null):n===4?t==="f32"?new p(new Float32Array(e),c.getTypeInfo("vec4f")):t==="i32"||t==="bool"?new p(new Int32Array(e),c.getTypeInfo("vec4i")):t==="u32"?new p(new Uint32Array(e),c.getTypeInfo("vec4u")):t==="f16"?new p(new Float32Array(e),c.getTypeInfo("vec4h")):(console.error(`getSubData: Unknown format ${t}`),null):(console.error(`getSubData: Invalid vector size ${e.length}`),null)}class p extends z{constructor(e,t,n=null){if(super(t,n),e instanceof Float32Array||e instanceof Uint32Array||e instanceof Int32Array)this.data=e;else{const s=this.typeInfo.name;s==="vec2f"||s==="vec3f"||s==="vec4f"?this.data=new Float32Array(e):s==="vec2i"||s==="vec3i"||s==="vec4i"?this.data=new Int32Array(e):s==="vec2u"||s==="vec3u"||s==="vec4u"?this.data=new Uint32Array(e):s==="vec2h"||s==="vec3h"||s==="vec4h"?this.data=new Float32Array(e):s==="vec2b"||s==="vec3b"||s==="vec4b"?this.data=new Int32Array(e):s==="vec2"||s==="vec3"||s==="vec4"?this.data=new Float32Array(e):console.error(`VectorData: Invalid type ${s}`)}}clone(){if(this.data instanceof Float32Array)return new p(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new p(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new p(new Uint32Array(this.data),this.typeInfo,null);throw"VectorData: Invalid data type"}setDataValue(e,t,n,s){n instanceof oe?console.error("TODO: Set vector postfix"):t instanceof p?this.data=t.data:console.error("SetDataValue: Invalid value",t)}getSubData(e,t,n){if(t===null)return this;let s=e.getTypeInfo("f32");if(this.typeInfo instanceof ae)s=this.typeInfo.format||s;else{const a=this.typeInfo.name;a==="vec2f"||a==="vec3f"||a==="vec4f"?s=e.getTypeInfo("f32"):a==="vec2i"||a==="vec3i"||a==="vec4i"?s=e.getTypeInfo("i32"):a==="vec2b"||a==="vec3b"||a==="vec4b"?s=e.getTypeInfo("bool"):a==="vec2u"||a==="vec3u"||a==="vec4u"?s=e.getTypeInfo("u32"):a==="vec2h"||a==="vec3h"||a==="vec4h"?s=e.getTypeInfo("f16"):console.error(`GetSubData: Unknown type ${a}`)}let r=this;for(;t!==null&&r!==null;){if(t instanceof ce){const a=t.index;let i=-1;if(a instanceof $){if(!(a.value instanceof d))return console.error(`GetSubData: Invalid array index ${a.value}`),null;i=a.value.value}else{const o=e.evalExpression(a,n);if(!(o instanceof d))return console.error("GetSubData: Unknown index type",a),null;i=o.value}if(i<0||i>=r.data.length)return console.error("GetSubData: Index out of range",i),null;if(r.data instanceof Float32Array){const o=new Float32Array(r.data.buffer,r.data.byteOffset+4*i,1);return new d(o,s)}if(r.data instanceof Int32Array){const o=new Int32Array(r.data.buffer,r.data.byteOffset+4*i,1);return new d(o,s)}if(r.data instanceof Uint32Array){const o=new Uint32Array(r.data.buffer,r.data.byteOffset+4*i,1);return new d(o,s)}throw"GetSubData: Invalid data type"}if(!(t instanceof oe))return console.error("GetSubData: Unknown postfix",t),null;{const a=t.value.toLowerCase();if(a.length===1){let o=0;if(a==="x"||a==="r")o=0;else if(a==="y"||a==="g")o=1;else if(a==="z"||a==="b")o=2;else{if(a!=="w"&&a!=="a")return console.error(`GetSubData: Unknown member ${a}`),null;o=3}if(this.data instanceof Float32Array){let l=new Float32Array(this.data.buffer,this.data.byteOffset+4*o,1);return new d(l,s,this)}if(this.data instanceof Int32Array){let l=new Int32Array(this.data.buffer,this.data.byteOffset+4*o,1);return new d(l,s,this)}if(this.data instanceof Uint32Array){let l=new Uint32Array(this.data.buffer,this.data.byteOffset+4*o,1);return new d(l,s,this)}}const i=[];for(const o of a)o==="x"||o==="r"?i.push(this.data[0]):o==="y"||o==="g"?i.push(this.data[1]):o==="z"||o==="b"?i.push(this.data[2]):o==="w"||o==="a"?i.push(this.data[3]):console.error(`GetDataValue: Unknown member ${o}`);r=$n(e,i,s.name)}t=t.postfix}return r}toString(){let e=`${this.data[0]}`;for(let t=1;t<this.data.length;++t)e+=`, ${this.data[t]}`;return e}}class T extends z{constructor(e,t,n=null){super(t,n),e instanceof Float32Array?this.data=e:this.data=new Float32Array(e)}clone(){return new T(new Float32Array(this.data),this.typeInfo,null)}setDataValue(e,t,n,s){n instanceof oe?console.error("TODO: Set matrix postfix"):t instanceof T?this.data=t.data:console.error("SetDataValue: Invalid value",t)}getSubData(e,t,n){if(t===null)return this;const s=this.typeInfo.name;if(e.getTypeInfo("f32"),this.typeInfo instanceof ae)this.typeInfo.format;else if(s.endsWith("f"))e.getTypeInfo("f32");else if(s.endsWith("i"))e.getTypeInfo("i32");else if(s.endsWith("u"))e.getTypeInfo("u32");else{if(!s.endsWith("h"))return console.error(`GetDataValue: Unknown type ${s}`),null;e.getTypeInfo("f16")}if(t instanceof ce){const r=t.index;let a=-1;if(r instanceof $){if(!(r.value instanceof d))return console.error(`GetDataValue: Invalid array index ${r.value}`),null;a=r.value.value}else{const l=e.evalExpression(r,n);if(!(l instanceof d))return console.error("GetDataValue: Unknown index type",r),null;a=l.value}if(a<0||a>=this.data.length)return console.error("GetDataValue: Index out of range",a),null;const i=s.endsWith("h")?"h":"f";let o;if(s==="mat2x2"||s==="mat2x2f"||s==="mat2x2h"||s==="mat3x2"||s==="mat3x2f"||s==="mat3x2h"||s==="mat4x2"||s==="mat4x2f"||s==="mat4x2h")o=new p(new Float32Array(this.data.buffer,this.data.byteOffset+2*a*4,2),e.getTypeInfo(`vec2${i}`));else if(s==="mat2x3"||s==="mat2x3f"||s==="mat2x3h"||s==="mat3x3"||s==="mat3x3f"||s==="mat3x3h"||s==="mat4x3"||s==="mat4x3f"||s==="mat4x3h")o=new p(new Float32Array(this.data.buffer,this.data.byteOffset+3*a*4,3),e.getTypeInfo(`vec3${i}`));else{if(s!=="mat2x4"&&s!=="mat2x4f"&&s!=="mat2x4h"&&s!=="mat3x4"&&s!=="mat3x4f"&&s!=="mat3x4h"&&s!=="mat4x4"&&s!=="mat4x4f"&&s!=="mat4x4h")return console.error(`GetDataValue: Unknown type ${s}`),null;o=new p(new Float32Array(this.data.buffer,this.data.byteOffset+4*a*4,4),e.getTypeInfo(`vec4${i}`))}return t.postfix?o.getSubData(e,t.postfix,n):o}return console.error("GetDataValue: Invalid postfix",t),null}toString(){let e=`${this.data[0]}`;for(let t=1;t<this.data.length;++t)e+=`, ${this.data[t]}`;return e}}class F extends z{constructor(e,t,n=0,s=null){super(t,s),this.buffer=e instanceof ArrayBuffer?e:e.buffer,this.offset=n}clone(){const e=new Uint8Array(new Uint8Array(this.buffer,this.offset,this.typeInfo.size));return new F(e.buffer,this.typeInfo,0,null)}setDataValue(e,t,n,s){if(t===null)return void console.log("setDataValue: NULL data.");let r=this.offset,a=this.typeInfo;for(;n;){if(n instanceof ce)if(a instanceof re){const i=n.index;if(i instanceof $){if(!(i.value instanceof d))return void console.error(`SetDataValue: Invalid index type ${i.value}`);r+=i.value.value*a.stride}else{const o=e.evalExpression(i,s);if(!(o instanceof d))return void console.error("SetDataValue: Unknown index type",i);r+=o.value*a.stride}a=a.format}else console.error(`SetDataValue: Type ${a.getTypeName()} is not an array`);else{if(!(n instanceof oe))return void console.error("SetDataValue: Unknown postfix type",n);{const i=n.value;if(a instanceof se){let o=!1;for(const l of a.members)if(l.name===i){r+=l.offset,a=l.type,o=!0;break}if(!o)return void console.error(`SetDataValue: Member ${i} not found`)}else if(a instanceof H){const o=a.getTypeName();let l=0;if(i==="x"||i==="r")l=0;else if(i==="y"||i==="g")l=1;else if(i==="z"||i==="b")l=2;else{if(i!=="w"&&i!=="a")return void console.error(`SetDataValue: Unknown member ${i}`);l=3}if(!(t instanceof d))return void console.error("SetDataValue: Invalid value",t);const u=t.value;return o==="vec2f"?void(new Float32Array(this.buffer,r,2)[l]=u):o==="vec3f"?void(new Float32Array(this.buffer,r,3)[l]=u):o==="vec4f"?void(new Float32Array(this.buffer,r,4)[l]=u):o==="vec2i"?void(new Int32Array(this.buffer,r,2)[l]=u):o==="vec3i"?void(new Int32Array(this.buffer,r,3)[l]=u):o==="vec4i"?void(new Int32Array(this.buffer,r,4)[l]=u):o==="vec2u"?void(new Uint32Array(this.buffer,r,2)[l]=u):o==="vec3u"?void(new Uint32Array(this.buffer,r,3)[l]=u):o==="vec4u"?void(new Uint32Array(this.buffer,r,4)[l]=u):void console.error(`SetDataValue: Type ${o} is not a struct`)}}}n=n.postfix}this.setData(e,t,a,r,s)}setData(e,t,n,s,r){const a=n.getTypeName();if(a!=="f32"&&a!=="f16")if(a!=="i32"&&a!=="atomic<i32>"&&a!=="x32")if(a!=="u32"&&a!=="atomic<u32>")if(a!=="bool"){if(a==="vec2f"||a==="vec2h"){const i=new Float32Array(this.buffer,s,2);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1]):(i[0]=t[0],i[1]=t[1]))}if(a==="vec3f"||a==="vec3h"){const i=new Float32Array(this.buffer,s,3);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2]):(i[0]=t[0],i[1]=t[1],i[2]=t[2]))}if(a==="vec4f"||a==="vec4h"){const i=new Float32Array(this.buffer,s,4);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3]))}if(a==="vec2i"){const i=new Int32Array(this.buffer,s,2);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1]):(i[0]=t[0],i[1]=t[1]))}if(a==="vec3i"){const i=new Int32Array(this.buffer,s,3);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2]):(i[0]=t[0],i[1]=t[1],i[2]=t[2]))}if(a==="vec4i"){const i=new Int32Array(this.buffer,s,4);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3]))}if(a==="vec2u"){const i=new Uint32Array(this.buffer,s,2);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1]):(i[0]=t[0],i[1]=t[1]))}if(a==="vec3u"){const i=new Uint32Array(this.buffer,s,3);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2]):(i[0]=t[0],i[1]=t[1],i[2]=t[2]))}if(a==="vec4u"){const i=new Uint32Array(this.buffer,s,4);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3]))}if(a==="vec2b"){const i=new Uint32Array(this.buffer,s,2);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1]):(i[0]=t[0],i[1]=t[1]))}if(a==="vec3b"){const i=new Uint32Array(this.buffer,s,3);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2]):(i[0]=t[0],i[1]=t[1],i[2]=t[2]))}if(a==="vec4b"){const i=new Uint32Array(this.buffer,s,4);return void(t instanceof p?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3]))}if(a==="mat2x2f"||a==="mat2x2h"){const i=new Float32Array(this.buffer,s,4);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3]))}if(a==="mat2x3f"||a==="mat2x3h"){const i=new Float32Array(this.buffer,s,6);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3],i[4]=t.data[4],i[5]=t.data[5]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5]))}if(a==="mat2x4f"||a==="mat2x4h"){const i=new Float32Array(this.buffer,s,8);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3],i[4]=t.data[4],i[5]=t.data[5],i[6]=t.data[6],i[7]=t.data[7]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7]))}if(a==="mat3x2f"||a==="mat3x2h"){const i=new Float32Array(this.buffer,s,6);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3],i[4]=t.data[4],i[5]=t.data[5]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5]))}if(a==="mat3x3f"||a==="mat3x3h"){const i=new Float32Array(this.buffer,s,9);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3],i[4]=t.data[4],i[5]=t.data[5],i[6]=t.data[6],i[7]=t.data[7],i[8]=t.data[8]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7],i[8]=t[8]))}if(a==="mat3x4f"||a==="mat3x4h"){const i=new Float32Array(this.buffer,s,12);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3],i[4]=t.data[4],i[5]=t.data[5],i[6]=t.data[6],i[7]=t.data[7],i[8]=t.data[8],i[9]=t.data[9],i[10]=t.data[10],i[11]=t.data[11]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7],i[8]=t[8],i[9]=t[9],i[10]=t[10],i[11]=t[11]))}if(a==="mat4x2f"||a==="mat4x2h"){const i=new Float32Array(this.buffer,s,8);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3],i[4]=t.data[4],i[5]=t.data[5],i[6]=t.data[6],i[7]=t.data[7]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7]))}if(a==="mat4x3f"||a==="mat4x3h"){const i=new Float32Array(this.buffer,s,12);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3],i[4]=t.data[4],i[5]=t.data[5],i[6]=t.data[6],i[7]=t.data[7],i[8]=t.data[8],i[9]=t.data[9],i[10]=t.data[10],i[11]=t.data[11]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7],i[8]=t[8],i[9]=t[9],i[10]=t[10],i[11]=t[11]))}if(a==="mat4x4f"||a==="mat4x4h"){const i=new Float32Array(this.buffer,s,16);return void(t instanceof T?(i[0]=t.data[0],i[1]=t.data[1],i[2]=t.data[2],i[3]=t.data[3],i[4]=t.data[4],i[5]=t.data[5],i[6]=t.data[6],i[7]=t.data[7],i[8]=t.data[8],i[9]=t.data[9],i[10]=t.data[10],i[11]=t.data[11],i[12]=t.data[12],i[13]=t.data[13],i[14]=t.data[14],i[15]=t.data[15]):(i[0]=t[0],i[1]=t[1],i[2]=t[2],i[3]=t[3],i[4]=t[4],i[5]=t[5],i[6]=t[6],i[7]=t[7],i[8]=t[8],i[9]=t[9],i[10]=t[10],i[11]=t[11],i[12]=t[12],i[13]=t[13],i[14]=t[14],i[15]=t[15]))}if(t instanceof F){if(n===t.typeInfo)return void new Uint8Array(this.buffer,s,t.buffer.byteLength).set(new Uint8Array(t.buffer));console.error("SetDataValue: Type mismatch",a,t.typeInfo.getTypeName())}else console.error(`SetData: Unknown type ${a}`)}else t instanceof d&&(new Int32Array(this.buffer,s,1)[0]=t.value);else t instanceof d&&(new Uint32Array(this.buffer,s,1)[0]=t.value);else t instanceof d&&(new Int32Array(this.buffer,s,1)[0]=t.value);else t instanceof d&&(new Float32Array(this.buffer,s,1)[0]=t.value)}getSubData(e,t,n){var s,r,a;if(t===null)return this;let i=this.offset,o=this.typeInfo;for(;t;){if(t instanceof ce){const u=t.index,h=u instanceof X?e.evalExpression(u,n):u;let x=0;if(h instanceof d?x=h.value:typeof h=="number"?x=h:console.error("GetDataValue: Invalid index type",u),o instanceof re)i+=x*o.stride,o=o.format;else{const b=o.getTypeName();b==="mat4x4"||b==="mat4x4f"||b==="mat4x4h"?(i+=16*x,o=e.getTypeInfo("vec4f")):console.error(`getDataValue: Type ${o.getTypeName()} is not an array`)}}else{if(!(t instanceof oe))return console.error("GetDataValue: Unknown postfix type",t),null;{const u=t.value;if(o instanceof se){let h=!1;for(const x of o.members)if(x.name===u){i+=x.offset,o=x.type,h=!0;break}if(!h)return console.error(`GetDataValue: Member ${u} not found`),null}else if(o instanceof H){const h=o.getTypeName();if(h==="vec2f"||h==="vec3f"||h==="vec4f"||h==="vec2i"||h==="vec3i"||h==="vec4i"||h==="vec2u"||h==="vec3u"||h==="vec4u"||h==="vec2b"||h==="vec3b"||h==="vec4b"||h==="vec2h"||h==="vec3h"||h==="vec4h"||h==="vec2"||h==="vec3"||h==="vec4"){if(u.length>0&&u.length<5){let x="f";const b=[];for(let k=0;k<u.length;++k){const O=u[k].toLowerCase();let S=0;if(O==="x"||O==="r")S=0;else if(O==="y"||O==="g")S=1;else if(O==="z"||O==="b")S=2;else{if(O!=="w"&&O!=="a")return console.error(`Unknown member ${u}`),null;S=3}if(u.length===1){if(h.endsWith("f"))return this.buffer.byteLength<i+4*S+4?(console.log("Insufficient buffer data"),null):new d(new Float32Array(this.buffer,i+4*S,1),e.getTypeInfo("f32"),this);if(h.endsWith("h"))return new d(new Float32Array(this.buffer,i+4*S,1),e.getTypeInfo("f16"),this);if(h.endsWith("i"))return new d(new Int32Array(this.buffer,i+4*S,1),e.getTypeInfo("i32"),this);if(h.endsWith("b"))return new d(new Int32Array(this.buffer,i+4*S,1),e.getTypeInfo("bool"),this);if(h.endsWith("u"))return new d(new Uint32Array(this.buffer,i+4*S,1),e.getTypeInfo("i32"),this)}if(h==="vec2f")b.push(new Float32Array(this.buffer,i,2)[S]);else if(h==="vec3f"){if(i+12>=this.buffer.byteLength)return console.log("Insufficient buffer data"),null;const P=new Float32Array(this.buffer,i,3);b.push(P[S])}else if(h==="vec4f")b.push(new Float32Array(this.buffer,i,4)[S]);else if(h==="vec2i")x="i",b.push(new Int32Array(this.buffer,i,2)[S]);else if(h==="vec3i")x="i",b.push(new Int32Array(this.buffer,i,3)[S]);else if(h==="vec4i")x="i",b.push(new Int32Array(this.buffer,i,4)[S]);else if(h==="vec2u"){x="u";const P=new Uint32Array(this.buffer,i,2);b.push(P[S])}else h==="vec3u"?(x="u",b.push(new Uint32Array(this.buffer,i,3)[S])):h==="vec4u"&&(x="u",b.push(new Uint32Array(this.buffer,i,4)[S]))}return b.length===2?o=e.getTypeInfo(`vec2${x}`):b.length===3?o=e.getTypeInfo(`vec3${x}`):b.length===4?o=e.getTypeInfo(`vec4${x}`):console.error(`GetDataValue: Invalid vector length ${b.length}`),new p(b,o,null)}return console.error(`GetDataValue: Unknown member ${u}`),null}return console.error(`GetDataValue: Type ${h} is not a struct`),null}}}t=t.postfix}const l=o.getTypeName();return l==="f32"?new d(new Float32Array(this.buffer,i,1),o,this):l==="i32"?new d(new Int32Array(this.buffer,i,1),o,this):l==="u32"?new d(new Uint32Array(this.buffer,i,1),o,this):l==="vec2f"?new p(new Float32Array(this.buffer,i,2),o,this):l==="vec3f"?new p(new Float32Array(this.buffer,i,3),o,this):l==="vec4f"?new p(new Float32Array(this.buffer,i,4),o,this):l==="vec2i"?new p(new Int32Array(this.buffer,i,2),o,this):l==="vec3i"?new p(new Int32Array(this.buffer,i,3),o,this):l==="vec4i"?new p(new Int32Array(this.buffer,i,4),o,this):l==="vec2u"?new p(new Uint32Array(this.buffer,i,2),o,this):l==="vec3u"?new p(new Uint32Array(this.buffer,i,3),o,this):l==="vec4u"?new p(new Uint32Array(this.buffer,i,4),o,this):o instanceof ae&&o.name==="atomic"?((s=o.format)===null||s===void 0?void 0:s.name)==="u32"?new d(new Uint32Array(this.buffer,i,1)[0],o.format,this):((r=o.format)===null||r===void 0?void 0:r.name)==="i32"?new d(new Int32Array(this.buffer,i,1)[0],o.format,this):(console.error(`GetDataValue: Invalid atomic format ${(a=o.format)===null||a===void 0?void 0:a.name}`),null):new F(this.buffer,o,i,this)}toString(){let e="";if(this.typeInfo instanceof re)if(this.typeInfo.format.name==="f32"){const t=new Float32Array(this.buffer,this.offset);e=`[${t[0]}`;for(let n=1;n<t.length;++n)e+=`, ${t[n]}`}else if(this.typeInfo.format.name==="i32"){const t=new Int32Array(this.buffer,this.offset);e=`[${t[0]}`;for(let n=1;n<t.length;++n)e+=`, ${t[n]}`}else if(this.typeInfo.format.name==="u32"){const t=new Uint32Array(this.buffer,this.offset);e=`[${t[0]}`;for(let n=1;n<t.length;++n)e+=`, ${t[n]}`}else if(this.typeInfo.format.name==="vec2f"){const t=new Float32Array(this.buffer,this.offset);e=`[${t[0]}, ${t[1]}]`;for(let n=1;n<t.length/2;++n)e+=`, [${t[2*n]}, ${t[2*n+1]}]`}else if(this.typeInfo.format.name==="vec3f"){const t=new Float32Array(this.buffer,this.offset);e=`[${t[0]}, ${t[1]}, ${t[2]}]`;for(let n=4;n<t.length;n+=4)e+=`, [${t[n]}, ${t[n+1]}, ${t[n+2]}]`}else if(this.typeInfo.format.name==="vec4f"){const t=new Float32Array(this.buffer,this.offset);e=`[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;for(let n=4;n<t.length;n+=4)e+=`, [${t[n]}, ${t[n+1]}, ${t[n+2]}, ${t[n+3]}]`}else e="[...]";else this.typeInfo instanceof se?e+="{...}":e="[...]";return e}}class J extends z{constructor(e,t,n,s){super(t,null),this.data=e,this.descriptor=n,this.view=s}clone(){return new J(this.data,this.typeInfo,this.descriptor,this.view)}get width(){var e,t;const n=this.descriptor.size;return n instanceof Array&&n.length>0?(e=n[0])!==null&&e!==void 0?e:0:n instanceof Object&&(t=n.width)!==null&&t!==void 0?t:0}get height(){var e,t;const n=this.descriptor.size;return n instanceof Array&&n.length>1?(e=n[1])!==null&&e!==void 0?e:0:n instanceof Object&&(t=n.height)!==null&&t!==void 0?t:0}get depthOrArrayLayers(){var e,t;const n=this.descriptor.size;return n instanceof Array&&n.length>2?(e=n[2])!==null&&e!==void 0?e:0:n instanceof Object&&(t=n.depthOrArrayLayers)!==null&&t!==void 0?t:0}get format(){var e;return this.descriptor&&(e=this.descriptor.format)!==null&&e!==void 0?e:"rgba8unorm"}get sampleCount(){var e;return this.descriptor&&(e=this.descriptor.sampleCount)!==null&&e!==void 0?e:1}get mipLevelCount(){var e;return this.descriptor&&(e=this.descriptor.mipLevelCount)!==null&&e!==void 0?e:1}get dimension(){var e;return this.descriptor&&(e=this.descriptor.dimension)!==null&&e!==void 0?e:"2d"}getMipLevelSize(e){if(e>=this.mipLevelCount)return[0,0,0];const t=[this.width,this.height,this.depthOrArrayLayers];for(let n=0;n<t.length;++n)t[n]=Math.max(1,t[n]>>e);return t}get texelByteSize(){const e=this.format,t=Be[e];return t?t.isDepthStencil?4:t.bytesPerBlock:0}get bytesPerRow(){return this.width*this.texelByteSize}get isDepthStencil(){const e=this.format,t=Be[e];return!!t&&t.isDepthStencil}getGpuSize(){const e=this.format,t=Be[e],n=this.width;if(!e||n<=0||!t)return-1;const s=this.height,r=this.depthOrArrayLayers,a=this.dimension;return n/t.blockWidth*(a==="1d"?1:s/t.blockHeight)*t.bytesPerBlock*r}getPixel(e,t,n=0,s=0){const r=this.texelByteSize,a=this.bytesPerRow,i=this.height,o=this.data[s];return On(new Uint8Array(o),e,t,n,s,i,a,r,this.format)}setPixel(e,t,n,s,r){const a=this.texelByteSize,i=this.bytesPerRow,o=this.height,l=this.data[s];(function(u,h,x,b,k,O,S,P,M,A){const I=b*(S>>=k)*(O>>=k)+x*S+h*P;switch(M){case"r8unorm":return void E(u,I,"8unorm",1,A);case"r8snorm":return void E(u,I,"8snorm",1,A);case"r8uint":return void E(u,I,"8uint",1,A);case"r8sint":return void E(u,I,"8sint",1,A);case"rg8unorm":return void E(u,I,"8unorm",2,A);case"rg8snorm":return void E(u,I,"8snorm",2,A);case"rg8uint":return void E(u,I,"8uint",2,A);case"rg8sint":return void E(u,I,"8sint",2,A);case"rgba8unorm-srgb":case"rgba8unorm":case"bgra8unorm-srgb":case"bgra8unorm":return void E(u,I,"8unorm",4,A);case"rgba8snorm":return void E(u,I,"8snorm",4,A);case"rgba8uint":return void E(u,I,"8uint",4,A);case"rgba8sint":return void E(u,I,"8sint",4,A);case"r16uint":return void E(u,I,"16uint",1,A);case"r16sint":return void E(u,I,"16sint",1,A);case"r16float":return void E(u,I,"16float",1,A);case"rg16uint":return void E(u,I,"16uint",2,A);case"rg16sint":return void E(u,I,"16sint",2,A);case"rg16float":return void E(u,I,"16float",2,A);case"rgba16uint":return void E(u,I,"16uint",4,A);case"rgba16sint":return void E(u,I,"16sint",4,A);case"rgba16float":return void E(u,I,"16float",4,A);case"r32uint":return void E(u,I,"32uint",1,A);case"r32sint":return void E(u,I,"32sint",1,A);case"depth16unorm":case"depth24plus":case"depth24plus-stencil8":case"depth32float":case"depth32float-stencil8":case"r32float":return void E(u,I,"32float",1,A);case"rg32uint":return void E(u,I,"32uint",2,A);case"rg32sint":return void E(u,I,"32sint",2,A);case"rg32float":return void E(u,I,"32float",2,A);case"rgba32uint":return void E(u,I,"32uint",4,A);case"rgba32sint":return void E(u,I,"32sint",4,A);case"rgba32float":return void E(u,I,"32float",4,A);case"rg11b10ufloat":console.error("TODO: rg11b10ufloat not supported for writing")}})(new Uint8Array(l),e,t,n,s,o,i,a,this.format,r)}}(c=>{c[c.token=0]="token",c[c.keyword=1]="keyword",c[c.reserved=2]="reserved"})(m||(m={}));class _{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}}class f{}y=f,f.none=new _("",m.reserved,""),f.eof=new _("EOF",m.token,""),f.reserved={asm:new _("asm",m.reserved,"asm"),bf16:new _("bf16",m.reserved,"bf16"),do:new _("do",m.reserved,"do"),enum:new _("enum",m.reserved,"enum"),f16:new _("f16",m.reserved,"f16"),f64:new _("f64",m.reserved,"f64"),handle:new _("handle",m.reserved,"handle"),i8:new _("i8",m.reserved,"i8"),i16:new _("i16",m.reserved,"i16"),i64:new _("i64",m.reserved,"i64"),mat:new _("mat",m.reserved,"mat"),premerge:new _("premerge",m.reserved,"premerge"),regardless:new _("regardless",m.reserved,"regardless"),typedef:new _("typedef",m.reserved,"typedef"),u8:new _("u8",m.reserved,"u8"),u16:new _("u16",m.reserved,"u16"),u64:new _("u64",m.reserved,"u64"),unless:new _("unless",m.reserved,"unless"),using:new _("using",m.reserved,"using"),vec:new _("vec",m.reserved,"vec"),void:new _("void",m.reserved,"void")},f.keywords={array:new _("array",m.keyword,"array"),atomic:new _("atomic",m.keyword,"atomic"),bool:new _("bool",m.keyword,"bool"),f32:new _("f32",m.keyword,"f32"),i32:new _("i32",m.keyword,"i32"),mat2x2:new _("mat2x2",m.keyword,"mat2x2"),mat2x3:new _("mat2x3",m.keyword,"mat2x3"),mat2x4:new _("mat2x4",m.keyword,"mat2x4"),mat3x2:new _("mat3x2",m.keyword,"mat3x2"),mat3x3:new _("mat3x3",m.keyword,"mat3x3"),mat3x4:new _("mat3x4",m.keyword,"mat3x4"),mat4x2:new _("mat4x2",m.keyword,"mat4x2"),mat4x3:new _("mat4x3",m.keyword,"mat4x3"),mat4x4:new _("mat4x4",m.keyword,"mat4x4"),ptr:new _("ptr",m.keyword,"ptr"),sampler:new _("sampler",m.keyword,"sampler"),sampler_comparison:new _("sampler_comparison",m.keyword,"sampler_comparison"),struct:new _("struct",m.keyword,"struct"),texture_1d:new _("texture_1d",m.keyword,"texture_1d"),texture_2d:new _("texture_2d",m.keyword,"texture_2d"),texture_2d_array:new _("texture_2d_array",m.keyword,"texture_2d_array"),texture_3d:new _("texture_3d",m.keyword,"texture_3d"),texture_cube:new _("texture_cube",m.keyword,"texture_cube"),texture_cube_array:new _("texture_cube_array",m.keyword,"texture_cube_array"),texture_multisampled_2d:new _("texture_multisampled_2d",m.keyword,"texture_multisampled_2d"),texture_storage_1d:new _("texture_storage_1d",m.keyword,"texture_storage_1d"),texture_storage_2d:new _("texture_storage_2d",m.keyword,"texture_storage_2d"),texture_storage_2d_array:new _("texture_storage_2d_array",m.keyword,"texture_storage_2d_array"),texture_storage_3d:new _("texture_storage_3d",m.keyword,"texture_storage_3d"),texture_depth_2d:new _("texture_depth_2d",m.keyword,"texture_depth_2d"),texture_depth_2d_array:new _("texture_depth_2d_array",m.keyword,"texture_depth_2d_array"),texture_depth_cube:new _("texture_depth_cube",m.keyword,"texture_depth_cube"),texture_depth_cube_array:new _("texture_depth_cube_array",m.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new _("texture_depth_multisampled_2d",m.keyword,"texture_depth_multisampled_2d"),texture_external:new _("texture_external",m.keyword,"texture_external"),u32:new _("u32",m.keyword,"u32"),vec2:new _("vec2",m.keyword,"vec2"),vec3:new _("vec3",m.keyword,"vec3"),vec4:new _("vec4",m.keyword,"vec4"),bitcast:new _("bitcast",m.keyword,"bitcast"),block:new _("block",m.keyword,"block"),break:new _("break",m.keyword,"break"),case:new _("case",m.keyword,"case"),continue:new _("continue",m.keyword,"continue"),continuing:new _("continuing",m.keyword,"continuing"),default:new _("default",m.keyword,"default"),diagnostic:new _("diagnostic",m.keyword,"diagnostic"),discard:new _("discard",m.keyword,"discard"),else:new _("else",m.keyword,"else"),enable:new _("enable",m.keyword,"enable"),fallthrough:new _("fallthrough",m.keyword,"fallthrough"),false:new _("false",m.keyword,"false"),fn:new _("fn",m.keyword,"fn"),for:new _("for",m.keyword,"for"),function:new _("function",m.keyword,"function"),if:new _("if",m.keyword,"if"),let:new _("let",m.keyword,"let"),const:new _("const",m.keyword,"const"),loop:new _("loop",m.keyword,"loop"),while:new _("while",m.keyword,"while"),private:new _("private",m.keyword,"private"),read:new _("read",m.keyword,"read"),read_write:new _("read_write",m.keyword,"read_write"),return:new _("return",m.keyword,"return"),requires:new _("requires",m.keyword,"requires"),storage:new _("storage",m.keyword,"storage"),switch:new _("switch",m.keyword,"switch"),true:new _("true",m.keyword,"true"),alias:new _("alias",m.keyword,"alias"),type:new _("type",m.keyword,"type"),uniform:new _("uniform",m.keyword,"uniform"),var:new _("var",m.keyword,"var"),override:new _("override",m.keyword,"override"),workgroup:new _("workgroup",m.keyword,"workgroup"),write:new _("write",m.keyword,"write"),r8unorm:new _("r8unorm",m.keyword,"r8unorm"),r8snorm:new _("r8snorm",m.keyword,"r8snorm"),r8uint:new _("r8uint",m.keyword,"r8uint"),r8sint:new _("r8sint",m.keyword,"r8sint"),r16uint:new _("r16uint",m.keyword,"r16uint"),r16sint:new _("r16sint",m.keyword,"r16sint"),r16float:new _("r16float",m.keyword,"r16float"),rg8unorm:new _("rg8unorm",m.keyword,"rg8unorm"),rg8snorm:new _("rg8snorm",m.keyword,"rg8snorm"),rg8uint:new _("rg8uint",m.keyword,"rg8uint"),rg8sint:new _("rg8sint",m.keyword,"rg8sint"),r32uint:new _("r32uint",m.keyword,"r32uint"),r32sint:new _("r32sint",m.keyword,"r32sint"),r32float:new _("r32float",m.keyword,"r32float"),rg16uint:new _("rg16uint",m.keyword,"rg16uint"),rg16sint:new _("rg16sint",m.keyword,"rg16sint"),rg16float:new _("rg16float",m.keyword,"rg16float"),rgba8unorm:new _("rgba8unorm",m.keyword,"rgba8unorm"),rgba8unorm_srgb:new _("rgba8unorm_srgb",m.keyword,"rgba8unorm_srgb"),rgba8snorm:new _("rgba8snorm",m.keyword,"rgba8snorm"),rgba8uint:new _("rgba8uint",m.keyword,"rgba8uint"),rgba8sint:new _("rgba8sint",m.keyword,"rgba8sint"),bgra8unorm:new _("bgra8unorm",m.keyword,"bgra8unorm"),bgra8unorm_srgb:new _("bgra8unorm_srgb",m.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new _("rgb10a2unorm",m.keyword,"rgb10a2unorm"),rg11b10float:new _("rg11b10float",m.keyword,"rg11b10float"),rg32uint:new _("rg32uint",m.keyword,"rg32uint"),rg32sint:new _("rg32sint",m.keyword,"rg32sint"),rg32float:new _("rg32float",m.keyword,"rg32float"),rgba16uint:new _("rgba16uint",m.keyword,"rgba16uint"),rgba16sint:new _("rgba16sint",m.keyword,"rgba16sint"),rgba16float:new _("rgba16float",m.keyword,"rgba16float"),rgba32uint:new _("rgba32uint",m.keyword,"rgba32uint"),rgba32sint:new _("rgba32sint",m.keyword,"rgba32sint"),rgba32float:new _("rgba32float",m.keyword,"rgba32float"),static_assert:new _("static_assert",m.keyword,"static_assert")},f.tokens={decimal_float_literal:new _("decimal_float_literal",m.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),hex_float_literal:new _("hex_float_literal",m.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),int_literal:new _("int_literal",m.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new _("uint_literal",m.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),name:new _("name",m.token,/([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),ident:new _("ident",m.token,/[_a-zA-Z][0-9a-zA-Z_]*/),and:new _("and",m.token,"&"),and_and:new _("and_and",m.token,"&&"),arrow:new _("arrow ",m.token,"->"),attr:new _("attr",m.token,"@"),forward_slash:new _("forward_slash",m.token,"/"),bang:new _("bang",m.token,"!"),bracket_left:new _("bracket_left",m.token,"["),bracket_right:new _("bracket_right",m.token,"]"),brace_left:new _("brace_left",m.token,"{"),brace_right:new _("brace_right",m.token,"}"),colon:new _("colon",m.token,":"),comma:new _("comma",m.token,","),equal:new _("equal",m.token,"="),equal_equal:new _("equal_equal",m.token,"=="),not_equal:new _("not_equal",m.token,"!="),greater_than:new _("greater_than",m.token,">"),greater_than_equal:new _("greater_than_equal",m.token,">="),shift_right:new _("shift_right",m.token,">>"),less_than:new _("less_than",m.token,"<"),less_than_equal:new _("less_than_equal",m.token,"<="),shift_left:new _("shift_left",m.token,"<<"),modulo:new _("modulo",m.token,"%"),minus:new _("minus",m.token,"-"),minus_minus:new _("minus_minus",m.token,"--"),period:new _("period",m.token,"."),plus:new _("plus",m.token,"+"),plus_plus:new _("plus_plus",m.token,"++"),or:new _("or",m.token,"|"),or_or:new _("or_or",m.token,"||"),paren_left:new _("paren_left",m.token,"("),paren_right:new _("paren_right",m.token,")"),semicolon:new _("semicolon",m.token,";"),star:new _("star",m.token,"*"),tilde:new _("tilde",m.token,"~"),underscore:new _("underscore",m.token,"_"),xor:new _("xor",m.token,"^"),plus_equal:new _("plus_equal",m.token,"+="),minus_equal:new _("minus_equal",m.token,"-="),times_equal:new _("times_equal",m.token,"*="),division_equal:new _("division_equal",m.token,"/="),modulo_equal:new _("modulo_equal",m.token,"%="),and_equal:new _("and_equal",m.token,"&="),or_equal:new _("or_equal",m.token,"|="),xor_equal:new _("xor_equal",m.token,"^="),shift_right_equal:new _("shift_right_equal",m.token,">>="),shift_left_equal:new _("shift_left_equal",m.token,"<<=")},f.simpleTokens={"@":y.tokens.attr,"{":y.tokens.brace_left,"}":y.tokens.brace_right,":":y.tokens.colon,",":y.tokens.comma,"(":y.tokens.paren_left,")":y.tokens.paren_right,";":y.tokens.semicolon},f.literalTokens={"&":y.tokens.and,"&&":y.tokens.and_and,"->":y.tokens.arrow,"/":y.tokens.forward_slash,"!":y.tokens.bang,"[":y.tokens.bracket_left,"]":y.tokens.bracket_right,"=":y.tokens.equal,"==":y.tokens.equal_equal,"!=":y.tokens.not_equal,">":y.tokens.greater_than,">=":y.tokens.greater_than_equal,">>":y.tokens.shift_right,"<":y.tokens.less_than,"<=":y.tokens.less_than_equal,"<<":y.tokens.shift_left,"%":y.tokens.modulo,"-":y.tokens.minus,"--":y.tokens.minus_minus,".":y.tokens.period,"+":y.tokens.plus,"++":y.tokens.plus_plus,"|":y.tokens.or,"||":y.tokens.or_or,"*":y.tokens.star,"~":y.tokens.tilde,_:y.tokens.underscore,"^":y.tokens.xor,"+=":y.tokens.plus_equal,"-=":y.tokens.minus_equal,"*=":y.tokens.times_equal,"/=":y.tokens.division_equal,"%=":y.tokens.modulo_equal,"&=":y.tokens.and_equal,"|=":y.tokens.or_equal,"^=":y.tokens.xor_equal,">>=":y.tokens.shift_right_equal,"<<=":y.tokens.shift_left_equal},f.regexTokens={decimal_float_literal:y.tokens.decimal_float_literal,hex_float_literal:y.tokens.hex_float_literal,int_literal:y.tokens.int_literal,uint_literal:y.tokens.uint_literal,ident:y.tokens.ident},f.storage_class=[y.keywords.function,y.keywords.private,y.keywords.workgroup,y.keywords.uniform,y.keywords.storage],f.access_mode=[y.keywords.read,y.keywords.write,y.keywords.read_write],f.sampler_type=[y.keywords.sampler,y.keywords.sampler_comparison],f.sampled_texture_type=[y.keywords.texture_1d,y.keywords.texture_2d,y.keywords.texture_2d_array,y.keywords.texture_3d,y.keywords.texture_cube,y.keywords.texture_cube_array],f.multisampled_texture_type=[y.keywords.texture_multisampled_2d],f.storage_texture_type=[y.keywords.texture_storage_1d,y.keywords.texture_storage_2d,y.keywords.texture_storage_2d_array,y.keywords.texture_storage_3d],f.depth_texture_type=[y.keywords.texture_depth_2d,y.keywords.texture_depth_2d_array,y.keywords.texture_depth_cube,y.keywords.texture_depth_cube_array,y.keywords.texture_depth_multisampled_2d],f.texture_external_type=[y.keywords.texture_external],f.any_texture_type=[...y.sampled_texture_type,...y.multisampled_texture_type,...y.storage_texture_type,...y.depth_texture_type,...y.texture_external_type],f.texel_format=[y.keywords.r8unorm,y.keywords.r8snorm,y.keywords.r8uint,y.keywords.r8sint,y.keywords.r16uint,y.keywords.r16sint,y.keywords.r16float,y.keywords.rg8unorm,y.keywords.rg8snorm,y.keywords.rg8uint,y.keywords.rg8sint,y.keywords.r32uint,y.keywords.r32sint,y.keywords.r32float,y.keywords.rg16uint,y.keywords.rg16sint,y.keywords.rg16float,y.keywords.rgba8unorm,y.keywords.rgba8unorm_srgb,y.keywords.rgba8snorm,y.keywords.rgba8uint,y.keywords.rgba8sint,y.keywords.bgra8unorm,y.keywords.bgra8unorm_srgb,y.keywords.rgb10a2unorm,y.keywords.rg11b10float,y.keywords.rg32uint,y.keywords.rg32sint,y.keywords.rg32float,y.keywords.rgba16uint,y.keywords.rgba16sint,y.keywords.rgba16float,y.keywords.rgba32uint,y.keywords.rgba32sint,y.keywords.rgba32float],f.const_literal=[y.tokens.int_literal,y.tokens.uint_literal,y.tokens.decimal_float_literal,y.tokens.hex_float_literal,y.keywords.true,y.keywords.false],f.literal_or_ident=[y.tokens.ident,y.tokens.int_literal,y.tokens.uint_literal,y.tokens.decimal_float_literal,y.tokens.hex_float_literal,y.tokens.name],f.element_count_expression=[y.tokens.int_literal,y.tokens.uint_literal,y.tokens.ident],f.template_types=[y.keywords.vec2,y.keywords.vec3,y.keywords.vec4,y.keywords.mat2x2,y.keywords.mat2x3,y.keywords.mat2x4,y.keywords.mat3x2,y.keywords.mat3x3,y.keywords.mat3x4,y.keywords.mat4x2,y.keywords.mat4x3,y.keywords.mat4x4,y.keywords.atomic,y.keywords.bitcast,...y.any_texture_type],f.attribute_name=[y.tokens.ident,y.keywords.block,y.keywords.diagnostic],f.assignment_operators=[y.tokens.equal,y.tokens.plus_equal,y.tokens.minus_equal,y.tokens.times_equal,y.tokens.division_equal,y.tokens.modulo_equal,y.tokens.and_equal,y.tokens.or_equal,y.tokens.xor_equal,y.tokens.shift_right_equal,y.tokens.shift_left_equal],f.increment_operators=[y.tokens.plus_plus,y.tokens.minus_minus];class dt{constructor(e,t,n,s,r){this.type=e,this.lexeme=t,this.line=n,this.start=s,this.end=r}toString(){return this.lexeme}isTemplateType(){return f.template_types.indexOf(this.type)!=-1}isArrayType(){return this.type==f.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class Dn{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=e??""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new dt(f.eof,"",this._line,this._current,this._current)),this._tokens}scanToken(){let e=this._advance();if(e==`
`)return this._line++,!0;if(this._isWhitespace(e))return!0;if(e=="/"){if(this._peekAhead()=="/"){for(;e!=`
`;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if(this._peekAhead()=="*"){this._advance();let a=1;for(;a>0;){if(this._isAtEnd())return!0;if(e=this._advance(),e==`
`)this._line++;else if(e=="*"){if(this._peekAhead()=="/"&&(this._advance(),a--,a==0))return!0}else e=="/"&&this._peekAhead()=="*"&&(this._advance(),a++)}return!0}}const t=f.simpleTokens[e];if(t)return this._addToken(t),!0;let n=f.none;const s=this._isAlpha(e),r=e==="_";if(this._isAlphaNumeric(e)){let a=this._peekAhead();for(;this._isAlphaNumeric(a);)e+=this._advance(),a=this._peekAhead()}if(s){const a=f.keywords[e];if(a)return this._addToken(a),!0}if(s||r)return this._addToken(f.tokens.ident),!0;for(;;){let a=this._findType(e);const i=this._peekAhead();if(e=="-"&&this._tokens.length>0){if(i=="=")return this._current++,e+=i,this._addToken(f.tokens.minus_equal),!0;if(i=="-")return this._current++,e+=i,this._addToken(f.tokens.minus_minus),!0;const o=this._tokens.length-1;if((f.literal_or_ident.indexOf(this._tokens[o].type)!=-1||this._tokens[o].type==f.tokens.paren_right)&&i!=">")return this._addToken(a),!0}if(e==">"&&(i==">"||i=="=")){let o=!1,l=this._tokens.length-1;for(let u=0;u<5&&l>=0&&f.assignment_operators.indexOf(this._tokens[l].type)===-1;++u,--l)if(this._tokens[l].type===f.tokens.less_than){l>0&&this._tokens[l-1].isArrayOrTemplateType()&&(o=!0);break}if(o)return this._addToken(a),!0}if(a===f.none){let o=e,l=0;const u=2;for(let h=0;h<u;++h)if(o+=this._peekAhead(h),a=this._findType(o),a!==f.none){l=h;break}if(a===f.none)return n!==f.none&&(this._current--,this._addToken(n),!0);e=o,this._current+=l+1}if(n=a,this._isAtEnd())break;e+=this._advance()}return n!==f.none&&(this._addToken(n),!0)}_findType(e){for(const n in f.regexTokens){const s=f.regexTokens[n];if(this._match(e,s.rule))return s}return f.literalTokens[e]||f.none}_match(e,t){const n=t.exec(e);return n&&n.index==0&&n[0]==e}_isAtEnd(){return this._current>=this._source.length}_isAlpha(e){return!this._isNumeric(e)&&!this._isWhitespace(e)&&e!=="_"&&e!=="."&&e!=="("&&e!==")"&&e!=="["&&e!=="]"&&e!=="{"&&e!=="}"&&e!==","&&e!==";"&&e!==":"&&e!=="="&&e!=="!"&&e!=="<"&&e!==">"&&e!=="+"&&e!=="-"&&e!=="*"&&e!=="/"&&e!=="%"&&e!=="&"&&e!=="|"&&e!=="^"&&e!=="~"&&e!=="@"&&e!=="#"&&e!=="?"&&e!=="'"&&e!=="`"&&e!=='"'&&e!=="\\"&&e!==`
`&&e!=="\r"&&e!=="	"&&e!=="\0"}_isNumeric(e){return e>="0"&&e<="9"}_isAlphaNumeric(e){return this._isAlpha(e)||this._isNumeric(e)||e==="_"}_isWhitespace(e){return e==" "||e=="	"||e=="\r"}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new dt(e,t,this._line,this._start,this._current))}}function w(c){return Array.isArray(c)||c?.buffer instanceof ArrayBuffer}const Le=new Float32Array(1),Un=new Uint32Array(Le.buffer),Vn=new Uint32Array(Le.buffer),Ee=new Int32Array(1),Mn=new Float32Array(Ee.buffer),Wn=new Uint32Array(Ee.buffer),Oe=new Uint32Array(1),Rn=new Float32Array(Oe.buffer),qn=new Int32Array(Oe.buffer);function mt(c,e,t){if(e===t)return c;if(e==="f32"){if(t==="i32"||t==="x32")return Le[0]=c,Un[0];if(t==="u32")return Le[0]=c,Vn[0]}else if(e==="i32"||e==="x32"){if(t==="f32")return Ee[0]=c,Mn[0];if(t==="u32")return Ee[0]=c,Wn[0]}else if(e==="u32"){if(t==="f32")return Oe[0]=c,Rn[0];if(t==="i32"||t==="x32")return Oe[0]=c,qn[0]}return console.error(`Unsupported cast from ${e} to ${t}`),c}class jn{constructor(e){this.resources=null,this.inUse=!1,this.info=null,this.node=e}}class ve{constructor(e,t){this.align=e,this.size=t}}class Y{constructor(){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new An,this.functions=[],this._types=new Map,this._functions=new Map}_isStorageTexture(e){return e.name=="texture_storage_1d"||e.name=="texture_storage_2d"||e.name=="texture_storage_2d_array"||e.name=="texture_storage_3d"}updateAST(e){for(const t of e)t instanceof me&&this._functions.set(t.name,new jn(t));for(const t of e)if(t instanceof Q){const n=this.getTypeInfo(t,null);n instanceof se&&this.structs.push(n)}for(const t of e)if(t instanceof Ke)this.aliases.push(this._getAliasInfo(t));else{if(t instanceof ze){const n=t,s=this._getAttributeNum(n.attributes,"id",0),r=n.type!=null?this.getTypeInfo(n.type,n.attributes):null;this.overrides.push(new kn(n.name,r,n.attributes,s));continue}if(this._isUniformVar(t)){const n=t,s=this._getAttributeNum(n.attributes,"group",0),r=this._getAttributeNum(n.attributes,"binding",0),a=this.getTypeInfo(n.type,n.attributes),i=new xe(n.name,a,s,r,n.attributes,te.Uniform,n.access);i.access||(i.access="read"),this.uniforms.push(i);continue}if(this._isStorageVar(t)){const n=t,s=this._getAttributeNum(n.attributes,"group",0),r=this._getAttributeNum(n.attributes,"binding",0),a=this.getTypeInfo(n.type,n.attributes),i=this._isStorageTexture(a),o=new xe(n.name,a,s,r,n.attributes,i?te.StorageTexture:te.Storage,n.access);o.access||(o.access="read"),this.storage.push(o);continue}if(this._isTextureVar(t)){const n=t,s=this._getAttributeNum(n.attributes,"group",0),r=this._getAttributeNum(n.attributes,"binding",0),a=this.getTypeInfo(n.type,n.attributes),i=this._isStorageTexture(a),o=new xe(n.name,a,s,r,n.attributes,i?te.StorageTexture:te.Texture,n.access);o.access||(o.access="read"),i?this.storage.push(o):this.textures.push(o);continue}if(this._isSamplerVar(t)){const n=t,s=this._getAttributeNum(n.attributes,"group",0),r=this._getAttributeNum(n.attributes,"binding",0),a=this.getTypeInfo(n.type,n.attributes),i=new xe(n.name,a,s,r,n.attributes,te.Sampler,n.access);this.samplers.push(i);continue}}for(const t of e)if(t instanceof me){const n=this._getAttribute(t,"vertex"),s=this._getAttribute(t,"fragment"),r=this._getAttribute(t,"compute"),a=n||s||r,i=new Tn(t.name,a?.name,t.attributes);i.attributes=t.attributes,i.startLine=t.startLine,i.endLine=t.endLine,this.functions.push(i),this._functions.get(t.name).info=i,a&&(this._functions.get(t.name).inUse=!0,i.inUse=!0,i.resources=this._findResources(t,!!a),i.inputs=this._getInputs(t.args),i.outputs=this._getOutputs(t.returnType),this.entry[a.name].push(i)),i.arguments=t.args.map(o=>new In(o.name,this.getTypeInfo(o.type,o.attributes),o.attributes)),i.returnType=t.returnType?this.getTypeInfo(t.returnType,t.attributes):null;continue}for(const t of this._functions.values())t.info&&(t.info.inUse=t.inUse,this._addCalls(t.node,t.info.calls));for(const t of this._functions.values())t.node.search(n=>{var s,r,a;if(n instanceof Mt){if(n.value)if(w(n.value))for(const i of n.value)for(const o of this.overrides)i===o.name&&((s=t.info)===null||s===void 0||s.overrides.push(o));else for(const i of this.overrides)n.value===i.name&&((r=t.info)===null||r===void 0||r.overrides.push(i))}else if(n instanceof j)for(const i of this.overrides)n.name===i.name&&((a=t.info)===null||a===void 0||a.overrides.push(i))});for(const t of this.uniforms)this._markStructsInUse(t.type);for(const t of this.storage)this._markStructsInUse(t.type)}getFunctionInfo(e){for(const t of this.functions)if(t.name==e)return t;return null}getStructInfo(e){for(const t of this.structs)if(t.name==e)return t;return null}getOverrideInfo(e){for(const t of this.overrides)if(t.name==e)return t;return null}_markStructsInUse(e){if(e)if(e.isStruct){if(e.inUse=!0,e.members)for(const t of e.members)this._markStructsInUse(t.type)}else if(e.isArray)this._markStructsInUse(e.format);else if(e.isTemplate)e.format&&this._markStructsInUse(e.format);else{const t=this._getAlias(e.name);t&&this._markStructsInUse(t)}}_addCalls(e,t){var n;for(const s of e.calls){const r=(n=this._functions.get(s.name))===null||n===void 0?void 0:n.info;r&&t.add(r)}}findResource(e,t,n){if(n){for(const s of this.entry.compute)if(s.name===n){for(const r of s.resources)if(r.group==e&&r.binding==t)return r}for(const s of this.entry.vertex)if(s.name===n){for(const r of s.resources)if(r.group==e&&r.binding==t)return r}for(const s of this.entry.fragment)if(s.name===n){for(const r of s.resources)if(r.group==e&&r.binding==t)return r}}for(const s of this.uniforms)if(s.group==e&&s.binding==t)return s;for(const s of this.storage)if(s.group==e&&s.binding==t)return s;for(const s of this.textures)if(s.group==e&&s.binding==t)return s;for(const s of this.samplers)if(s.group==e&&s.binding==t)return s;return null}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_markStructsFromAST(e){const t=this.getTypeInfo(e,null);this._markStructsInUse(t)}_findResources(e,t){const n=[],s=this,r=[];return e.search(a=>{if(a instanceof Ae)r.push({});else if(a instanceof Se)r.pop();else if(a instanceof ee){const i=a;t&&i.type!==null&&this._markStructsFromAST(i.type),r.length>0&&(r[r.length-1][i.name]=i)}else if(a instanceof Z){const i=a;t&&i.type!==null&&this._markStructsFromAST(i.type)}else if(a instanceof pe){const i=a;t&&i.type!==null&&this._markStructsFromAST(i.type),r.length>0&&(r[r.length-1][i.name]=i)}else if(a instanceof j){const i=a;if(r.length>0&&r[r.length-1][i.name])return;const o=s._findResource(i.name);o&&n.push(o)}else if(a instanceof Xe){const i=a,o=s._functions.get(i.name);o&&(t&&(o.inUse=!0),e.calls.add(o.node),o.resources===null&&(o.resources=s._findResources(o.node,t)),n.push(...o.resources))}else if(a instanceof Ge){const i=a,o=s._functions.get(i.name);o&&(t&&(o.inUse=!0),e.calls.add(o.node),o.resources===null&&(o.resources=s._findResources(o.node,t)),n.push(...o.resources))}}),[...new Map(n.map(a=>[a.name,a])).values()]}getBindGroups(){const e=[];function t(n,s){n>=e.length&&(e.length=n+1),e[n]===void 0&&(e[n]=[]),s>=e[n].length&&(e[n].length=s+1)}for(const n of this.uniforms)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.storage)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.textures)t(n.group,n.binding),e[n.group][n.binding]=n;for(const n of this.samplers)t(n.group,n.binding),e[n.group][n.binding]=n;return e}_getOutputs(e,t=void 0){if(t===void 0&&(t=[]),e instanceof Q)this._getStructOutputs(e,t);else{const n=this._getOutputInfo(e);n!==null&&t.push(n)}return t}_getStructOutputs(e,t){for(const n of e.members)if(n.type instanceof Q)this._getStructOutputs(n.type,t);else{const s=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(s!==null){const r=this.getTypeInfo(n.type,n.type.attributes),a=this._parseInt(s.value),i=new lt(n.name,r,s.name,a);t.push(i)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(t!==null){const n=this.getTypeInfo(e,e.attributes),s=this._parseInt(t.value);return new lt("",n,t.name,s)}return null}_getInputs(e,t=void 0){t===void 0&&(t=[]);for(const n of e)if(n.type instanceof Q)this._getStructInputs(n.type,t);else{const s=this._getInputInfo(n);s!==null&&t.push(s)}return t}_getStructInputs(e,t){for(const n of e.members)if(n.type instanceof Q)this._getStructInputs(n.type,t);else{const s=this._getInputInfo(n);s!==null&&t.push(s)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(t!==null){const n=this._getAttribute(e,"interpolation"),s=this.getTypeInfo(e.type,e.attributes),r=this._parseInt(t.value),a=new wn(e.name,s,t.name,r);return n!==null&&(a.interpolation=this._parseString(n.value)),a}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new bn(e.name,this.getTypeInfo(e.type,null))}getTypeInfoByName(e){for(const t of this.structs)if(t.name==e)return t;for(const t of this.aliases)if(t.name==e)return t.type;return null}getTypeInfo(e,t=null){if(this._types.has(e))return this._types.get(e);if(e instanceof we){const s=e.type?this.getTypeInfo(e.type,e.attributes):null,r=new Me(e.name,s,t);return this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof de){const s=e,r=s.format?this.getTypeInfo(s.format,s.attributes):null,a=new re(s.name,t);return a.format=r,a.count=s.count,this._types.set(e,a),this._updateTypeInfo(a),a}if(e instanceof Q){const s=e,r=new se(s.name,t);r.startLine=s.startLine,r.endLine=s.endLine;for(const a of s.members){const i=this.getTypeInfo(a.type,a.attributes);r.members.push(new ut(a.name,i,a.attributes))}return this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof he){const s=e,r=s.format instanceof v,a=s.format?r?this.getTypeInfo(s.format,null):new H(s.format,null):null,i=new ae(s.name,a,t,s.access);return this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof g){const s=e,r=s.format?this.getTypeInfo(s.format,null):null,a=new ae(s.name,r,t,s.access);return this._types.set(e,a),this._updateTypeInfo(a),a}const n=new H(e.name,t);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var t,n,s;const r=this._getTypeSize(e);if(e.size=(t=r?.size)!==null&&t!==void 0?t:0,e instanceof re&&e.format){const a=this._getTypeSize(e.format);e.stride=Math.max((n=a?.size)!==null&&n!==void 0?n:0,(s=a?.align)!==null&&s!==void 0?s:0),this._updateTypeInfo(e.format)}e instanceof Me&&this._updateTypeInfo(e.format),e instanceof se&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,s=0,r=0,a=0;for(let i=0,o=e.members.length;i<o;++i){const l=e.members[i],u=this._getTypeSize(l);if(!u)continue;(t=this._getAlias(l.type.name))!==null&&t!==void 0||l.type;const h=u.align,x=u.size;n=this._roundUp(h,n+s),s=x,r=n,a=Math.max(a,h),l.offset=n,l.size=x,this._updateTypeInfo(l.type)}e.size=this._roundUp(a,r+s),e.align=a}_getTypeSize(e){var t,n;if(e==null)return null;const s=this._getAttributeNum(e.attributes,"size",0),r=this._getAttributeNum(e.attributes,"align",0);if(e instanceof ut&&(e=e.type),e instanceof H){const a=this._getAlias(e.name);a!==null&&(e=a)}{const a=Y._typeInfo[e.name];if(a!==void 0){const i=((t=e.format)===null||t===void 0?void 0:t.name)==="f16"?2:1;return new ve(Math.max(r,a.align/i),Math.max(s,a.size/i))}}{const a=Y._typeInfo[e.name.substring(0,e.name.length-1)];if(a){const i=e.name[e.name.length-1]==="h"?2:1;return new ve(Math.max(r,a.align/i),Math.max(s,a.size/i))}}if(e instanceof re){let a=e,i=8,o=8;const l=this._getTypeSize(a.format);return l!==null&&(o=l.size,i=l.align),o=a.count*this._getAttributeNum((n=e?.attributes)!==null&&n!==void 0?n:null,"stride",this._roundUp(i,o)),s&&(o=s),new ve(Math.max(r,i),Math.max(s,o))}if(e instanceof se){let a=0,i=0,o=0,l=0,u=0;for(const h of e.members){const x=this._getTypeSize(h.type);x!==null&&(a=Math.max(x.align,a),o=this._roundUp(x.align,o+l),l=x.size,u=o)}return i=this._roundUp(a,u+l),new ve(Math.max(r,a),Math.max(s,i))}return null}_isUniformVar(e){return e instanceof ee&&e.storage=="uniform"}_isStorageVar(e){return e instanceof ee&&e.storage=="storage"}_isTextureVar(e){return e instanceof ee&&e.type!==null&&Y._textureTypes.indexOf(e.type.name)!=-1}_isSamplerVar(e){return e instanceof ee&&e.type!==null&&Y._samplerTypes.indexOf(e.type.name)!=-1}_getAttribute(e,t){const n=e;if(!n||!n.attributes)return null;const s=n.attributes;for(let r of s)if(r.name==t)return r;return null}_getAttributeNum(e,t,n){if(e===null)return n;for(let s of e)if(s.name==t){let r=s!==null&&s.value!==null?s.value:n;return r instanceof Array&&(r=r[0]),typeof r=="number"?r:typeof r=="string"?parseInt(r):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}}Y._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},Y._textureTypes=f.any_texture_type.map(c=>c.name),Y._samplerTypes=f.sampler_type.map(c=>c.name);let Ze=0;class Ye{constructor(e,t,n){this.id=Ze++,this.name=e,this.value=t,this.node=n}clone(){return new Ye(this.name,this.value,this.node)}}class Qe{constructor(e){this.id=Ze++,this.name=e.name,this.node=e}clone(){return new Qe(this.node)}}class Je{constructor(e){this.parent=null,this.variables=new Map,this.functions=new Map,this.currentFunctionName="",this.id=Ze++,e&&(this.parent=e,this.currentFunctionName=e.currentFunctionName)}getVariable(e){var t;return this.variables.has(e)?(t=this.variables.get(e))!==null&&t!==void 0?t:null:this.parent?this.parent.getVariable(e):null}getFunction(e){var t;return this.functions.has(e)?(t=this.functions.get(e))!==null&&t!==void 0?t:null:this.parent?this.parent.getFunction(e):null}createVariable(e,t,n){this.variables.set(e,new Ye(e,t,n??null))}setVariable(e,t,n){const s=this.getVariable(e);s!==null?s.value=t:this.createVariable(e,t,n)}getVariableValue(e){var t;const n=this.getVariable(e);return(t=n?.value)!==null&&t!==void 0?t:null}clone(){return new Je(this)}}class Hn{evalExpression(e,t){return null}getTypeInfo(e){return null}getVariableName(e,t){return""}}class zn{constructor(e){this.exec=e}getTypeInfo(e){return this.exec.getTypeInfo(e)}All(e,t){const n=this.exec.evalExpression(e.args[0],t);let s=!0;if(n instanceof p)return n.data.forEach(r=>{r||(s=!1)}),new d(s?1:0,this.getTypeInfo("bool"));throw new Error(`All() expects a vector argument. Line ${e.line}`)}Any(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p){const s=n.data.some(r=>r);return new d(s?1:0,this.getTypeInfo("bool"))}throw new Error(`Any() expects a vector argument. Line ${e.line}`)}Select(e,t){const n=this.exec.evalExpression(e.args[2],t);if(!(n instanceof d))throw new Error(`Select() expects a bool condition. Line ${e.line}`);return n.value?this.exec.evalExpression(e.args[1],t):this.exec.evalExpression(e.args[0],t)}ArrayLength(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.evalExpression(n,t);if(s instanceof F&&s.typeInfo.size===0){const r=s.typeInfo,a=s.buffer.byteLength/r.stride;return new d(a,this.getTypeInfo("u32"))}return new d(s.typeInfo.size,this.getTypeInfo("u32"))}Abs(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.abs(r)),n.typeInfo);const s=n;return new d(Math.abs(s.value),s.typeInfo)}Acos(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.acos(r)),n.typeInfo);const s=n;return new d(Math.acos(s.value),n.typeInfo)}Acosh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.acosh(r)),n.typeInfo);const s=n;return new d(Math.acosh(s.value),n.typeInfo)}Asin(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.asin(r)),n.typeInfo);const s=n;return new d(Math.asin(s.value),n.typeInfo)}Asinh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.asinh(r)),n.typeInfo);const s=n;return new d(Math.asinh(s.value),n.typeInfo)}Atan(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.atan(r)),n.typeInfo);const s=n;return new d(Math.atan(s.value),n.typeInfo)}Atanh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.atanh(r)),n.typeInfo);const s=n;return new d(Math.atanh(s.value),n.typeInfo)}Atan2(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof p&&s instanceof p)return new p(n.data.map((i,o)=>Math.atan2(i,s.data[o])),n.typeInfo);const r=n,a=s;return new d(Math.atan2(r.value,a.value),n.typeInfo)}Ceil(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.ceil(r)),n.typeInfo);const s=n;return new d(Math.ceil(s.value),n.typeInfo)}_clamp(e,t,n){return Math.min(Math.max(e,t),n)}Clamp(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof p&&s instanceof p&&r instanceof p)return new p(n.data.map((l,u)=>this._clamp(l,s.data[u],r.data[u])),n.typeInfo);const a=n,i=s,o=r;return new d(this._clamp(a.value,i.value,o.value),n.typeInfo)}Cos(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.cos(r)),n.typeInfo);const s=n;return new d(Math.cos(s.value),n.typeInfo)}Cosh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.cosh(r)),n.typeInfo);const s=n;return new d(Math.cos(s.value),n.typeInfo)}CountLeadingZeros(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.clz32(r)),n.typeInfo);const s=n;return new d(Math.clz32(s.value),n.typeInfo)}_countOneBits(e){let t=0;for(;e!==0;)1&e&&t++,e>>=1;return t}CountOneBits(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>this._countOneBits(r)),n.typeInfo);const s=n;return new d(this._countOneBits(s.value),n.typeInfo)}_countTrailingZeros(e){if(e===0)return 32;let t=0;for(;!(1&e);)e>>=1,t++;return t}CountTrailingZeros(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>this._countTrailingZeros(r)),n.typeInfo);const s=n;return new d(this._countTrailingZeros(s.value),n.typeInfo)}Cross(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof p&&s instanceof p){if(n.data.length!==3||s.data.length!==3)return console.error(`Cross() expects 3D vectors. Line ${e.line}`),null;const r=n.data,a=s.data;return new p([r[1]*a[2]-a[1]*r[2],r[2]*a[0]-a[2]*r[0],r[0]*a[1]-a[0]*r[1]],n.typeInfo)}return console.error(`Cross() expects vector arguments. Line ${e.line}`),null}Degrees(e,t){const n=this.exec.evalExpression(e.args[0],t),s=180/Math.PI;return n instanceof p?new p(n.data.map(r=>r*s),n.typeInfo):new d(n.value*s,this.getTypeInfo("f32"))}Determinant(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof T){const s=n.data,r=n.typeInfo.getTypeName(),a=r.endsWith("h")?this.getTypeInfo("f16"):this.getTypeInfo("f32");if(r==="mat2x2"||r==="mat2x2f"||r==="mat2x2h")return new d(s[0]*s[3]-s[1]*s[2],a);if(r==="mat2x3"||r==="mat2x3f"||r==="mat2x3h")return new d(s[0]*(s[4]*s[8]-s[5]*s[7])-s[1]*(s[3]*s[8]-s[5]*s[6])+s[2]*(s[3]*s[7]-s[4]*s[6]),a);if(r==="mat2x4"||r==="mat2x4f"||r==="mat2x4h")console.error(`TODO: Determinant for ${r}`);else if(r==="mat3x2"||r==="mat3x2f"||r==="mat3x2h")console.error(`TODO: Determinant for ${r}`);else{if(r==="mat3x3"||r==="mat3x3f"||r==="mat3x3h")return new d(s[0]*(s[4]*s[8]-s[5]*s[7])-s[1]*(s[3]*s[8]-s[5]*s[6])+s[2]*(s[3]*s[7]-s[4]*s[6]),a);r==="mat3x4"||r==="mat3x4f"||r==="mat3x4h"||r==="mat4x2"||r==="mat4x2f"||r==="mat4x2h"||r==="mat4x3"||r==="mat4x3f"||r==="mat4x3h"?console.error(`TODO: Determinant for ${r}`):r!=="mat4x4"&&r!=="mat4x4f"&&r!=="mat4x4h"||console.error(`TODO: Determinant for ${r}`)}}return console.error(`Determinant expects a matrix argument. Line ${e.line}`),null}Distance(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof p&&s instanceof p){let i=0;for(let o=0;o<n.data.length;++o)i+=(n.data[o]-s.data[o])*(n.data[o]-s.data[o]);return new d(Math.sqrt(i),this.getTypeInfo("f32"))}const r=n,a=s;return new d(Math.abs(r.value-a.value),n.typeInfo)}_dot(e,t){let n=0;for(let s=0;s<e.length;++s)n+=t[s]*e[s];return n}Dot(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);return n instanceof p&&s instanceof p?new d(this._dot(n.data,s.data),this.getTypeInfo("f32")):(console.error(`Dot() expects vector arguments. Line ${e.line}`),null)}Dot4U8Packed(e,t){return console.error(`TODO: dot4U8Packed. Line ${e.line}`),null}Dot4I8Packed(e,t){return console.error(`TODO: dot4I8Packed. Line ${e.line}`),null}Exp(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.exp(r)),n.typeInfo);const s=n;return new d(Math.exp(s.value),n.typeInfo)}Exp2(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.pow(2,r)),n.typeInfo);const s=n;return new d(Math.pow(2,s.value),n.typeInfo)}ExtractBits(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(s.typeInfo.name!=="u32"&&s.typeInfo.name!=="x32")return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`),null;if(r.typeInfo.name!=="u32"&&r.typeInfo.name!=="x32")return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`),null;const a=s.value,i=r.value;if(n instanceof p)return new p(n.data.map(l=>l>>a&(1<<i)-1),n.typeInfo);if(n.typeInfo.name!=="i32"&&n.typeInfo.name!=="x32")return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`),null;const o=n.value;return new d(o>>a&(1<<i)-1,this.getTypeInfo("i32"))}FaceForward(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof p&&s instanceof p&&r instanceof p){const a=this._dot(s.data,r.data);return new p(a<0?Array.from(n.data):n.data.map(i=>-i),n.typeInfo)}return console.error(`FaceForward() expects vector arguments. Line ${e.line}`),null}_firstLeadingBit(e){return e===0?-1:31-Math.clz32(e)}FirstLeadingBit(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>this._firstLeadingBit(r)),n.typeInfo);const s=n;return new d(this._firstLeadingBit(s.value),n.typeInfo)}_firstTrailingBit(e){return e===0?-1:Math.log2(e&-e)}FirstTrailingBit(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>this._firstTrailingBit(r)),n.typeInfo);const s=n;return new d(this._firstTrailingBit(s.value),n.typeInfo)}Floor(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.floor(r)),n.typeInfo);const s=n;return new d(Math.floor(s.value),n.typeInfo)}Fma(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof p&&s instanceof p&&r instanceof p)return n.data.length!==s.data.length||n.data.length!==r.data.length?(console.error(`Fma() expects vectors of the same length. Line ${e.line}`),null):new p(n.data.map((l,u)=>l*s.data[u]+r.data[u]),n.typeInfo);const a=n,i=s,o=r;return new d(a.value*i.value+o.value,a.typeInfo)}Fract(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>r-Math.floor(r)),n.typeInfo);const s=n;return new d(s.value-Math.floor(s.value),n.typeInfo)}Frexp(e,t){return console.error(`TODO: frexp. Line ${e.line}`),null}InsertBits(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t),a=this.exec.evalExpression(e.args[3],t);if(r.typeInfo.name!=="u32"&&r.typeInfo.name!=="x32")return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`),null;const i=r.value,o=(1<<a.value)-1<<i,l=~o;if(n instanceof p&&s instanceof p)return new p(n.data.map((x,b)=>x&l|s.data[b]<<i&o),n.typeInfo);const u=n.value,h=s.value;return new d(u&l|h<<i&o,n.typeInfo)}InverseSqrt(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>1/Math.sqrt(r)),n.typeInfo);const s=n;return new d(1/Math.sqrt(s.value),n.typeInfo)}Ldexp(e,t){return console.error(`TODO: ldexp. Line ${e.line}`),null}Length(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p){let r=0;return n.data.forEach(a=>{r+=a*a}),new d(Math.sqrt(r),this.getTypeInfo("f32"))}const s=n;return new d(Math.abs(s.value),n.typeInfo)}Log(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.log(r)),n.typeInfo);const s=n;return new d(Math.log(s.value),n.typeInfo)}Log2(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.log2(r)),n.typeInfo);const s=n;return new d(Math.log2(s.value),n.typeInfo)}Max(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof p&&s instanceof p)return new p(n.data.map((i,o)=>Math.max(i,s.data[o])),n.typeInfo);const r=n,a=s;return new d(Math.max(r.value,a.value),n.typeInfo)}Min(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof p&&s instanceof p)return new p(n.data.map((i,o)=>Math.min(i,s.data[o])),n.typeInfo);const r=n,a=s;return new d(Math.min(r.value,a.value),n.typeInfo)}Mix(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof p&&s instanceof p&&r instanceof p)return new p(n.data.map((o,l)=>n.data[l]*(1-r.data[l])+s.data[l]*r.data[l]),n.typeInfo);const a=s,i=r;return new d(n.value*(1-i.value)+a.value*i.value,n.typeInfo)}Modf(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof p&&s instanceof p)return new p(n.data.map((a,i)=>a%s.data[i]),n.typeInfo);const r=s;return new d(n.value%r.value,n.typeInfo)}Normalize(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p){const s=this.Length(e,t).value;return new p(n.data.map(r=>r/s),n.typeInfo)}return console.error(`Normalize() expects a vector argument. Line ${e.line}`),null}Pow(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof p&&s instanceof p)return new p(n.data.map((i,o)=>Math.pow(i,s.data[o])),n.typeInfo);const r=n,a=s;return new d(Math.pow(r.value,a.value),n.typeInfo)}QuantizeToF16(e,t){const n=this.exec.evalExpression(e.args[0],t);return n instanceof p?new p(n.data.map(s=>s),n.typeInfo):new d(n.value,n.typeInfo)}Radians(e,t){const n=this.exec.evalExpression(e.args[0],t);return n instanceof p?new p(n.data.map(s=>s*Math.PI/180),n.typeInfo):new d(n.value*Math.PI/180,this.getTypeInfo("f32"))}Reflect(e,t){let n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof p&&s instanceof p){const r=this._dot(n.data,s.data);return new p(n.data.map((a,i)=>a-2*r*s.data[i]),n.typeInfo)}return console.error(`Reflect() expects vector arguments. Line ${e.line}`),null}Refract(e,t){let n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof p&&s instanceof p&&r instanceof d){const a=this._dot(s.data,n.data);return new p(n.data.map((i,o)=>{const l=1-r.value*r.value*(1-a*a);if(l<0)return 0;const u=Math.sqrt(l);return r.value*i-(r.value*a+u)*s.data[o]}),n.typeInfo)}return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`),null}ReverseBits(e,t){return console.error(`TODO: reverseBits. Line ${e.line}`),null}Round(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.round(r)),n.typeInfo);const s=n;return new d(Math.round(s.value),n.typeInfo)}Saturate(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.min(Math.max(r,0),1)),n.typeInfo);const s=n;return new d(Math.min(Math.max(s.value,0),1),n.typeInfo)}Sign(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.sign(r)),n.typeInfo);const s=n;return new d(Math.sign(s.value),n.typeInfo)}Sin(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.sin(r)),n.typeInfo);const s=n;return new d(Math.sin(s.value),n.typeInfo)}Sinh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.sinh(r)),n.typeInfo);const s=n;return new d(Math.sinh(s.value),n.typeInfo)}_smoothstep(e,t,n){const s=Math.min(Math.max((n-e)/(t-e),0),1);return s*s*(3-2*s)}SmoothStep(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(r instanceof p&&n instanceof p&&s instanceof p)return new p(r.data.map((l,u)=>this._smoothstep(n.data[u],s.data[u],l)),r.typeInfo);const a=n,i=s,o=r;return new d(this._smoothstep(a.value,i.value,o.value),r.typeInfo)}Sqrt(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.sqrt(r)),n.typeInfo);const s=n;return new d(Math.sqrt(s.value),n.typeInfo)}Step(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(s instanceof p&&n instanceof p)return new p(s.data.map((a,i)=>a<n.data[i]?0:1),s.typeInfo);const r=n;return new d(s.value<r.value?0:1,r.typeInfo)}Tan(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.tan(r)),n.typeInfo);const s=n;return new d(Math.tan(s.value),n.typeInfo)}Tanh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.tanh(r)),n.typeInfo);const s=n;return new d(Math.tanh(s.value),n.typeInfo)}_getTransposeType(e){const t=e.getTypeName();return t==="mat2x2f"||t==="mat2x2h"?e:t==="mat2x3f"?this.getTypeInfo("mat3x2f"):t==="mat2x3h"?this.getTypeInfo("mat3x2h"):t==="mat2x4f"?this.getTypeInfo("mat4x2f"):t==="mat2x4h"?this.getTypeInfo("mat4x2h"):t==="mat3x2f"?this.getTypeInfo("mat2x3f"):t==="mat3x2h"?this.getTypeInfo("mat2x3h"):t==="mat3x3f"||t==="mat3x3h"?e:t==="mat3x4f"?this.getTypeInfo("mat4x3f"):t==="mat3x4h"?this.getTypeInfo("mat4x3h"):t==="mat4x2f"?this.getTypeInfo("mat2x4f"):t==="mat4x2h"?this.getTypeInfo("mat2x4h"):t==="mat4x3f"?this.getTypeInfo("mat3x4f"):t==="mat4x3h"?this.getTypeInfo("mat3x4h"):(t==="mat4x4f"||t==="mat4x4h"||console.error(`Invalid matrix type ${t}`),e)}Transpose(e,t){const n=this.exec.evalExpression(e.args[0],t);if(!(n instanceof T))return console.error(`Transpose() expects a matrix argument. Line ${e.line}`),null;const s=this._getTransposeType(n.typeInfo);if(n.typeInfo.name==="mat2x2"||n.typeInfo.name==="mat2x2f"||n.typeInfo.name==="mat2x2h"){const r=n.data;return new T([r[0],r[2],r[1],r[3]],s)}if(n.typeInfo.name==="mat2x3"||n.typeInfo.name==="mat2x3f"||n.typeInfo.name==="mat2x3h"){const r=n.data;return new T([r[0],r[3],r[6],r[1],r[4],r[7]],s)}if(n.typeInfo.name==="mat2x4"||n.typeInfo.name==="mat2x4f"||n.typeInfo.name==="mat2x4h"){const r=n.data;return new T([r[0],r[4],r[8],r[12],r[1],r[5],r[9],r[13]],s)}if(n.typeInfo.name==="mat3x2"||n.typeInfo.name==="mat3x2f"||n.typeInfo.name==="mat3x2h"){const r=n.data;return new T([r[0],r[3],r[1],r[4],r[2],r[5]],s)}if(n.typeInfo.name==="mat3x3"||n.typeInfo.name==="mat3x3f"||n.typeInfo.name==="mat3x3h"){const r=n.data;return new T([r[0],r[3],r[6],r[1],r[4],r[7],r[2],r[5],r[8]],s)}if(n.typeInfo.name==="mat3x4"||n.typeInfo.name==="mat3x4f"||n.typeInfo.name==="mat3x4h"){const r=n.data;return new T([r[0],r[4],r[8],r[12],r[1],r[5],r[9],r[13],r[2],r[6],r[10],r[14]],s)}if(n.typeInfo.name==="mat4x2"||n.typeInfo.name==="mat4x2f"||n.typeInfo.name==="mat4x2h"){const r=n.data;return new T([r[0],r[4],r[1],r[5],r[2],r[6]],s)}if(n.typeInfo.name==="mat4x3"||n.typeInfo.name==="mat4x3f"||n.typeInfo.name==="mat4x3h"){const r=n.data;return new T([r[0],r[4],r[8],r[1],r[5],r[9],r[2],r[6],r[10]],s)}if(n.typeInfo.name==="mat4x4"||n.typeInfo.name==="mat4x4f"||n.typeInfo.name==="mat4x4h"){const r=n.data;return new T([r[0],r[4],r[8],r[12],r[1],r[5],r[9],r[13],r[2],r[6],r[10],r[14],r[3],r[7],r[11],r[15]],s)}return console.error(`Invalid matrix type ${n.typeInfo.name}`),null}Trunc(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof p)return new p(n.data.map(r=>Math.trunc(r)),n.typeInfo);const s=n;return new d(Math.trunc(s.value),n.typeInfo)}Dpdx(e,t){return console.error(`TODO: dpdx. Line ${e.line}`),null}DpdxCoarse(e,t){return console.error(`TODO: dpdxCoarse. Line ${e.line}`),null}DpdxFine(e,t){return console.error("TODO: dpdxFine"),null}Dpdy(e,t){return console.error("TODO: dpdy"),null}DpdyCoarse(e,t){return console.error("TODO: dpdyCoarse"),null}DpdyFine(e,t){return console.error("TODO: dpdyFine"),null}Fwidth(e,t){return console.error("TODO: fwidth"),null}FwidthCoarse(e,t){return console.error("TODO: fwidthCoarse"),null}FwidthFine(e,t){return console.error("TODO: fwidthFine"),null}TextureDimensions(e,t){const n=e.args[0],s=e.args.length>1?this.exec.evalExpression(e.args[1],t).value:0;if(n instanceof j){const r=n.name,a=t.getVariableValue(r);if(a instanceof J){if(s<0||s>=a.mipLevelCount)return console.error(`Invalid mip level for textureDimensions. Line ${e.line}`),null;const i=a.getMipLevelSize(s),o=a.dimension;return o==="1d"?new d(i[0],this.getTypeInfo("u32")):o==="3d"?new p(i,this.getTypeInfo("vec3u")):o==="2d"?new p(i.slice(0,2),this.getTypeInfo("vec2u")):(console.error(`Invalid texture dimension ${o} not found. Line ${e.line}`),null)}return console.error(`Texture ${r} not found. Line ${e.line}`),null}return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`),null}TextureGather(e,t){return console.error("TODO: textureGather"),null}TextureGatherCompare(e,t){return console.error("TODO: textureGatherCompare"),null}TextureLoad(e,t){const n=e.args[0],s=this.exec.evalExpression(e.args[1],t),r=e.args.length>2?this.exec.evalExpression(e.args[2],t).value:0;if(!(s instanceof p)||s.data.length!==2)return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`),null;if(n instanceof j){const a=n.name,i=t.getVariableValue(a);if(i instanceof J){const o=Math.floor(s.data[0]),l=Math.floor(s.data[1]);if(o<0||o>=i.width||l<0||l>=i.height)return console.error(`Texture ${a} out of bounds. Line ${e.line}`),null;const u=i.getPixel(o,l,0,r);return u===null?(console.error(`Invalid texture format for textureLoad. Line ${e.line}`),null):new p(u,this.getTypeInfo("vec4f"))}return console.error(`Texture ${a} not found. Line ${e.line}`),null}return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`),null}TextureNumLayers(e,t){const n=e.args[0];if(n instanceof j){const s=n.name,r=t.getVariableValue(s);return r instanceof J?new d(r.depthOrArrayLayers,this.getTypeInfo("u32")):(console.error(`Texture ${s} not found. Line ${e.line}`),null)}return console.error(`Invalid texture argument for textureNumLayers. Line ${e.line}`),null}TextureNumLevels(e,t){const n=e.args[0];if(n instanceof j){const s=n.name,r=t.getVariableValue(s);return r instanceof J?new d(r.mipLevelCount,this.getTypeInfo("u32")):(console.error(`Texture ${s} not found. Line ${e.line}`),null)}return console.error(`Invalid texture argument for textureNumLevels. Line ${e.line}`),null}TextureNumSamples(e,t){const n=e.args[0];if(n instanceof j){const s=n.name,r=t.getVariableValue(s);return r instanceof J?new d(r.sampleCount,this.getTypeInfo("u32")):(console.error(`Texture ${s} not found. Line ${e.line}`),null)}return console.error(`Invalid texture argument for textureNumSamples. Line ${e.line}`),null}TextureSample(e,t){return console.error("TODO: textureSample"),null}TextureSampleBias(e,t){return console.error("TODO: textureSampleBias"),null}TextureSampleCompare(e,t){return console.error("TODO: textureSampleCompare"),null}TextureSampleCompareLevel(e,t){return console.error("TODO: textureSampleCompareLevel"),null}TextureSampleGrad(e,t){return console.error("TODO: textureSampleGrad"),null}TextureSampleLevel(e,t){return console.error("TODO: textureSampleLevel"),null}TextureSampleBaseClampToEdge(e,t){return console.error("TODO: textureSampleBaseClampToEdge"),null}TextureStore(e,t){const n=e.args[0],s=this.exec.evalExpression(e.args[1],t),r=e.args.length===4?this.exec.evalExpression(e.args[2],t).value:0,a=e.args.length===4?this.exec.evalExpression(e.args[3],t).data:this.exec.evalExpression(e.args[2],t).data;if(a.length!==4)return console.error(`Invalid value argument for textureStore. Line ${e.line}`),null;if(!(s instanceof p)||s.data.length!==2)return console.error(`Invalid UV argument for textureStore. Line ${e.line}`),null;if(n instanceof j){const i=n.name,o=t.getVariableValue(i);if(o instanceof J){const l=o.getMipLevelSize(0),u=Math.floor(s.data[0]),h=Math.floor(s.data[1]);return u<0||u>=l[0]||h<0||h>=l[1]?(console.error(`Texture ${i} out of bounds. Line ${e.line}`),null):(o.setPixel(u,h,0,r,Array.from(a)),null)}return console.error(`Texture ${i} not found. Line ${e.line}`),null}return console.error(`Invalid texture argument for textureStore. Line ${e.line}`),null}AtomicLoad(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t);return t.getVariable(s).value.getSubData(this.exec,n.postfix,t)}AtomicStore(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t);return o instanceof d&&i instanceof d&&(o.value=i.value),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),null}AtomicAdd(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new d(o.value,o.typeInfo);return o instanceof d&&i instanceof d&&(o.value+=i.value),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicSub(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new d(o.value,o.typeInfo);return o instanceof d&&i instanceof d&&(o.value-=i.value),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicMax(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new d(o.value,o.typeInfo);return o instanceof d&&i instanceof d&&(o.value=Math.max(o.value,i.value)),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicMin(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new d(o.value,o.typeInfo);return o instanceof d&&i instanceof d&&(o.value=Math.min(o.value,i.value)),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicAnd(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new d(o.value,o.typeInfo);return o instanceof d&&i instanceof d&&(o.value=o.value&i.value),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicOr(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new d(o.value,o.typeInfo);return o instanceof d&&i instanceof d&&(o.value=o.value|i.value),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicXor(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new d(o.value,o.typeInfo);return o instanceof d&&i instanceof d&&(o.value=o.value^i.value),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicExchange(e,t){let n=e.args[0];n instanceof C&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new d(o.value,o.typeInfo);return o instanceof d&&i instanceof d&&(o.value=i.value),r.value instanceof F&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicCompareExchangeWeak(e,t){return console.error("TODO: atomicCompareExchangeWeak"),null}Pack4x8snorm(e,t){return console.error("TODO: pack4x8snorm"),null}Pack4x8unorm(e,t){return console.error("TODO: pack4x8unorm"),null}Pack4xI8(e,t){return console.error("TODO: pack4xI8"),null}Pack4xU8(e,t){return console.error("TODO: pack4xU8"),null}Pack4x8Clamp(e,t){return console.error("TODO: pack4x8Clamp"),null}Pack4xU8Clamp(e,t){return console.error("TODO: pack4xU8Clamp"),null}Pack2x16snorm(e,t){return console.error("TODO: pack2x16snorm"),null}Pack2x16unorm(e,t){return console.error("TODO: pack2x16unorm"),null}Pack2x16float(e,t){return console.error("TODO: pack2x16float"),null}Unpack4x8snorm(e,t){return console.error("TODO: unpack4x8snorm"),null}Unpack4x8unorm(e,t){return console.error("TODO: unpack4x8unorm"),null}Unpack4xI8(e,t){return console.error("TODO: unpack4xI8"),null}Unpack4xU8(e,t){return console.error("TODO: unpack4xU8"),null}Unpack2x16snorm(e,t){return console.error("TODO: unpack2x16snorm"),null}Unpack2x16unorm(e,t){return console.error("TODO: unpack2x16unorm"),null}Unpack2x16float(e,t){return console.error("TODO: unpack2x16float"),null}StorageBarrier(e,t){return null}TextureBarrier(e,t){return null}WorkgroupBarrier(e,t){return null}WorkgroupUniformLoad(e,t){return null}SubgroupAdd(e,t){return console.error("TODO: subgroupAdd"),null}SubgroupExclusiveAdd(e,t){return console.error("TODO: subgroupExclusiveAdd"),null}SubgroupInclusiveAdd(e,t){return console.error("TODO: subgroupInclusiveAdd"),null}SubgroupAll(e,t){return console.error("TODO: subgroupAll"),null}SubgroupAnd(e,t){return console.error("TODO: subgroupAnd"),null}SubgroupAny(e,t){return console.error("TODO: subgroupAny"),null}SubgroupBallot(e,t){return console.error("TODO: subgroupBallot"),null}SubgroupBroadcast(e,t){return console.error("TODO: subgroupBroadcast"),null}SubgroupBroadcastFirst(e,t){return console.error("TODO: subgroupBroadcastFirst"),null}SubgroupElect(e,t){return console.error("TODO: subgroupElect"),null}SubgroupMax(e,t){return console.error("TODO: subgroupMax"),null}SubgroupMin(e,t){return console.error("TODO: subgroupMin"),null}SubgroupMul(e,t){return console.error("TODO: subgroupMul"),null}SubgroupExclusiveMul(e,t){return console.error("TODO: subgroupExclusiveMul"),null}SubgroupInclusiveMul(e,t){return console.error("TODO: subgroupInclusiveMul"),null}SubgroupOr(e,t){return console.error("TODO: subgroupOr"),null}SubgroupShuffle(e,t){return console.error("TODO: subgroupShuffle"),null}SubgroupShuffleDown(e,t){return console.error("TODO: subgroupShuffleDown"),null}SubgroupShuffleUp(e,t){return console.error("TODO: subgroupShuffleUp"),null}SubgroupShuffleXor(e,t){return console.error("TODO: subgroupShuffleXor"),null}SubgroupXor(e,t){return console.error("TODO: subgroupXor"),null}QuadBroadcast(e,t){return console.error("TODO: quadBroadcast"),null}QuadSwapDiagonal(e,t){return console.error("TODO: quadSwapDiagonal"),null}QuadSwapX(e,t){return console.error("TODO: quadSwapX"),null}QuadSwapY(e,t){return console.error("TODO: quadSwapY"),null}}const Fe={vec2:2,vec2f:2,vec2i:2,vec2u:2,vec2b:2,vec2h:2,vec3:3,vec3f:3,vec3i:3,vec3u:3,vec3b:3,vec3h:3,vec4:4,vec4f:4,vec4i:4,vec4u:4,vec4b:4,vec4h:4},R={mat2x2:[2,2,4],mat2x2f:[2,2,4],mat2x2h:[2,2,4],mat2x3:[2,3,6],mat2x3f:[2,3,6],mat2x3h:[2,3,6],mat2x4:[2,4,8],mat2x4f:[2,4,8],mat2x4h:[2,4,8],mat3x2:[3,2,6],mat3x2f:[3,2,6],mat3x2h:[3,2,6],mat3x3:[3,3,9],mat3x3f:[3,3,9],mat3x3h:[3,3,9],mat3x4:[3,4,12],mat3x4f:[3,4,12],mat3x4h:[3,4,12],mat4x2:[4,2,8],mat4x2f:[4,2,8],mat4x2h:[4,2,8],mat4x3:[4,3,12],mat4x3f:[4,3,12],mat4x3h:[4,3,12],mat4x4:[4,4,16],mat4x4f:[4,4,16],mat4x4h:[4,4,16]};class V extends Hn{constructor(e,t){var n;super(),this.ast=e??[],this.reflection=new Y,this.reflection.updateAST(this.ast),this.context=(n=t?.clone())!==null&&n!==void 0?n:new Je,this.builtins=new zn(this),this.typeInfo={bool:this.getTypeInfo(v.bool),i32:this.getTypeInfo(v.i32),u32:this.getTypeInfo(v.u32),f32:this.getTypeInfo(v.f32),f16:this.getTypeInfo(v.f16),vec2f:this.getTypeInfo(g.vec2f),vec2u:this.getTypeInfo(g.vec2u),vec2i:this.getTypeInfo(g.vec2i),vec2h:this.getTypeInfo(g.vec2h),vec3f:this.getTypeInfo(g.vec3f),vec3u:this.getTypeInfo(g.vec3u),vec3i:this.getTypeInfo(g.vec3i),vec3h:this.getTypeInfo(g.vec3h),vec4f:this.getTypeInfo(g.vec4f),vec4u:this.getTypeInfo(g.vec4u),vec4i:this.getTypeInfo(g.vec4i),vec4h:this.getTypeInfo(g.vec4h),mat2x2f:this.getTypeInfo(g.mat2x2f),mat2x3f:this.getTypeInfo(g.mat2x3f),mat2x4f:this.getTypeInfo(g.mat2x4f),mat3x2f:this.getTypeInfo(g.mat3x2f),mat3x3f:this.getTypeInfo(g.mat3x3f),mat3x4f:this.getTypeInfo(g.mat3x4f),mat4x2f:this.getTypeInfo(g.mat4x2f),mat4x3f:this.getTypeInfo(g.mat4x3f),mat4x4f:this.getTypeInfo(g.mat4x4f)}}getVariableValue(e){var t,n;const s=(n=(t=this.context.getVariable(e))===null||t===void 0?void 0:t.value)!==null&&n!==void 0?n:null;if(s===null)return null;if(s instanceof d)return s.value;if(s instanceof p||s instanceof T)return Array.from(s.data);if(s instanceof F&&s.typeInfo instanceof re){if(s.typeInfo.format.name==="u32")return Array.from(new Uint32Array(s.buffer,s.offset,s.typeInfo.count));if(s.typeInfo.format.name==="i32")return Array.from(new Int32Array(s.buffer,s.offset,s.typeInfo.count));if(s.typeInfo.format.name==="f32")return Array.from(new Float32Array(s.buffer,s.offset,s.typeInfo.count))}return console.error(`Unsupported return variable type ${s.typeInfo.name}`),null}execute(e){(e=e??{}).constants&&this._setOverrides(e.constants,this.context),this._execStatements(this.ast,this.context)}dispatchWorkgroups(e,t,n,s){const r=this.context.clone();(s=s??{}).constants&&this._setOverrides(s.constants,r),this._execStatements(this.ast,r);const a=r.getFunction(e);if(!a)return void console.error(`Function ${e} not found`);if(typeof t=="number")t=[t,1,1];else{if(t.length===0)return void console.error("Invalid dispatch count");t.length===1?t=[t[0],1,1]:t.length===2?t=[t[0],t[1],1]:t.length>3&&(t=[t[0],t[1],t[2]])}const i=t[0],o=t[1],l=t[2],u=this.getTypeInfo("vec3u");r.setVariable("@num_workgroups",new p(t,u));const h=this.reflection.getFunctionInfo(e);h===null&&console.error(`Function ${e} not found in reflection data`);for(const x in n)for(const b in n[x]){const k=n[x][b];r.variables.forEach(O=>{var S;const P=O.node;if(P?.attributes){let M=null,A=null;for(const I of P.attributes)I.name==="binding"?M=I.value:I.name==="group"&&(A=I.value);if(b==M&&x==A){let I=!1;for(const W of h.resources)if(W.name===O.name&&W.group===parseInt(x)&&W.binding===parseInt(b)){I=!0;break}if(I)if(k.texture!==void 0&&k.descriptor!==void 0){const W=new J(k.texture,this.getTypeInfo(P.type),k.descriptor,(S=k.texture.view)!==null&&S!==void 0?S:null);O.value=W}else k.uniform!==void 0?O.value=new F(k.uniform,this.getTypeInfo(P.type)):O.value=new F(k,this.getTypeInfo(P.type))}}})}for(let x=0;x<l;++x)for(let b=0;b<o;++b)for(let k=0;k<i;++k)r.setVariable("@workgroup_id",new p([k,b,x],this.getTypeInfo("vec3u"))),this._dispatchWorkgroup(a,[k,b,x],r)}execStatement(e,t){if(e instanceof Ot)return this.evalExpression(e.value,t);if(e instanceof Nt){if(e.condition){const n=this.evalExpression(e.condition,t);if(!(n instanceof d))throw new Error("Invalid break-if condition");if(!n.value)return null}return V._breakObj}if(e instanceof Bt)return V._continueObj;if(e instanceof pe)this._let(e,t);else if(e instanceof ee)this._var(e,t);else if(e instanceof be)this._const(e,t);else if(e instanceof me)this._function(e,t);else{if(e instanceof Et)return this._if(e,t);if(e instanceof Lt)return this._switch(e,t);if(e instanceof It)return this._for(e,t);if(e instanceof kt)return this._while(e,t);if(e instanceof St)return this._loop(e,t);if(e instanceof We){const n=t.clone();return n.currentFunctionName=t.currentFunctionName,this._execStatements(e.body,n)}if(e instanceof At)this._assign(e,t);else if(e instanceof Tt)this._increment(e,t);else{if(e instanceof Q)return null;if(e instanceof ze){const n=e.name;t.getVariable(n)===null&&t.setVariable(n,new d(0,this.getTypeInfo("u32")))}else if(e instanceof Ge)this._call(e,t);else{if(e instanceof Pt||e instanceof Ke)return null;console.error("Invalid statement type.",e,`Line ${e.line}`)}}}return null}evalExpression(e,t){return e instanceof K?this._evalBinaryOp(e,t):e instanceof $?this._evalLiteral(e,t):e instanceof j?this._evalVariable(e,t):e instanceof Xe?this._evalCall(e,t):e instanceof Z?this._evalCreate(e,t):e instanceof Ft?this._evalConst(e,t):e instanceof Ct?this._evalBitcast(e,t):e instanceof C?this._evalUnaryOp(e,t):(console.error("Invalid expression type",e,`Line ${e.line}`),null)}getTypeInfo(e){var t;if(e instanceof v){const s=this.reflection.getTypeInfo(e);if(s!==null)return s}let n=(t=this.typeInfo[e])!==null&&t!==void 0?t:null;return n!==null||(n=this.reflection.getTypeInfoByName(e)),n}_setOverrides(e,t){for(const n in e){const s=e[n],r=this.reflection.getOverrideInfo(n);r!==null?(r.type===null&&(r.type=this.getTypeInfo("u32")),r.type.name==="u32"||r.type.name==="i32"||r.type.name==="f32"||r.type.name==="f16"?t.setVariable(n,new d(s,r.type)):r.type.name==="bool"?t.setVariable(n,new d(s?1:0,r.type)):r.type.name==="vec2"||r.type.name==="vec3"||r.type.name==="vec4"||r.type.name==="vec2f"||r.type.name==="vec3f"||r.type.name==="vec4f"||r.type.name==="vec2i"||r.type.name==="vec3i"||r.type.name==="vec4i"||r.type.name==="vec2u"||r.type.name==="vec3u"||r.type.name==="vec4u"||r.type.name==="vec2h"||r.type.name==="vec3h"||r.type.name==="vec4h"?t.setVariable(n,new p(s,r.type)):console.error(`Invalid constant type for ${n}`)):console.error(`Override ${n} does not exist in the shader.`)}}_dispatchWorkgroup(e,t,n){const s=[1,1,1];for(const u of e.node.attributes)if(u.name==="workgroup_size"){if(u.value.length>0){const h=n.getVariableValue(u.value[0]);s[0]=h instanceof d?h.value:parseInt(u.value[0])}if(u.value.length>1){const h=n.getVariableValue(u.value[1]);s[1]=h instanceof d?h.value:parseInt(u.value[1])}if(u.value.length>2){const h=n.getVariableValue(u.value[2]);s[2]=h instanceof d?h.value:parseInt(u.value[2])}}const r=this.getTypeInfo("vec3u"),a=this.getTypeInfo("u32");n.setVariable("@workgroup_size",new p(s,r));const i=s[0],o=s[1],l=s[2];for(let u=0,h=0;u<l;++u)for(let x=0;x<o;++x)for(let b=0;b<i;++b,++h){const k=[b,x,u],O=[b+t[0]*s[0],x+t[1]*s[1],u+t[2]*s[2]];n.setVariable("@local_invocation_id",new p(k,r)),n.setVariable("@global_invocation_id",new p(O,r)),n.setVariable("@local_invocation_index",new d(h,a)),this._dispatchExec(e,n)}}_dispatchExec(e,t){for(const n of e.node.args)for(const s of n.attributes)if(s.name==="builtin"){const r=`@${s.value}`,a=t.getVariable(r);a!==void 0&&t.variables.set(n.name,a)}this._execStatements(e.node.body,t)}getVariableName(e,t){for(;e instanceof C;)e=e.right;return e instanceof j?e.name:(console.error("Unknown variable type",e,"Line",e.line),null)}_execStatements(e,t){for(const n of e){if(n instanceof Array){const r=t.clone(),a=this._execStatements(n,r);if(a)return a;continue}const s=this.execStatement(n,t);if(s)return s}return null}_call(e,t){const n=t.clone();n.currentFunctionName=e.name;const s=t.getFunction(e.name);if(s){for(let r=0;r<s.node.args.length;++r){const a=s.node.args[r],i=this.evalExpression(e.args[r],n);n.setVariable(a.name,i,a)}this._execStatements(s.node.body,n)}else e.isBuiltin?this._callBuiltinFunction(e,n):this.getTypeInfo(e.name)&&this._evalCreate(e,t)}_increment(e,t){const n=this.getVariableName(e.variable,t),s=t.getVariable(n);s?e.operator==="++"?s.value instanceof d?s.value.value++:console.error(`Variable ${n} is not a scalar. Line ${e.line}`):e.operator==="--"?s.value instanceof d?s.value.value--:console.error(`Variable ${n} is not a scalar. Line ${e.line}`):console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`):console.error(`Variable ${n} not found. Line ${e.line}`)}_getVariableData(e,t){if(e instanceof j){const n=this.getVariableName(e,t),s=t.getVariable(n);return s===null?(console.error(`Variable ${n} not found. Line ${e.line}`),null):s.value.getSubData(this,e.postfix,t)}if(e instanceof C){if(e.operator==="*"){const n=this._getVariableData(e.right,t);return n instanceof ue?n.reference.getSubData(this,e.postfix,t):(console.error(`Variable ${e.right} is not a pointer. Line ${e.line}`),null)}if(e.operator==="&"){const n=this._getVariableData(e.right,t);return new ue(n)}}return null}_assign(e,t){let n=null,s="<var>",r=null;if(e.variable instanceof C){const o=this._getVariableData(e.variable,t),l=this.evalExpression(e.value,t),u=e.operator;if(u==="="){if(o instanceof d||o instanceof p||o instanceof T){if(l instanceof d||l instanceof p||l instanceof T&&o.data.length===l.data.length)return void o.data.set(l.data);console.error(`Invalid assignment. Line ${e.line}`)}else if(o instanceof F&&l instanceof F&&o.buffer.byteLength-o.offset>=l.buffer.byteLength-l.offset)return void(o.buffer.byteLength%4==0?new Uint32Array(o.buffer,o.offset,o.typeInfo.size/4).set(new Uint32Array(l.buffer,l.offset,l.typeInfo.size/4)):new Uint8Array(o.buffer,o.offset,o.typeInfo.size).set(new Uint8Array(l.buffer,l.offset,l.typeInfo.size)));return console.error(`Invalid assignment. Line ${e.line}`),null}if(u==="+=")return o instanceof d||o instanceof p||o instanceof T?l instanceof d||l instanceof p||l instanceof T?void o.data.set(l.data.map((h,x)=>o.data[x]+h)):void console.error(`Invalid assignment . Line ${e.line}`):void console.error(`Invalid assignment. Line ${e.line}`);if(u==="-=")return(o instanceof d||o instanceof p||o instanceof T)&&(l instanceof d||l instanceof p||l instanceof T)?void o.data.set(l.data.map((h,x)=>o.data[x]-h)):void console.error(`Invalid assignment. Line ${e.line}`)}if(e.variable instanceof C){if(e.variable.operator==="*"){s=this.getVariableName(e.variable.right,t);const o=t.getVariable(s);if(!(o&&o.value instanceof ue))return void console.error(`Variable ${s} is not a pointer. Line ${e.line}`);n=o.value.reference;let l=e.variable.postfix;if(!l){let u=e.variable.right;for(;u instanceof C;){if(u.postfix){l=u.postfix;break}u=u.right}}l&&(n=n.getSubData(this,l,t))}}else{r=e.variable.postfix,s=this.getVariableName(e.variable,t);const o=t.getVariable(s);if(o===null)return void console.error(`Variable ${s} not found. Line ${e.line}`);n=o.value}if(n instanceof ue&&(n=n.reference),n===null)return void console.error(`Variable ${s} not found. Line ${e.line}`);const a=this.evalExpression(e.value,t),i=e.operator;if(i!=="="){const o=n.getSubData(this,r,t);if(o instanceof p&&a instanceof d){const l=o.data,u=a.value;if(i==="+=")for(let h=0;h<l.length;++h)l[h]+=u;else if(i==="-=")for(let h=0;h<l.length;++h)l[h]-=u;else if(i==="*=")for(let h=0;h<l.length;++h)l[h]*=u;else if(i==="/=")for(let h=0;h<l.length;++h)l[h]/=u;else if(i==="%=")for(let h=0;h<l.length;++h)l[h]%=u;else if(i==="&=")for(let h=0;h<l.length;++h)l[h]&=u;else if(i==="|=")for(let h=0;h<l.length;++h)l[h]|=u;else if(i==="^=")for(let h=0;h<l.length;++h)l[h]^=u;else if(i==="<<=")for(let h=0;h<l.length;++h)l[h]<<=u;else if(i===">>=")for(let h=0;h<l.length;++h)l[h]>>=u;else console.error(`Invalid operator ${i}. Line ${e.line}`)}else if(o instanceof p&&a instanceof p){const l=o.data,u=a.data;if(l.length!==u.length)return void console.error(`Vector length mismatch. Line ${e.line}`);if(i==="+=")for(let h=0;h<l.length;++h)l[h]+=u[h];else if(i==="-=")for(let h=0;h<l.length;++h)l[h]-=u[h];else if(i==="*=")for(let h=0;h<l.length;++h)l[h]*=u[h];else if(i==="/=")for(let h=0;h<l.length;++h)l[h]/=u[h];else if(i==="%=")for(let h=0;h<l.length;++h)l[h]%=u[h];else if(i==="&=")for(let h=0;h<l.length;++h)l[h]&=u[h];else if(i==="|=")for(let h=0;h<l.length;++h)l[h]|=u[h];else if(i==="^=")for(let h=0;h<l.length;++h)l[h]^=u[h];else if(i==="<<=")for(let h=0;h<l.length;++h)l[h]<<=u[h];else if(i===">>=")for(let h=0;h<l.length;++h)l[h]>>=u[h];else console.error(`Invalid operator ${i}. Line ${e.line}`)}else{if(!(o instanceof d&&a instanceof d))return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);i==="+="?o.value+=a.value:i==="-="?o.value-=a.value:i==="*="?o.value*=a.value:i==="/="?o.value/=a.value:i==="%="?o.value%=a.value:i==="&="?o.value&=a.value:i==="|="?o.value|=a.value:i==="^="?o.value^=a.value:i==="<<="?o.value<<=a.value:i===">>="?o.value>>=a.value:console.error(`Invalid operator ${i}. Line ${e.line}`)}return void(n instanceof F&&n.setDataValue(this,o,r,t))}if(n instanceof F)n.setDataValue(this,a,r,t);else if(r){if(!(n instanceof p||n instanceof T))return void console.error(`Variable ${s} is not a vector or matrix. Line ${e.line}`);if(r instanceof ce){const o=this.evalExpression(r.index,t).value;if(n instanceof p){if(!(a instanceof d))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[o]=a.value}else{if(!(n instanceof T))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);{const l=this.evalExpression(r.index,t).value;if(l<0)return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);if(!(a instanceof p))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);{const u=n.typeInfo.getTypeName();if(u==="mat2x2"||u==="mat2x2f"||u==="mat2x2h"){if(!(l<2&&a.data.length===2))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[2*l]=a.data[0],n.data[2*l+1]=a.data[1]}else if(u==="mat2x3"||u==="mat2x3f"||u==="mat2x3h"){if(!(l<2&&a.data.length===3))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[3*l]=a.data[0],n.data[3*l+1]=a.data[1],n.data[3*l+2]=a.data[2]}else if(u==="mat2x4"||u==="mat2x4f"||u==="mat2x4h"){if(!(l<2&&a.data.length===4))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[4*l]=a.data[0],n.data[4*l+1]=a.data[1],n.data[4*l+2]=a.data[2],n.data[4*l+3]=a.data[3]}else if(u==="mat3x2"||u==="mat3x2f"||u==="mat3x2h"){if(!(l<3&&a.data.length===2))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[2*l]=a.data[0],n.data[2*l+1]=a.data[1]}else if(u==="mat3x3"||u==="mat3x3f"||u==="mat3x3h"){if(!(l<3&&a.data.length===3))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[3*l]=a.data[0],n.data[3*l+1]=a.data[1],n.data[3*l+2]=a.data[2]}else if(u==="mat3x4"||u==="mat3x4f"||u==="mat3x4h"){if(!(l<3&&a.data.length===4))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[4*l]=a.data[0],n.data[4*l+1]=a.data[1],n.data[4*l+2]=a.data[2],n.data[4*l+3]=a.data[3]}else if(u==="mat4x2"||u==="mat4x2f"||u==="mat4x2h"){if(!(l<4&&a.data.length===2))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[2*l]=a.data[0],n.data[2*l+1]=a.data[1]}else if(u==="mat4x3"||u==="mat4x3f"||u==="mat4x3h"){if(!(l<4&&a.data.length===3))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[3*l]=a.data[0],n.data[3*l+1]=a.data[1],n.data[3*l+2]=a.data[2]}else{if(u!=="mat4x4"&&u!=="mat4x4f"&&u!=="mat4x4h")return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);if(!(l<4&&a.data.length===4))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[4*l]=a.data[0],n.data[4*l+1]=a.data[1],n.data[4*l+2]=a.data[2],n.data[4*l+3]=a.data[3]}}}}}else if(r instanceof oe){const o=r.value;if(!(n instanceof p))return void console.error(`Invalid assignment to ${o}. Variable ${s} is not a vector. Line ${e.line}`);if(a instanceof d){if(o.length>1)return void console.error(`Invalid assignment to ${o} for variable ${s}. Line ${e.line}`);if(o==="x")n.data[0]=a.value;else if(o==="y"){if(n.data.length<2)return void console.error(`Invalid assignment to ${o} for variable ${s}. Line ${e.line}`);n.data[1]=a.value}else if(o==="z"){if(n.data.length<3)return void console.error(`Invalid assignment to ${o} for variable ${s}. Line ${e.line}`);n.data[2]=a.value}else if(o==="w"){if(n.data.length<4)return void console.error(`Invalid assignment to ${o} for variable ${s}. Line ${e.line}`);n.data[3]=a.value}}else{if(!(a instanceof p))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);if(o.length!==a.data.length)return void console.error(`Invalid assignment to ${o} for variable ${s}. Line ${e.line}`);for(let l=0;l<o.length;++l){const u=o[l];if(u==="x"||u==="r")n.data[0]=a.data[l];else if(u==="y"||u==="g"){if(a.data.length<2)return void console.error(`Invalid assignment to ${u} for variable ${s}. Line ${e.line}`);n.data[1]=a.data[l]}else if(u==="z"||u==="b"){if(a.data.length<3)return void console.error(`Invalid assignment to ${u} for variable ${s}. Line ${e.line}`);n.data[2]=a.data[l]}else{if(u!=="w"&&u!=="a")return void console.error(`Invalid assignment to ${u} for variable ${s}. Line ${e.line}`);if(a.data.length<4)return void console.error(`Invalid assignment to ${u} for variable ${s}. Line ${e.line}`);n.data[3]=a.data[l]}}}}}else n instanceof d&&a instanceof d?n.value=a.value:n instanceof p&&a instanceof p||n instanceof T&&a instanceof T?n.data.set(a.data):console.error(`Invalid assignment to ${s}. Line ${e.line}`)}_function(e,t){const n=new Qe(e);t.functions.set(e.name,n)}_const(e,t){let n=null;e.value!==null&&(n=this.evalExpression(e.value,t)),t.createVariable(e.name,n,e)}_let(e,t){let n=null;if(e.value!==null){if(n=this.evalExpression(e.value,t),n===null)return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);e.value instanceof C||(n=n.clone())}else{const s=e.type.name;if(s==="f32"||s==="i32"||s==="u32"||s==="bool"||s==="f16"||s==="vec2"||s==="vec3"||s==="vec4"||s==="vec2f"||s==="vec3f"||s==="vec4f"||s==="vec2i"||s==="vec3i"||s==="vec4i"||s==="vec2u"||s==="vec3u"||s==="vec4u"||s==="vec2h"||s==="vec3h"||s==="vec4h"||s==="vec2b"||s==="vec3b"||s==="vec4b"||s==="mat2x2"||s==="mat2x3"||s==="mat2x4"||s==="mat3x2"||s==="mat3x3"||s==="mat3x4"||s==="mat4x2"||s==="mat4x3"||s==="mat4x4"||s==="mat2x2f"||s==="mat2x3f"||s==="mat2x4f"||s==="mat3x2f"||s==="mat3x3f"||s==="mat3x4f"||s==="mat4x2f"||s==="mat4x3f"||s==="mat4x4f"||s==="mat2x2h"||s==="mat2x3h"||s==="mat2x4h"||s==="mat3x2h"||s==="mat3x3h"||s==="mat3x4h"||s==="mat4x2h"||s==="mat4x3h"||s==="mat4x4h"||s==="array"){const r=new Z(e.type,[]);n=this._evalCreate(r,t)}}t.createVariable(e.name,n,e)}_var(e,t){let n=null;if(e.value!==null){if(n=this.evalExpression(e.value,t),n===null)return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);e.value instanceof C||(n=n.clone())}else{if(e.type===null)return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);const s=e.type.name;if(s==="f32"||s==="i32"||s==="u32"||s==="bool"||s==="f16"||s==="vec2"||s==="vec3"||s==="vec4"||s==="vec2f"||s==="vec3f"||s==="vec4f"||s==="vec2i"||s==="vec3i"||s==="vec4i"||s==="vec2u"||s==="vec3u"||s==="vec4u"||s==="vec2h"||s==="vec3h"||s==="vec4h"||s==="vec2b"||s==="vec3b"||s==="vec4b"||s==="mat2x2"||s==="mat2x3"||s==="mat2x4"||s==="mat3x2"||s==="mat3x3"||s==="mat3x4"||s==="mat4x2"||s==="mat4x3"||s==="mat4x4"||s==="mat2x2f"||s==="mat2x3f"||s==="mat2x4f"||s==="mat3x2f"||s==="mat3x3f"||s==="mat3x4f"||s==="mat4x2f"||s==="mat4x3f"||s==="mat4x4f"||s==="mat2x2h"||s==="mat2x3h"||s==="mat2x4h"||s==="mat3x2h"||s==="mat3x3h"||s==="mat3x4h"||s==="mat4x2h"||s==="mat4x3h"||s==="mat4x4h"||e.type instanceof de||e.type instanceof Q||e.type instanceof g){const r=new Z(e.type,[]);n=this._evalCreate(r,t)}}t.createVariable(e.name,n,e)}_switch(e,t){t=t.clone();const n=this.evalExpression(e.condition,t);if(!(n instanceof d))return console.error(`Invalid if condition. Line ${e.line}`),null;let s=null;for(const r of e.cases)if(r instanceof Ut)for(const a of r.selectors){if(a instanceof ke){s=r;continue}const i=this.evalExpression(a,t);if(!(i instanceof d))return console.error(`Invalid case selector. Line ${e.line}`),null;if(i.value===n.value)return this._execStatements(r.body,t)}else r instanceof Vt&&(s=r);return s?this._execStatements(s.body,t):null}_if(e,t){t=t.clone();const n=this.evalExpression(e.condition,t);if(!(n instanceof d))return console.error(`Invalid if condition. Line ${e.line}`),null;if(n.value)return this._execStatements(e.body,t);for(const s of e.elseif){const r=this.evalExpression(s.condition,t);if(!(r instanceof d))return console.error(`Invalid if condition. Line ${e.line}`),null;if(r.value)return this._execStatements(s.body,t)}return e.else?this._execStatements(e.else,t):null}_getScalarValue(e){return e instanceof d?e.value:(console.error("Expected scalar value.",e),0)}_for(e,t){for(t=t.clone(),this.execStatement(e.init,t);this._getScalarValue(this.evalExpression(e.condition,t));){const n=this._execStatements(e.body,t);if(n===V._breakObj)break;if(n!==null&&n!==V._continueObj)return n;this.execStatement(e.increment,t)}return null}_loop(e,t){for(t=t.clone();;){const n=this._execStatements(e.body,t);if(n===V._breakObj)break;if(n===V._continueObj){if(e.continuing&&this._execStatements(e.continuing.body,t)===V._breakObj)break}else if(n!==null)return n}return null}_while(e,t){for(t=t.clone();this._getScalarValue(this.evalExpression(e.condition,t));){const n=this._execStatements(e.body,t);if(n===V._breakObj)break;if(n!==V._continueObj&&n!==null)return n}return null}_evalBitcast(e,t){const n=this.evalExpression(e.value,t),s=e.type;if(n instanceof d){const r=mt(n.value,n.typeInfo.name,s.name);return new d(r,this.getTypeInfo(s))}if(n instanceof p){const r=n.typeInfo.getTypeName();let a="";if(r.endsWith("f"))a="f32";else if(r.endsWith("i"))a="i32";else if(r.endsWith("u"))a="u32";else if(r.endsWith("b"))a="bool";else{if(!r.endsWith("h"))return console.error(`Unknown vector type ${r}. Line ${e.line}`),null;a="f16"}const i=s.getTypeName();let o="";if(i.endsWith("f"))o="f32";else if(i.endsWith("i"))o="i32";else if(i.endsWith("u"))o="u32";else if(i.endsWith("b"))o="bool";else{if(!i.endsWith("h"))return console.error(`Unknown vector type ${o}. Line ${e.line}`),null;o="f16"}const l=(function(u,h,x){if(h===x)return u;const b=new Array(u.length);for(let k=0;k<u.length;k++)b[k]=mt(u[k],h,x);return b})(Array.from(n.data),a,o);return new p(l,this.getTypeInfo(s))}return console.error(`TODO: bitcast for ${n.typeInfo.name}. Line ${e.line}`),null}_evalConst(e,t){return t.getVariableValue(e.name).clone().getSubData(this,e.postfix,t)}_evalCreate(e,t){var n;if(e instanceof Z){if(e.type===null)return Re.void;switch(e.type.getTypeName()){case"bool":case"i32":case"u32":case"f32":case"f16":return this._callConstructorValue(e,t);case"vec2":case"vec3":case"vec4":case"vec2f":case"vec3f":case"vec4f":case"vec2h":case"vec3h":case"vec4h":case"vec2i":case"vec3i":case"vec4i":case"vec2u":case"vec3u":case"vec4u":case"vec2b":case"vec3b":case"vec4b":return this._callConstructorVec(e,t);case"mat2x2":case"mat2x2f":case"mat2x2h":case"mat2x3":case"mat2x3f":case"mat2x3h":case"mat2x4":case"mat2x4f":case"mat2x4h":case"mat3x2":case"mat3x2f":case"mat3x2h":case"mat3x3":case"mat3x3f":case"mat3x3h":case"mat3x4":case"mat3x4f":case"mat3x4h":case"mat4x2":case"mat4x2f":case"mat4x2h":case"mat4x3":case"mat4x3f":case"mat4x3h":case"mat4x4":case"mat4x4f":case"mat4x4h":return this._callConstructorMatrix(e,t)}}const s=e instanceof Z?e.type.name:e.name,r=e instanceof Z?this.getTypeInfo(e.type):this.getTypeInfo(e.name);if(r===null)return console.error(`Unknown type ${s}. Line ${e.line}`),null;if(r.size===0)return null;const a=new F(new ArrayBuffer(r.size),r,0);if(r instanceof se){if(e.args)for(let i=0;i<e.args.length;++i){const o=r.members[i],l=e.args[i],u=this.evalExpression(l,t);a.setData(this,u,o.type,o.offset,t)}}else if(r instanceof re){let i=0;if(e.args)for(let o=0;o<e.args.length;++o){const l=e.args[o],u=this.evalExpression(l,t);r.format===null&&(((n=u.typeInfo)===null||n===void 0?void 0:n.name)==="x32"?r.format=this.getTypeInfo("i32"):r.format=u.typeInfo),a.setData(this,u,r.format,i,t),i+=r.stride}}else console.error(`Unknown type "${s}". Line ${e.line}`);return e instanceof Z?a.getSubData(this,e.postfix,t):a}_evalLiteral(e,t){const n=this.getTypeInfo(e.type),s=n.name;return s==="x32"||s==="u32"||s==="f32"||s==="f16"||s==="i32"||s==="bool"?new d(e.scalarValue,n):s==="vec2"||s==="vec3"||s==="vec4"||s==="vec2f"||s==="vec3f"||s==="vec4f"||s==="vec2h"||s==="vec3h"||s==="vec4h"||s==="vec2i"||s==="vec3i"||s==="vec4i"||s==="vec2u"||s==="vec3u"||s==="vec4u"?this._callConstructorVec(e,t):s==="mat2x2"||s==="mat2x3"||s==="mat2x4"||s==="mat3x2"||s==="mat3x3"||s==="mat3x4"||s==="mat4x2"||s==="mat4x3"||s==="mat4x4"||s==="mat2x2f"||s==="mat2x3f"||s==="mat2x4f"||s==="mat3x2f"||s==="mat3x3f"||s==="mat3x4f"||s==="mat4x2f"||s==="mat4x3f"||s==="mat4x4f"||s==="mat2x2h"||s==="mat2x3h"||s==="mat2x4h"||s==="mat3x2h"||s==="mat3x3h"||s==="mat3x4h"||s==="mat4x2h"||s==="mat4x3h"||s==="mat4x4h"?this._callConstructorMatrix(e,t):e.value}_evalVariable(e,t){const n=t.getVariableValue(e.name);return n===null?n:n.getSubData(this,e.postfix,t)}_maxFormatTypeInfo(e){let t=e[0];if(t.name==="f32")return t;for(let n=1;n<e.length;++n){const s=V._priority.get(t.name);V._priority.get(e[n].name)<s&&(t=e[n])}return t.name==="x32"?this.getTypeInfo("i32"):t}_evalUnaryOp(e,t){const n=this.evalExpression(e.right,t);if(e.operator==="&")return new ue(n);if(e.operator==="*")return n instanceof ue?n.reference.getSubData(this,e.postfix,t):(console.error(`Invalid dereference. Line ${e.line}`),null);const s=n instanceof d?n.value:n instanceof p?Array.from(n.data):null;switch(e.operator){case"+":{if(w(s)){const i=s.map((o,l)=>+o);return new p(i,n.typeInfo)}const r=s,a=this._maxFormatTypeInfo([n.typeInfo,n.typeInfo]);return new d(+r,a)}case"-":{if(w(s)){const i=s.map((o,l)=>-o);return new p(i,n.typeInfo)}const r=s,a=this._maxFormatTypeInfo([n.typeInfo,n.typeInfo]);return new d(-r,a)}case"!":{if(w(s)){const i=s.map((o,l)=>o?0:1);return new p(i,n.typeInfo)}const r=s,a=this._maxFormatTypeInfo([n.typeInfo,n.typeInfo]);return new d(r?0:1,a)}case"~":{if(w(s)){const i=s.map((o,l)=>~o);return new p(i,n.typeInfo)}const r=s,a=this._maxFormatTypeInfo([n.typeInfo,n.typeInfo]);return new d(~r,a)}}return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`),null}_evalBinaryOp(e,t){const n=this.evalExpression(e.left,t),s=this.evalExpression(e.right,t),r=n instanceof d?n.value:n instanceof p||n instanceof T?Array.from(n.data):null,a=s instanceof d?s.value:s instanceof p||s instanceof T?Array.from(s.data):null;switch(e.operator){case"+":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b+h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x+u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u+x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i+o,l)}case"-":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b-h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x-u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u-x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i-o,l)}case"*":{if(w(r)&&w(a)){const u=r,h=a;if(n instanceof T&&s instanceof T){const x=(function(S,P,M,A){if(R[P.name]===void 0||R[A.name]===void 0)return null;const I=R[P.name][0],W=R[P.name][1],q=R[A.name][0];if(I!==R[A.name][1])return null;const rt=new Array(q*W);for(let _e=0;_e<W;_e++)for(let ge=0;ge<q;ge++){let it=0;for(let ye=0;ye<I;ye++)it+=S[ye*W+_e]*M[ge*I+ye];rt[_e*q+ge]=it}return rt})(u,n.typeInfo,h,s.typeInfo);if(x===null)return console.error(`Matrix multiplication failed. Line ${e.line}.`),null;const b=R[s.typeInfo.name][0],k=R[n.typeInfo.name][1],O=this.getTypeInfo(`mat${b}x${k}f`);return new T(x,O)}if(n instanceof T&&s instanceof p){const x=(function(b,k,O,S){if(R[k.name]===void 0||Fe[S.name]===void 0)return null;const P=R[k.name][0],M=R[k.name][1];if(P!==O.length)return null;const A=new Array(M);for(let I=0;I<M;I++){let W=0;for(let q=0;q<P;q++)W+=b[q*M+I]*O[q];A[I]=W}return A})(u,n.typeInfo,h,s.typeInfo);return x===null?(console.error(`Matrix vector multiplication failed. Line ${e.line}.`),null):new p(x,s.typeInfo)}if(n instanceof p&&s instanceof T){const x=(function(b,k,O,S){if(Fe[k.name]===void 0||R[S.name]===void 0)return null;const P=R[S.name][0],M=R[S.name][1];if(M!==b.length)return null;const A=[];for(let I=0;I<P;I++){let W=0;for(let q=0;q<M;q++)W+=b[q]*O[q*P+I];A[I]=W}return A})(u,n.typeInfo,h,s.typeInfo);return x===null?(console.error(`Matrix vector multiplication failed. Line ${e.line}.`),null):new p(x,n.typeInfo)}{if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b*h[k]);return new p(x,n.typeInfo)}}if(w(r)){const u=a,h=r.map((x,b)=>x*u);return n instanceof T?new T(h,n.typeInfo):new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u*x);return s instanceof T?new T(h,s.typeInfo):new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i*o,l)}case"%":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b%h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x%u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u%x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i%o,l)}case"/":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b/h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x/u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u/x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i/o,l)}case"&":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b&h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x&u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u&x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i&o,l)}case"|":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b|h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x|u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u|x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i|o,l)}case"^":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b^h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x^u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u^x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i^o,l)}case"<<":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b<<h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x<<u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u<<x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i<<o,l)}case">>":{if(w(r)&&w(a)){const u=r,h=a;if(u.length!==h.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const x=u.map((b,k)=>b>>h[k]);return new p(x,n.typeInfo)}if(w(r)){const u=a,h=r.map((x,b)=>x>>u);return new p(h,n.typeInfo)}if(w(a)){const u=r,h=a.map((x,b)=>u>>x);return new p(h,s.typeInfo)}const i=r,o=a,l=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new d(i>>o,l)}case">":if(w(r)&&w(a)){const i=r,o=a;if(i.length!==o.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const l=i.map((u,h)=>u>o[h]?1:0);return new p(l,n.typeInfo)}if(w(r)){const i=a,o=r.map((l,u)=>l>i?1:0);return new p(o,n.typeInfo)}if(w(a)){const i=r,o=a.map((l,u)=>i>l?1:0);return new p(o,s.typeInfo)}return new d(r>a?1:0,this.getTypeInfo("bool"));case"<":if(w(r)&&w(a)){const i=r,o=a;if(i.length!==o.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const l=i.map((u,h)=>u<o[h]?1:0);return new p(l,n.typeInfo)}if(w(r)){const i=a,o=r.map((l,u)=>l<i?1:0);return new p(o,n.typeInfo)}if(w(a)){const i=r,o=a.map((l,u)=>i<l?1:0);return new p(o,s.typeInfo)}return new d(r<a?1:0,this.getTypeInfo("bool"));case"==":if(w(r)&&w(a)){const i=r,o=a;if(i.length!==o.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const l=i.map((u,h)=>u===o[h]?1:0);return new p(l,n.typeInfo)}if(w(r)){const i=a,o=r.map((l,u)=>l==i?1:0);return new p(o,n.typeInfo)}if(w(a)){const i=r,o=a.map((l,u)=>i==l?1:0);return new p(o,s.typeInfo)}return new d(r===a?1:0,this.getTypeInfo("bool"));case"!=":if(w(r)&&w(a)){const i=r,o=a;if(i.length!==o.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const l=i.map((u,h)=>u!==o[h]?1:0);return new p(l,n.typeInfo)}if(w(r)){const i=a,o=r.map((l,u)=>l!==i?1:0);return new p(o,n.typeInfo)}if(w(a)){const i=r,o=a.map((l,u)=>i!==l?1:0);return new p(o,s.typeInfo)}return new d(r!==a?1:0,this.getTypeInfo("bool"));case">=":if(w(r)&&w(a)){const i=r,o=a;if(i.length!==o.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const l=i.map((u,h)=>u>=o[h]?1:0);return new p(l,n.typeInfo)}if(w(r)){const i=a,o=r.map((l,u)=>l>=i?1:0);return new p(o,n.typeInfo)}if(w(a)){const i=r,o=a.map((l,u)=>i>=l?1:0);return new p(o,s.typeInfo)}return new d(r>=a?1:0,this.getTypeInfo("bool"));case"<=":if(w(r)&&w(a)){const i=r,o=a;if(i.length!==o.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const l=i.map((u,h)=>u<=o[h]?1:0);return new p(l,n.typeInfo)}if(w(r)){const i=a,o=r.map((l,u)=>l<=i?1:0);return new p(o,n.typeInfo)}if(w(a)){const i=r,o=a.map((l,u)=>i<=l?1:0);return new p(o,s.typeInfo)}return new d(r<=a?1:0,this.getTypeInfo("bool"));case"&&":if(w(r)&&w(a)){const i=r,o=a;if(i.length!==o.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const l=i.map((u,h)=>u&&o[h]?1:0);return new p(l,n.typeInfo)}if(w(r)){const i=a,o=r.map((l,u)=>l&&i?1:0);return new p(o,n.typeInfo)}if(w(a)){const i=r,o=a.map((l,u)=>i&&l?1:0);return new p(o,s.typeInfo)}return new d(r&&a?1:0,this.getTypeInfo("bool"));case"||":if(w(r)&&w(a)){const i=r,o=a;if(i.length!==o.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const l=i.map((u,h)=>u||o[h]?1:0);return new p(l,n.typeInfo)}if(w(r)){const i=a,o=r.map((l,u)=>l||i?1:0);return new p(o,n.typeInfo)}if(w(a)){const i=r,o=a.map((l,u)=>i||l?1:0);return new p(o,s.typeInfo)}return new d(r||a?1:0,this.getTypeInfo("bool"))}return console.error(`Unknown operator ${e.operator}. Line ${e.line}`),null}_evalCall(e,t){if(e.cachedReturnValue!==null)return e.cachedReturnValue;const n=t.clone();n.currentFunctionName=e.name;const s=t.getFunction(e.name);if(!s)return e.isBuiltin?this._callBuiltinFunction(e,n):this.getTypeInfo(e.name)?this._evalCreate(e,t):(console.error(`Unknown function "${e.name}". Line ${e.line}`),null);for(let r=0;r<s.node.args.length;++r){const a=s.node.args[r],i=this.evalExpression(e.args[r],n);n.createVariable(a.name,i,a)}return this._execStatements(s.node.body,n)}_callBuiltinFunction(e,t){switch(e.name){case"all":return this.builtins.All(e,t);case"any":return this.builtins.Any(e,t);case"select":return this.builtins.Select(e,t);case"arrayLength":return this.builtins.ArrayLength(e,t);case"abs":return this.builtins.Abs(e,t);case"acos":return this.builtins.Acos(e,t);case"acosh":return this.builtins.Acosh(e,t);case"asin":return this.builtins.Asin(e,t);case"asinh":return this.builtins.Asinh(e,t);case"atan":return this.builtins.Atan(e,t);case"atanh":return this.builtins.Atanh(e,t);case"atan2":return this.builtins.Atan2(e,t);case"ceil":return this.builtins.Ceil(e,t);case"clamp":return this.builtins.Clamp(e,t);case"cos":return this.builtins.Cos(e,t);case"cosh":return this.builtins.Cosh(e,t);case"countLeadingZeros":return this.builtins.CountLeadingZeros(e,t);case"countOneBits":return this.builtins.CountOneBits(e,t);case"countTrailingZeros":return this.builtins.CountTrailingZeros(e,t);case"cross":return this.builtins.Cross(e,t);case"degrees":return this.builtins.Degrees(e,t);case"determinant":return this.builtins.Determinant(e,t);case"distance":return this.builtins.Distance(e,t);case"dot":return this.builtins.Dot(e,t);case"dot4U8Packed":return this.builtins.Dot4U8Packed(e,t);case"dot4I8Packed":return this.builtins.Dot4I8Packed(e,t);case"exp":return this.builtins.Exp(e,t);case"exp2":return this.builtins.Exp2(e,t);case"extractBits":return this.builtins.ExtractBits(e,t);case"faceForward":return this.builtins.FaceForward(e,t);case"firstLeadingBit":return this.builtins.FirstLeadingBit(e,t);case"firstTrailingBit":return this.builtins.FirstTrailingBit(e,t);case"floor":return this.builtins.Floor(e,t);case"fma":return this.builtins.Fma(e,t);case"fract":return this.builtins.Fract(e,t);case"frexp":return this.builtins.Frexp(e,t);case"insertBits":return this.builtins.InsertBits(e,t);case"inverseSqrt":return this.builtins.InverseSqrt(e,t);case"ldexp":return this.builtins.Ldexp(e,t);case"length":return this.builtins.Length(e,t);case"log":return this.builtins.Log(e,t);case"log2":return this.builtins.Log2(e,t);case"max":return this.builtins.Max(e,t);case"min":return this.builtins.Min(e,t);case"mix":return this.builtins.Mix(e,t);case"modf":return this.builtins.Modf(e,t);case"normalize":return this.builtins.Normalize(e,t);case"pow":return this.builtins.Pow(e,t);case"quantizeToF16":return this.builtins.QuantizeToF16(e,t);case"radians":return this.builtins.Radians(e,t);case"reflect":return this.builtins.Reflect(e,t);case"refract":return this.builtins.Refract(e,t);case"reverseBits":return this.builtins.ReverseBits(e,t);case"round":return this.builtins.Round(e,t);case"saturate":return this.builtins.Saturate(e,t);case"sign":return this.builtins.Sign(e,t);case"sin":return this.builtins.Sin(e,t);case"sinh":return this.builtins.Sinh(e,t);case"smoothstep":return this.builtins.SmoothStep(e,t);case"sqrt":return this.builtins.Sqrt(e,t);case"step":return this.builtins.Step(e,t);case"tan":return this.builtins.Tan(e,t);case"tanh":return this.builtins.Tanh(e,t);case"transpose":return this.builtins.Transpose(e,t);case"trunc":return this.builtins.Trunc(e,t);case"dpdx":return this.builtins.Dpdx(e,t);case"dpdxCoarse":return this.builtins.DpdxCoarse(e,t);case"dpdxFine":return this.builtins.DpdxFine(e,t);case"dpdy":return this.builtins.Dpdy(e,t);case"dpdyCoarse":return this.builtins.DpdyCoarse(e,t);case"dpdyFine":return this.builtins.DpdyFine(e,t);case"fwidth":return this.builtins.Fwidth(e,t);case"fwidthCoarse":return this.builtins.FwidthCoarse(e,t);case"fwidthFine":return this.builtins.FwidthFine(e,t);case"textureDimensions":return this.builtins.TextureDimensions(e,t);case"textureGather":return this.builtins.TextureGather(e,t);case"textureGatherCompare":return this.builtins.TextureGatherCompare(e,t);case"textureLoad":return this.builtins.TextureLoad(e,t);case"textureNumLayers":return this.builtins.TextureNumLayers(e,t);case"textureNumLevels":return this.builtins.TextureNumLevels(e,t);case"textureNumSamples":return this.builtins.TextureNumSamples(e,t);case"textureSample":return this.builtins.TextureSample(e,t);case"textureSampleBias":return this.builtins.TextureSampleBias(e,t);case"textureSampleCompare":return this.builtins.TextureSampleCompare(e,t);case"textureSampleCompareLevel":return this.builtins.TextureSampleCompareLevel(e,t);case"textureSampleGrad":return this.builtins.TextureSampleGrad(e,t);case"textureSampleLevel":return this.builtins.TextureSampleLevel(e,t);case"textureSampleBaseClampToEdge":return this.builtins.TextureSampleBaseClampToEdge(e,t);case"textureStore":return this.builtins.TextureStore(e,t);case"atomicLoad":return this.builtins.AtomicLoad(e,t);case"atomicStore":return this.builtins.AtomicStore(e,t);case"atomicAdd":return this.builtins.AtomicAdd(e,t);case"atomicSub":return this.builtins.AtomicSub(e,t);case"atomicMax":return this.builtins.AtomicMax(e,t);case"atomicMin":return this.builtins.AtomicMin(e,t);case"atomicAnd":return this.builtins.AtomicAnd(e,t);case"atomicOr":return this.builtins.AtomicOr(e,t);case"atomicXor":return this.builtins.AtomicXor(e,t);case"atomicExchange":return this.builtins.AtomicExchange(e,t);case"atomicCompareExchangeWeak":return this.builtins.AtomicCompareExchangeWeak(e,t);case"pack4x8snorm":return this.builtins.Pack4x8snorm(e,t);case"pack4x8unorm":return this.builtins.Pack4x8unorm(e,t);case"pack4xI8":return this.builtins.Pack4xI8(e,t);case"pack4xU8":return this.builtins.Pack4xU8(e,t);case"pack4x8Clamp":return this.builtins.Pack4x8Clamp(e,t);case"pack4xU8Clamp":return this.builtins.Pack4xU8Clamp(e,t);case"pack2x16snorm":return this.builtins.Pack2x16snorm(e,t);case"pack2x16unorm":return this.builtins.Pack2x16unorm(e,t);case"pack2x16float":return this.builtins.Pack2x16float(e,t);case"unpack4x8snorm":return this.builtins.Unpack4x8snorm(e,t);case"unpack4x8unorm":return this.builtins.Unpack4x8unorm(e,t);case"unpack4xI8":return this.builtins.Unpack4xI8(e,t);case"unpack4xU8":return this.builtins.Unpack4xU8(e,t);case"unpack2x16snorm":return this.builtins.Unpack2x16snorm(e,t);case"unpack2x16unorm":return this.builtins.Unpack2x16unorm(e,t);case"unpack2x16float":return this.builtins.Unpack2x16float(e,t);case"storageBarrier":return this.builtins.StorageBarrier(e,t);case"textureBarrier":return this.builtins.TextureBarrier(e,t);case"workgroupBarrier":return this.builtins.WorkgroupBarrier(e,t);case"workgroupUniformLoad":return this.builtins.WorkgroupUniformLoad(e,t);case"subgroupAdd":return this.builtins.SubgroupAdd(e,t);case"subgroupExclusiveAdd":return this.builtins.SubgroupExclusiveAdd(e,t);case"subgroupInclusiveAdd":return this.builtins.SubgroupInclusiveAdd(e,t);case"subgroupAll":return this.builtins.SubgroupAll(e,t);case"subgroupAnd":return this.builtins.SubgroupAnd(e,t);case"subgroupAny":return this.builtins.SubgroupAny(e,t);case"subgroupBallot":return this.builtins.SubgroupBallot(e,t);case"subgroupBroadcast":return this.builtins.SubgroupBroadcast(e,t);case"subgroupBroadcastFirst":return this.builtins.SubgroupBroadcastFirst(e,t);case"subgroupElect":return this.builtins.SubgroupElect(e,t);case"subgroupMax":return this.builtins.SubgroupMax(e,t);case"subgroupMin":return this.builtins.SubgroupMin(e,t);case"subgroupMul":return this.builtins.SubgroupMul(e,t);case"subgroupExclusiveMul":return this.builtins.SubgroupExclusiveMul(e,t);case"subgroupInclusiveMul":return this.builtins.SubgroupInclusiveMul(e,t);case"subgroupOr":return this.builtins.SubgroupOr(e,t);case"subgroupShuffle":return this.builtins.SubgroupShuffle(e,t);case"subgroupShuffleDown":return this.builtins.SubgroupShuffleDown(e,t);case"subgroupShuffleUp":return this.builtins.SubgroupShuffleUp(e,t);case"subgroupShuffleXor":return this.builtins.SubgroupShuffleXor(e,t);case"subgroupXor":return this.builtins.SubgroupXor(e,t);case"quadBroadcast":return this.builtins.QuadBroadcast(e,t);case"quadSwapDiagonal":return this.builtins.QuadSwapDiagonal(e,t);case"quadSwapX":return this.builtins.QuadSwapX(e,t);case"quadSwapY":return this.builtins.QuadSwapY(e,t)}const n=t.getFunction(e.name);if(n){const s=t.clone();for(let r=0;r<n.node.args.length;++r){const a=n.node.args[r],i=this.evalExpression(e.args[r],s);s.setVariable(a.name,i,a)}return this._execStatements(n.node.body,s)}return null}_callConstructorValue(e,t){if(!e.args||e.args.length===0)return new d(0,this.getTypeInfo(e.type));const n=this.evalExpression(e.args[0],t);return n.typeInfo=this.getTypeInfo(e.type),n.getSubData(this,e.postfix,t).clone()}_callConstructorVec(e,t){const n=this.getTypeInfo(e.type),s=e.type.getTypeName(),r=Fe[s];if(r===void 0)return console.error(`Invalid vec constructor ${s}. Line ${e.line}`),null;const a=[];if(e instanceof $)if(e.isVector){const i=e.vectorValue;for(const o of i)a.push(o)}else a.push(e.scalarValue);else if(e.args)for(const i of e.args){const o=this.evalExpression(i,t);if(o instanceof p){const l=o.data;for(let u=0;u<l.length;++u){let h=l[u];a.push(h)}}else if(o instanceof d){let l=o.value;a.push(l)}}if(e.type instanceof g&&e.type.format===null&&(e.type.format=g.f32),a.length===0){const i=new Array(r).fill(0);return new p(i,n).getSubData(this,e.postfix,t)}if(a.length===1)for(;a.length<r;)a.push(a[0]);return a.length<r?(console.error(`Invalid vec constructor. Line ${e.line}`),null):new p(a.length>r?a.slice(0,r):a,n).getSubData(this,e.postfix,t)}_callConstructorMatrix(e,t){const n=this.getTypeInfo(e.type),s=e.type.getTypeName(),r=R[s];if(r===void 0)return console.error(`Invalid matrix constructor ${s}. Line ${e.line}`),null;const a=[];if(e instanceof $)if(e.isVector){const i=e.vectorValue;for(const o of i)a.push(o)}else a.push(e.scalarValue);else if(e.args)for(const i of e.args){const o=this.evalExpression(i,t);o instanceof p?a.push(...o.data):o instanceof d?a.push(o.value):o instanceof T&&a.push(...o.data)}if(n instanceof ae&&n.format===null&&(n.format=this.getTypeInfo("f32")),a.length===0){const i=new Array(r[2]).fill(0);return new T(i,n).getSubData(this,e.postfix,t)}return a.length!==r[2]?(console.error(`Invalid matrix constructor. Line ${e.line}`),null):new T(a,n).getSubData(this,e.postfix,t)}}V._breakObj=new z(new H("BREAK",null),null),V._continueObj=new z(new H("CONTINUE",null),null),V._priority=new Map([["f32",0],["f16",1],["u32",2],["i32",3],["x32",3]]);class Gn{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class Kn{constructor(){this._tokens=[],this._current=0,this._currentLine=1,this._deferArrayCountEval=[],this._currentLoop=[],this._context=new Gn,this._exec=new V,this._forwardTypeCount=0}parse(e){this._initialize(e),this._deferArrayCountEval.length=0;const t=[];for(;!this._isAtEnd();){const n=this._global_decl_or_directive();if(!n)break;t.push(n)}if(this._deferArrayCountEval.length>0){for(const n of this._deferArrayCountEval){const s=n.arrayType,r=n.countNode;if(r instanceof j){const a=r.name,i=this._context.constants.get(a);if(i)try{const o=i.constEvaluate(this._exec);s.count=o}catch{}}}this._deferArrayCountEval.length=0}if(this._forwardTypeCount>0)for(const n of t)n.search(s=>{s instanceof pt||s instanceof we?s.type=this._forwardType(s.type):s instanceof de?s.format=this._forwardType(s.format):s instanceof ee||s instanceof pe||s instanceof be?s.type=this._forwardType(s.type):s instanceof me?s.returnType=this._forwardType(s.returnType):s instanceof ht&&(s.type=this._forwardType(s.type))});return t}_forwardType(e){if(e instanceof ft){const t=this._getType(e.name);if(t)return t}else e instanceof we?e.type=this._forwardType(e.type):e instanceof de&&(e.format=this._forwardType(e.format));return e}_initialize(e){if(e)if(typeof e=="string"){const t=new Dn(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_updateNode(e,t){return e.line=t??this._currentLine,e}_error(e,t){return{token:e,message:t,toString:()=>`${t}`}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==f.eof}_match(e){if(e instanceof _)return!!this._check(e)&&(this._advance(),!0);for(let t=0,n=e.length;t<n;++t){const s=e[t];if(this._check(s))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),`${t}. Line:${this._currentLine}`)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){const n=t.type;let s=!1;for(const r of e){if(n===r)return!0;r===f.tokens.name&&(s=!0)}if(s){const r=f.tokens.name.rule.exec(t.lexeme);if(r&&r.index==0&&r[0]==t.lexeme)return!0}return!1}if(t.type===e)return!0;if(e===f.tokens.name){const n=f.tokens.name.rule.exec(t.lexeme);return n&&n.index==0&&n[0]==t.lexeme}return!1}_advance(){var e,t;return this._currentLine=(t=(e=this._peek())===null||e===void 0?void 0:e.line)!==null&&t!==void 0?t:-1,this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(f.tokens.semicolon)&&!this._isAtEnd(););if(this._match(f.keywords.alias)){const t=this._type_alias();return this._consume(f.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([t]),t}if(this._match(f.keywords.diagnostic)){const t=this._diagnostic();return this._consume(f.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([t]),t}if(this._match(f.keywords.requires)){const t=this._requires_directive();return this._consume(f.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([t]),t}if(this._match(f.keywords.enable)){const t=this._enable_directive();return this._consume(f.tokens.semicolon,"Expected ';'"),this._exec.reflection.updateAST([t]),t}const e=this._attribute();if(this._check(f.keywords.var)){const t=this._global_variable_decl();return t!=null&&(t.attributes=e),this._consume(f.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([t]),t}if(this._check(f.keywords.override)){const t=this._override_variable_decl();return t!=null&&(t.attributes=e),this._consume(f.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([t]),t}if(this._check(f.keywords.let)){const t=this._global_let_decl();return t!=null&&(t.attributes=e),this._consume(f.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([t]),t}if(this._check(f.keywords.const)){const t=this._global_const_decl();return t!=null&&(t.attributes=e),this._consume(f.tokens.semicolon,"Expected ';'."),this._exec.reflection.updateAST([t]),t}if(this._check(f.keywords.struct)){const t=this._struct_decl();return t!=null&&(t.attributes=e),this._exec.reflection.updateAST([t]),t}if(this._check(f.keywords.fn)){const t=this._function_decl();return t!=null&&(t.attributes=e),this._exec.reflection.updateAST([t]),t}return null}_function_decl(){if(!this._match(f.keywords.fn))return null;const e=this._currentLine,t=this._consume(f.tokens.ident,"Expected function name.").toString();this._consume(f.tokens.paren_left,"Expected '(' for function arguments.");const n=[];if(!this._check(f.tokens.paren_right))do{if(this._check(f.tokens.paren_right))break;const i=this._attribute(),o=this._consume(f.tokens.name,"Expected argument name.").toString();this._consume(f.tokens.colon,"Expected ':' for argument type.");const l=this._attribute(),u=this._type_decl();u!=null&&(u.attributes=l,n.push(this._updateNode(new ht(o,u,i))))}while(this._match(f.tokens.comma));this._consume(f.tokens.paren_right,"Expected ')' after function arguments.");let s=null;if(this._match(f.tokens.arrow)){const i=this._attribute();s=this._type_decl(),s!=null&&(s.attributes=i)}const r=this._compound_statement(),a=this._currentLine;return this._updateNode(new me(t,n,s,r,e,a),e)}_compound_statement(){const e=[];for(this._consume(f.tokens.brace_left,"Expected '{' for block.");!this._check(f.tokens.brace_right);){const t=this._statement();t!==null&&e.push(t)}return this._consume(f.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(f.tokens.semicolon)&&!this._isAtEnd(););if(this._check(f.tokens.attr)&&this._attribute(),this._check(f.keywords.if))return this._if_statement();if(this._check(f.keywords.switch))return this._switch_statement();if(this._check(f.keywords.loop))return this._loop_statement();if(this._check(f.keywords.for))return this._for_statement();if(this._check(f.keywords.while))return this._while_statement();if(this._check(f.keywords.continuing))return this._continuing_statement();if(this._check(f.keywords.static_assert))return this._static_assert_statement();if(this._check(f.tokens.brace_left))return this._compound_statement();let e=null;if(this._check(f.keywords.return))e=this._return_statement();else if(this._check([f.keywords.var,f.keywords.let,f.keywords.const]))e=this._variable_statement();else if(this._match(f.keywords.discard))e=this._updateNode(new Fn);else if(this._match(f.keywords.break)){const t=this._updateNode(new Nt);if(this._currentLoop.length>0){const n=this._currentLoop[this._currentLoop.length-1];t.loopId=n.id}e=t,this._check(f.keywords.if)&&(this._advance(),t.condition=this._optional_paren_expression())}else if(this._match(f.keywords.continue)){const t=this._updateNode(new Bt);if(!(this._currentLoop.length>0))throw this._error(this._peek(),`Continue statement must be inside a loop. Line: ${t.line}`);{const n=this._currentLoop[this._currentLoop.length-1];t.loopId=n.id}e=t}else e=this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement();return e!=null&&this._consume(f.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(f.keywords.static_assert))return null;const e=this._currentLine,t=this._optional_paren_expression();return this._updateNode(new Pn(t),e)}_while_statement(){if(!this._match(f.keywords.while))return null;const e=this._updateNode(new kt(null,null));return this._currentLoop.push(e),e.condition=this._optional_paren_expression(),this._check(f.tokens.attr)&&this._attribute(),e.body=this._compound_statement(),this._currentLoop.pop(),e}_continuing_statement(){const e=this._currentLoop.length>0?this._currentLoop[this._currentLoop.length-1].id:-1;if(!this._match(f.keywords.continuing))return null;const t=this._currentLine,n=this._compound_statement();return this._updateNode(new We(n,e),t)}_for_statement(){if(!this._match(f.keywords.for))return null;this._consume(f.tokens.paren_left,"Expected '('.");const e=this._updateNode(new It(null,null,null,null));return this._currentLoop.push(e),e.init=this._check(f.tokens.semicolon)?null:this._for_init(),this._consume(f.tokens.semicolon,"Expected ';'."),e.condition=this._check(f.tokens.semicolon)?null:this._short_circuit_or_expression(),this._consume(f.tokens.semicolon,"Expected ';'."),e.increment=this._check(f.tokens.paren_right)?null:this._for_increment(),this._consume(f.tokens.paren_right,"Expected ')'."),this._check(f.tokens.attr)&&this._attribute(),e.body=this._compound_statement(),this._currentLoop.pop(),e}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(f.keywords.var)){const e=this._variable_decl();if(e===null)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(f.tokens.equal)&&(t=this._short_circuit_or_expression()),this._updateNode(new ee(e.name,e.type,e.storage,e.access,t),e.line)}if(this._match(f.keywords.let)){const e=this._currentLine,t=this._consume(f.tokens.name,"Expected name for let.").toString();let n=null;if(this._match(f.tokens.colon)){const r=this._attribute();n=this._type_decl(),n!=null&&(n.attributes=r)}this._consume(f.tokens.equal,"Expected '=' for let.");const s=this._short_circuit_or_expression();return this._updateNode(new pe(t,n,null,null,s),e)}if(this._match(f.keywords.const)){const e=this._currentLine,t=this._consume(f.tokens.name,"Expected name for const.").toString();let n=null;if(this._match(f.tokens.colon)){const r=this._attribute();n=this._type_decl(),n!=null&&(n.attributes=r)}this._consume(f.tokens.equal,"Expected '=' for const.");const s=this._short_circuit_or_expression();return n===null&&s instanceof $&&(n=s.type),this._updateNode(new be(t,n,null,null,s),e)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(t==null)return null;if(!this._check(f.increment_operators))return this._current=e,null;const n=this._consume(f.increment_operators,"Expected increment operator");return this._updateNode(new Tt(n.type===f.tokens.plus_plus?le.increment:le.decrement,t))}_assignment_statement(){let e=null;const t=this._currentLine;if(this._check(f.tokens.brace_right))return null;let n=this._match(f.tokens.underscore);if(n||(e=this._unary_expression()),!n&&e==null)return null;const s=this._consume(f.assignment_operators,"Expected assignment operator."),r=this._short_circuit_or_expression();return this._updateNode(new At(fe.parse(s.lexeme),e,r),t)}_func_call_statement(){if(!this._check(f.tokens.ident))return null;const e=this._currentLine,t=this._current,n=this._consume(f.tokens.ident,"Expected function name."),s=this._argument_expression_list();return s===null?(this._current=t,null):this._updateNode(new Ge(n.lexeme,s),e)}_loop_statement(){if(!this._match(f.keywords.loop))return null;this._check(f.tokens.attr)&&this._attribute(),this._consume(f.tokens.brace_left,"Expected '{' for loop.");const e=this._updateNode(new St([],null));this._currentLoop.push(e);let t=this._statement();for(;t!==null;){if(Array.isArray(t))for(let n of t)e.body.push(n);else e.body.push(t);if(t instanceof We){e.continuing=t;break}t=this._statement()}return this._currentLoop.pop(),this._consume(f.tokens.brace_right,"Expected '}' for loop."),e}_switch_statement(){if(!this._match(f.keywords.switch))return null;const e=this._updateNode(new Lt(null,[]));if(this._currentLoop.push(e),e.condition=this._optional_paren_expression(),this._check(f.tokens.attr)&&this._attribute(),this._consume(f.tokens.brace_left,"Expected '{' for switch."),e.cases=this._switch_body(),e.cases==null||e.cases.length==0)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(f.tokens.brace_right,"Expected '}' for switch."),this._currentLoop.pop(),e}_switch_body(){const e=[];let t=!1;for(;this._check([f.keywords.default,f.keywords.case]);){if(this._match(f.keywords.case)){const n=this._case_selectors();for(const r of n)if(r instanceof ke){if(t)throw this._error(this._previous(),"Multiple default cases in switch statement.");t=!0;break}this._match(f.tokens.colon),this._check(f.tokens.attr)&&this._attribute(),this._consume(f.tokens.brace_left,"Exected '{' for switch case.");const s=this._case_body();this._consume(f.tokens.brace_right,"Exected '}' for switch case."),e.push(this._updateNode(new Ut(n,s)))}if(this._match(f.keywords.default)){if(t)throw this._error(this._previous(),"Multiple default cases in switch statement.");this._match(f.tokens.colon),this._check(f.tokens.attr)&&this._attribute(),this._consume(f.tokens.brace_left,"Exected '{' for switch default.");const n=this._case_body();this._consume(f.tokens.brace_right,"Exected '}' for switch default."),e.push(this._updateNode(new Vt(n)))}}return e}_case_selectors(){const e=[];for(this._match(f.keywords.default)?e.push(this._updateNode(new ke)):e.push(this._shift_expression());this._match(f.tokens.comma);)this._match(f.keywords.default)?e.push(this._updateNode(new ke)):e.push(this._shift_expression());return e}_case_body(){if(this._match(f.keywords.fallthrough))return this._consume(f.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(e==null)return[];e instanceof Array||(e=[e]);const t=this._case_body();return t.length==0?e:[...e,t[0]]}_if_statement(){if(!this._match(f.keywords.if))return null;const e=this._currentLine,t=this._optional_paren_expression();this._check(f.tokens.attr)&&this._attribute();const n=this._compound_statement();let s=[];this._match_elseif()&&(this._check(f.tokens.attr)&&this._attribute(),s=this._elseif_statement(s));let r=null;return this._match(f.keywords.else)&&(this._check(f.tokens.attr)&&this._attribute(),r=this._compound_statement()),this._updateNode(new Et(t,n,s,r),e)}_match_elseif(){return this._tokens[this._current].type===f.keywords.else&&this._tokens[this._current+1].type===f.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),n=this._compound_statement();return e.push(this._updateNode(new Cn(t,n))),this._match_elseif()&&(this._check(f.tokens.attr)&&this._attribute(),this._elseif_statement(e)),e}_return_statement(){if(!this._match(f.keywords.return))return null;const e=this._short_circuit_or_expression();return this._updateNode(new Ot(e))}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(f.tokens.or_or);)e=this._updateNode(new K(this._previous().toString(),e,this._short_circuit_and_expr()));return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(f.tokens.and_and);)e=this._updateNode(new K(this._previous().toString(),e,this._inclusive_or_expression()));return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(f.tokens.or);)e=this._updateNode(new K(this._previous().toString(),e,this._exclusive_or_expression()));return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(f.tokens.xor);)e=this._updateNode(new K(this._previous().toString(),e,this._and_expression()));return e}_and_expression(){let e=this._equality_expression();for(;this._match(f.tokens.and);)e=this._updateNode(new K(this._previous().toString(),e,this._equality_expression()));return e}_equality_expression(){const e=this._relational_expression();return this._match([f.tokens.equal_equal,f.tokens.not_equal])?this._updateNode(new K(this._previous().toString(),e,this._relational_expression())):e}_relational_expression(){let e=this._shift_expression();for(;this._match([f.tokens.less_than,f.tokens.greater_than,f.tokens.less_than_equal,f.tokens.greater_than_equal]);)e=this._updateNode(new K(this._previous().toString(),e,this._shift_expression()));return e}_shift_expression(){let e=this._additive_expression();for(;this._match([f.tokens.shift_left,f.tokens.shift_right]);)e=this._updateNode(new K(this._previous().toString(),e,this._additive_expression()));return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([f.tokens.plus,f.tokens.minus]);)e=this._updateNode(new K(this._previous().toString(),e,this._multiplicative_expression()));return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([f.tokens.star,f.tokens.forward_slash,f.tokens.modulo]);)e=this._updateNode(new K(this._previous().toString(),e,this._unary_expression()));return e}_unary_expression(){return this._match([f.tokens.minus,f.tokens.bang,f.tokens.tilde,f.tokens.star,f.tokens.and])?this._updateNode(new C(this._previous().toString(),this._unary_expression())):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(f.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(f.tokens.bracket_right,"Expected ']'.");const t=this._updateNode(new ce(e)),n=this._postfix_expression();return n&&(t.postfix=n),t}if(this._match(f.tokens.period)){const e=this._consume(f.tokens.name,"Expected member name."),t=this._postfix_expression(),n=this._updateNode(new oe(e.lexeme));return t&&(n.postfix=t),n}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_getType(e){const t=this._getStruct(e);if(t!==null)return t;switch(e){case"void":return v.void;case"bool":return v.bool;case"i32":return v.i32;case"u32":return v.u32;case"f32":return v.f32;case"f16":return v.f16;case"vec2f":return g.vec2f;case"vec3f":return g.vec3f;case"vec4f":return g.vec4f;case"vec2i":return g.vec2i;case"vec3i":return g.vec3i;case"vec4i":return g.vec4i;case"vec2u":return g.vec2u;case"vec3u":return g.vec3u;case"vec4u":return g.vec4u;case"vec2h":return g.vec2h;case"vec3h":return g.vec3h;case"vec4h":return g.vec4h;case"mat2x2f":return g.mat2x2f;case"mat2x3f":return g.mat2x3f;case"mat2x4f":return g.mat2x4f;case"mat3x2f":return g.mat3x2f;case"mat3x3f":return g.mat3x3f;case"mat3x4f":return g.mat3x4f;case"mat4x2f":return g.mat4x2f;case"mat4x3f":return g.mat4x3f;case"mat4x4f":return g.mat4x4f;case"mat2x2h":return g.mat2x2h;case"mat2x3h":return g.mat2x3h;case"mat2x4h":return g.mat2x4h;case"mat3x2h":return g.mat3x2h;case"mat3x3h":return g.mat3x3h;case"mat3x4h":return g.mat3x4h;case"mat4x2h":return g.mat4x2h;case"mat4x3h":return g.mat4x3h;case"mat4x4h":return g.mat4x4h;case"mat2x2i":return g.mat2x2i;case"mat2x3i":return g.mat2x3i;case"mat2x4i":return g.mat2x4i;case"mat3x2i":return g.mat3x2i;case"mat3x3i":return g.mat3x3i;case"mat3x4i":return g.mat3x4i;case"mat4x2i":return g.mat4x2i;case"mat4x3i":return g.mat4x3i;case"mat4x4i":return g.mat4x4i;case"mat2x2u":return g.mat2x2u;case"mat2x3u":return g.mat2x3u;case"mat2x4u":return g.mat2x4u;case"mat3x2u":return g.mat3x2u;case"mat3x3u":return g.mat3x3u;case"mat3x4u":return g.mat3x4u;case"mat4x2u":return g.mat4x2u;case"mat4x3u":return g.mat4x3u;case"mat4x4u":return g.mat4x4u}return null}_validateTypeRange(e,t){if(t.name==="i32"){if(e<-2147483648||e>2147483647)throw this._error(this._previous(),`Value out of range for i32: ${e}. Line: ${this._currentLine}.`)}else if(t.name==="u32"&&(e<0||e>4294967295))throw this._error(this._previous(),`Value out of range for u32: ${e}. Line: ${this._currentLine}.`)}_primary_expression(){if(this._match(f.tokens.ident)){const n=this._previous().toString();if(this._check(f.tokens.paren_left)){const s=this._argument_expression_list(),r=this._getType(n);return r!==null?this._updateNode(new Z(r,s)):this._updateNode(new Xe(n,s))}if(this._context.constants.has(n)){const s=this._context.constants.get(n);return this._updateNode(new Ft(n,s.value))}return this._updateNode(new j(n))}if(this._match(f.tokens.int_literal)){const n=this._previous().toString();let s=n.endsWith("i")||n.endsWith("i")?v.i32:n.endsWith("u")||n.endsWith("U")?v.u32:v.x32;const r=parseInt(n);return this._validateTypeRange(r,s),this._updateNode(new $(new d(r,this._exec.getTypeInfo(s)),s))}if(this._match(f.tokens.uint_literal)){const n=parseInt(this._previous().toString());return this._validateTypeRange(n,v.u32),this._updateNode(new $(new d(n,this._exec.getTypeInfo(v.u32)),v.u32))}if(this._match([f.tokens.decimal_float_literal,f.tokens.hex_float_literal])){let n=this._previous().toString(),s=n.endsWith("h");s&&(n=n.substring(0,n.length-1));const r=parseFloat(n);this._validateTypeRange(r,s?v.f16:v.f32);const a=s?v.f16:v.f32;return this._updateNode(new $(new d(r,this._exec.getTypeInfo(a)),a))}if(this._match([f.keywords.true,f.keywords.false])){let n=this._previous().toString()===f.keywords.true.rule;return this._updateNode(new $(new d(n?1:0,this._exec.getTypeInfo(v.bool)),v.bool))}if(this._check(f.tokens.paren_left))return this._paren_expression();if(this._match(f.keywords.bitcast)){this._consume(f.tokens.less_than,"Expected '<'.");const n=this._type_decl();this._consume(f.tokens.greater_than,"Expected '>'.");const s=this._paren_expression();return this._updateNode(new Ct(n,s))}const e=this._type_decl(),t=this._argument_expression_list();return this._updateNode(new Z(e,t))}_argument_expression_list(){if(!this._match(f.tokens.paren_left))return null;const e=[];do{if(this._check(f.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(f.tokens.comma));return this._consume(f.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(f.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(f.tokens.paren_right),e}_paren_expression(){this._consume(f.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(f.tokens.paren_right,"Expected ')'."),e}_struct_decl(){if(!this._match(f.keywords.struct))return null;const e=this._currentLine,t=this._consume(f.tokens.ident,"Expected name for struct.").toString();this._consume(f.tokens.brace_left,"Expected '{' for struct body.");const n=[];for(;!this._check(f.tokens.brace_right);){const a=this._attribute(),i=this._consume(f.tokens.name,"Expected variable name.").toString();this._consume(f.tokens.colon,"Expected ':' for struct member type.");const o=this._attribute(),l=this._type_decl();l!=null&&(l.attributes=o),this._check(f.tokens.brace_right)?this._match(f.tokens.comma):this._consume(f.tokens.comma,"Expected ',' for struct member."),n.push(this._updateNode(new pt(i,l,a)))}this._consume(f.tokens.brace_right,"Expected '}' after struct body.");const s=this._currentLine,r=this._updateNode(new Q(t,n,e,s),e);return this._context.structs.set(t,r),r}_global_variable_decl(){const e=this._variable_decl();if(!e)return null;if(this._match(f.tokens.equal)){const t=this._const_expression();e.value=t}if(e.type!==null&&e.value instanceof $){if(e.value.type.name!=="x32"&&e.type.getTypeName()!==e.value.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`);e.value.isScalar&&this._validateTypeRange(e.value.scalarValue,e.type),e.value.type=e.type}else e.type===null&&e.value instanceof $&&(e.type=e.value.type.name==="x32"?v.i32:e.value.type,e.value.isScalar&&this._validateTypeRange(e.value.scalarValue,e.type));return e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(f.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){var e;if(!this._match(f.keywords.const))return null;const t=this._consume(f.tokens.name,"Expected variable name"),n=this._currentLine;let s=null;if(this._match(f.tokens.colon)){const o=this._attribute();s=this._type_decl(),s!=null&&(s.attributes=o)}let r=null;this._consume(f.tokens.equal,"const declarations require an assignment");const a=this._short_circuit_or_expression();try{let o=[v.f32],l=a.constEvaluate(this._exec,o);l instanceof d&&this._validateTypeRange(l.value,o[0]),o[0]instanceof g&&o[0].format===null&&l.typeInfo instanceof ae&&l.typeInfo.format!==null&&(l.typeInfo.format.name==="f16"?o[0].format=v.f16:l.typeInfo.format.name==="f32"?o[0].format=v.f32:l.typeInfo.format.name==="i32"?o[0].format=v.i32:l.typeInfo.format.name==="u32"?o[0].format=v.u32:l.typeInfo.format.name==="bool"?o[0].format=v.bool:console.error(`TODO: impelement template format type ${l.typeInfo.format.name}`)),r=this._updateNode(new $(l,o[0])),this._exec.context.setVariable(t.toString(),l)}catch{r=a}if(s!==null&&r instanceof $){if(r.type.name!=="x32"&&s.getTypeName()!==r.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${r.type.name} to ${s.name}. Line:${this._currentLine}`);r.type=s,r.isScalar&&this._validateTypeRange(r.scalarValue,r.type)}else s===null&&r instanceof $&&(s=(e=r?.type)!==null&&e!==void 0?e:v.f32,s===v.x32&&(s=v.i32));const i=this._updateNode(new be(t.toString(),s,"","",r),n);return this._context.constants.set(i.name,i),i}_global_let_decl(){if(!this._match(f.keywords.let))return null;const e=this._currentLine,t=this._consume(f.tokens.name,"Expected variable name");let n=null;if(this._match(f.tokens.colon)){const r=this._attribute();n=this._type_decl(),n!=null&&(n.attributes=r)}let s=null;if(this._match(f.tokens.equal)&&(s=this._const_expression()),n!==null&&s instanceof $){if(s.type.name!=="x32"&&n.getTypeName()!==s.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${s.type.name} to ${n.name}. Line:${this._currentLine}`);s.type=n}else n===null&&s instanceof $&&(n=s.type.name==="x32"?v.i32:s.type);return s instanceof $&&s.isScalar&&this._validateTypeRange(s.scalarValue,n),this._updateNode(new pe(t.toString(),n,"","",s),e)}_const_expression(){return this._short_circuit_or_expression()}_variable_decl(){if(!this._match(f.keywords.var))return null;const e=this._currentLine;let t="",n="";this._match(f.tokens.less_than)&&(t=this._consume(f.storage_class,"Expected storage_class.").toString(),this._match(f.tokens.comma)&&(n=this._consume(f.access_mode,"Expected access_mode.").toString()),this._consume(f.tokens.greater_than,"Expected '>'."));const s=this._consume(f.tokens.name,"Expected variable name");let r=null;if(this._match(f.tokens.colon)){const a=this._attribute();r=this._type_decl(),r!=null&&(r.attributes=a)}return this._updateNode(new ee(s.toString(),r,t,n,null),e)}_override_decl(){if(!this._match(f.keywords.override))return null;const e=this._consume(f.tokens.name,"Expected variable name");let t=null;if(this._match(f.tokens.colon)){const n=this._attribute();t=this._type_decl(),t!=null&&(t.attributes=n)}return this._updateNode(new ze(e.toString(),t,null))}_diagnostic(){this._consume(f.tokens.paren_left,"Expected '('");const e=this._consume(f.tokens.ident,"Expected severity control name.");this._consume(f.tokens.comma,"Expected ','");let t=this._consume(f.tokens.ident,"Expected diagnostic rule name.").toString();return this._match(f.tokens.period)&&(t+=`.${this._consume(f.tokens.ident,"Expected diagnostic message.").toString()}`),this._consume(f.tokens.paren_right,"Expected ')'"),this._updateNode(new Pt(e.toString(),t))}_enable_directive(){const e=this._consume(f.tokens.ident,"identity expected.");return this._updateNode(new Nn(e.toString()))}_requires_directive(){const e=[this._consume(f.tokens.ident,"identity expected.").toString()];for(;this._match(f.tokens.comma);){const t=this._consume(f.tokens.ident,"identity expected.");e.push(t.toString())}return this._updateNode(new Bn(e))}_type_alias(){const e=this._consume(f.tokens.ident,"identity expected.");this._consume(f.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(t===null)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const n=this._updateNode(new Ke(e.toString(),t));return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([f.tokens.ident,...f.texel_format,f.keywords.bool,f.keywords.f32,f.keywords.i32,f.keywords.u32])){const n=this._advance().toString();if(this._context.structs.has(n))return this._context.structs.get(n);if(this._context.aliases.has(n))return this._context.aliases.get(n).type;if(!this._getType(n)){const s=this._updateNode(new ft(n));return this._forwardTypeCount++,s}return this._updateNode(new v(n))}let e=this._texture_sampler_types();if(e)return e;if(this._check(f.template_types)){let n=this._advance().toString(),s=null,r=null;return this._match(f.tokens.less_than)&&(s=this._type_decl(),r=null,this._match(f.tokens.comma)&&(r=this._consume(f.access_mode,"Expected access_mode for pointer").toString()),this._consume(f.tokens.greater_than,"Expected '>' for type.")),this._updateNode(new g(n,s,r))}if(this._match(f.keywords.ptr)){let n=this._previous().toString();this._consume(f.tokens.less_than,"Expected '<' for pointer.");const s=this._consume(f.storage_class,"Expected storage_class for pointer");this._consume(f.tokens.comma,"Expected ',' for pointer.");const r=this._type_decl();let a=null;return this._match(f.tokens.comma)&&(a=this._consume(f.access_mode,"Expected access_mode for pointer").toString()),this._consume(f.tokens.greater_than,"Expected '>' for pointer."),this._updateNode(new we(n,s.toString(),r,a))}const t=this._attribute();if(this._match(f.keywords.array)){let n=null,s=-1;const r=this._previous();let a=null;if(this._match(f.tokens.less_than)){n=this._type_decl(),this._context.aliases.has(n.name)&&(n=this._context.aliases.get(n.name).type);let o="";if(this._match(f.tokens.comma)){a=this._shift_expression();try{o=a.constEvaluate(this._exec).toString(),a=null}catch{o="1"}}this._consume(f.tokens.greater_than,"Expected '>' for array."),s=o?parseInt(o):0}const i=this._updateNode(new de(r.toString(),t,n,s));return a&&this._deferArrayCountEval.push({arrayType:i,countNode:a}),i}return null}_texture_sampler_types(){if(this._match(f.sampler_type))return this._updateNode(new he(this._previous().toString(),null,null));if(this._match(f.depth_texture_type))return this._updateNode(new he(this._previous().toString(),null,null));if(this._match(f.sampled_texture_type)||this._match(f.multisampled_texture_type)){const e=this._previous();this._consume(f.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(f.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new he(e.toString(),t,null))}if(this._match(f.storage_texture_type)){const e=this._previous();this._consume(f.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(f.texel_format,"Invalid texel format.").toString();this._consume(f.tokens.comma,"Expected ',' after texel format.");const n=this._consume(f.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(f.tokens.greater_than,"Expected '>' for sampler type."),this._updateNode(new he(e.toString(),t,n))}return null}_attribute(){let e=[];for(;this._match(f.tokens.attr);){const t=this._consume(f.attribute_name,"Expected attribute name"),n=this._updateNode(new Mt(t.toString(),null));if(this._match(f.tokens.paren_left)){if(n.value=this._consume(f.literal_or_ident,"Expected attribute value").toString(),this._check(f.tokens.comma)){this._advance();do{const s=this._consume(f.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(s)}while(this._match(f.tokens.comma))}this._consume(f.tokens.paren_right,"Expected ')'")}e.push(n)}return e.length==0?null:e}}class Xn extends Y{constructor(e){super(),e&&this.update(e)}update(e){const t=new Kn().parse(e);this.updateAST(t)}}function Zn(c){const e={attributes:[],bindings:[]};let t;try{t=Yn(c)}catch(r){return N.error(r.message)(),e}for(const r of t.uniforms){const a=[];for(const i of r.type?.members||[])a.push({name:i.name,type:_t(i.type)});e.bindings.push({type:"uniform",name:r.name,group:r.group,location:r.binding,members:a})}for(const r of t.textures)e.bindings.push({type:"texture",name:r.name,group:r.group,location:r.binding});for(const r of t.samplers)e.bindings.push({type:"sampler",name:r.name,group:r.group,location:r.binding});const n=t.entry.vertex[0],s=n?.inputs.length||0;for(let r=0;r<s;r++){const a=n.inputs[r];if(a.locationType==="location"){const i=_t(a.type);e.attributes.push({name:a.name,location:Number(a.location),type:i})}}return e}function _t(c){return c.format?`${c.name}<${c.format.name}>`:c.name}function Yn(c){try{return new Xn(c)}catch(e){if(e instanceof Error)throw e;let t="WGSL parse error";throw typeof e=="object"&&e?.message&&(t+=`: ${e.message} `),typeof e=="object"&&e?.token&&(t+=e.token.line||""),new Error(t,{cause:e})}}function et(c,e=[],t=0){const n=Math.fround(c),s=c-n;return e[t]=n,e[t+1]=s,e}function Wt(c){return c-Math.fround(c)}function Rt(c){const e=new Float32Array(32);for(let t=0;t<4;++t)for(let n=0;n<4;++n){const s=t*4+n;et(c[n*4+t],e,s*2)}return e}const Qn=`
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`,Jn=`const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);

const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);

const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);

const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!

float nint(float d) {
    if (d == floor(d)) return d;
    return floor(d + 0.5);
}

vec2 nint_fp64(vec2 a) {
    float hi = nint(a.x);
    float lo;
    vec2 tmp;
    if (hi == a.x) {
        lo = nint(a.y);
        tmp = quickTwoSum(hi, lo);
    } else {
        lo = 0.0;
        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
            hi -= 1.0;
        }
        tmp = vec2(hi, lo);
    }
    return tmp;
}

/* k_power controls how much range reduction we would like to have
Range reduction uses the following method:
assume a = k_power * r + m * log(2), k and m being integers.
Set k_power = 4 (we can choose other k to trade accuracy with performance.
we only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;
*/

vec2 exp_fp64(vec2 a) {
  // We need to make sure these two numbers match
  // as bit-wise shift is not available in GLSL 1.0
  const int k_power = 4;
  const float k = 16.0;

  const float inv_k = 1.0 / k;

  if (a.x <= -88.0) return vec2(0.0, 0.0);
  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
  if (a.x == 1.0 && a.y == 0.0) return E_FP64;

  float m = floor(a.x / LOG2_FP64.x + 0.5);
  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
  vec2 s, t, p;

  p = mul_fp64(r, r);
  s = sum_fp64(r, p * 0.5);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);

  s = sum_fp64(s, t);


  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.
  for (int i = 0; i < k_power; i++) {
    s = sum_fp64(s * 2.0, mul_fp64(s, s));
  }

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = sum_fp64(s, vec2(fp64.ONE, 0.0));
#else
  s = sum_fp64(s, vec2(1.0, 0.0));
#endif

  return s * pow(2.0, m);
//   return r;
}

vec2 log_fp64(vec2 a)
{
  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
  vec2 x = vec2(log(a.x), 0.0);
  vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = vec2(fp64.ONE, 0.0);
#else
  s = vec2(1.0, 0.0);
#endif

  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
  return x;
}

vec2 sin_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(0.0, 0.0);
  }

  x = -mul_fp64(a, a);
  s = a;
  r = a;

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);
  // s = sum_fp64(s, t);

  return s;
}

vec2 cos_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(1.0, 0.0);
  }

  x = -mul_fp64(a, a);
  r = x;
  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);
  // s = sum_fp64(s, t);

  return s;
}

void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
  if (a.x == 0.0 && a.y == 0.0) {
    sin_t = vec2(0.0, 0.0);
    cos_t = vec2(1.0, 0.0);
  }

  sin_t = sin_taylor_fp64(a);
  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}

vec2 sin_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return sin_taylor_fp64(t);
        } else if (j == 1) {
            return cos_taylor_fp64(t);
        } else if (j == -1) {
            return -cos_taylor_fp64(t);
        } else {
            return -sin_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);



    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        }
    } else {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    }

    return result;
}

vec2 cos_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(1.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return cos_taylor_fp64(t);
        } else if (j == 1) {
            return -sin_taylor_fp64(t);
        } else if (j == -1) {
            return sin_taylor_fp64(t);
        } else {
            return -cos_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);

    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    return result;
}

vec2 tan_fp64(vec2 a) {
    vec2 sin_a;
    vec2 cos_a;

    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);


    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    // We just can't get PI/16 * 3.0 very accurately.
    // so let's just store it
    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }


    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

    vec2 sin_t, cos_t;
    vec2 s, c;
    sincos_taylor_fp64(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#else
        if (abs_k == 1) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs_k == 2) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs_k == 3) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs_k == 4) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#endif
        if (k > 0) {
            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return div_fp64(sin_a, cos_a);
}

vec2 radians_fp64(vec2 degree) {
  return mul_fp64(degree, PI_180_FP64);
}

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

// Vector functions
// vec2 functions
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sum_fp64(a[0], b[0]);
    out_val[1] = sum_fp64(a[1], b[1]);
}

void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sub_fp64(a[0], b[0]);
    out_val[1] = sub_fp64(a[1], b[1]);
}

void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = mul_fp64(a[0], b[0]);
    out_val[1] = mul_fp64(a[1], b[1]);
}

void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = div_fp64(a[0], b[0]);
    out_val[1] = div_fp64(a[1], b[1]);
}

void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
  vec2 range[2];
  vec2_sub_fp64(y, x, range);
  vec2 portion[2];
  portion[0] = range[0] * a;
  portion[1] = range[1] * a;
  vec2_sum_fp64(x, portion, out_val);
}

vec2 vec2_length_fp64(vec2 x[2]) {
  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}

void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
  vec2 length = vec2_length_fp64(x);
  vec2 length_vec2[2];
  length_vec2[0] = length;
  length_vec2[1] = length;

  vec2_div_fp64(x, length_vec2, out_val);
}

vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
  vec2 diff[2];
  vec2_sub_fp64(x, y, diff);
  return vec2_length_fp64(diff);
}

vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
  vec2 v[2];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);

  return sum_fp64(v[0], v[1]);
}

// vec3 functions
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

vec2 vec3_length_fp64(vec2 x[3]) {
  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
    mul_fp64(x[2], x[2])));
}

vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
  vec2 diff[3];
  vec3_sub_fp64(x, y, diff);
  return vec3_length_fp64(diff);
}

// vec4 functions
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
  out_val[0].x = a[0];
  out_val[0].y = 0.0;

  out_val[1].x = a[1];
  out_val[1].y = 0.0;

  out_val[2].x = a[2];
  out_val[2].y = 0.0;

  out_val[3].x = a[3];
  out_val[3].y = 0.0;
}

void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
  out_val[0] = mul_fp64(a[0], b);
  out_val[1] = mul_fp64(a[1], b);
  out_val[2] = mul_fp64(a[2], b);
  out_val[3] = mul_fp64(a[3], b);
}

void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
  for (int i = 0; i < 4; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
  vec2 v[4];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);
  v[2] = mul_fp64(a[2], b[2]);
  v[3] = mul_fp64(a[3], b[3]);

  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}

void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
  vec2 tmp[4];

  for (int i = 0; i < 4; i++)
  {
    for (int j = 0; j < 4; j++)
    {
      tmp[j] = b[j + i * 4];
    }
    vec4_dot_fp64(a, tmp, out_val[i]);
  }
}
`,es={ONE:1},ts={name:"fp64arithmetic",vs:Qn,defaultUniforms:es,uniformTypes:{ONE:"f32"},fp64ify:et,fp64LowPart:Wt,fp64ifyMatrix4:Rt},Ts={name:"fp64",vs:Jn,dependencies:[ts],fp64ify:et,fp64LowPart:Wt,fp64ifyMatrix4:Rt},Ce={};function tt(c="id"){Ce[c]=Ce[c]||1;const e=Ce[c]++;return`${c}-${e}`}class gt{id;userData={};topology;bufferLayout=[];vertexCount;indices;attributes;constructor(e){if(this.id=e.id||tt("geometry"),this.topology=e.topology,this.indices=e.indices||null,this.attributes=e.attributes,this.vertexCount=e.vertexCount,this.bufferLayout=e.bufferLayout||[],this.indices&&!(this.indices.usage&ne.INDEX))throw new Error("Index buffer must have INDEX usage")}destroy(){this.indices?.destroy();for(const e of Object.values(this.attributes))e.destroy()}getVertexCount(){return this.vertexCount}getAttributes(){return this.attributes}getIndexes(){return this.indices||null}_calculateVertexCount(e){return e.byteLength/12}}function ns(c,e){if(e instanceof gt)return e;const t=ss(c,e),{attributes:n,bufferLayout:s}=rs(c,e);return new gt({topology:e.topology||"triangle-list",bufferLayout:s,vertexCount:e.vertexCount,indices:t,attributes:n})}function ss(c,e){if(!e.indices)return;const t=e.indices.value;return c.createBuffer({usage:ne.INDEX,data:t})}function rs(c,e){const t=[],n={};for(const[r,a]of Object.entries(e.attributes)){let i=r;switch(r){case"POSITION":i="positions";break;case"NORMAL":i="normals";break;case"TEXCOORD_0":i="texCoords";break;case"COLOR_0":i="colors";break}if(a){n[i]=c.createBuffer({data:a.value,id:`${r}-buffer`});const{value:o,size:l,normalized:u}=a;t.push({name:i,format:xn(o,l,u)})}}const s=e._calculateVertexCount(e.attributes,e.indices);return{attributes:n,bufferLayout:t,vertexCount:s}}class nt{static defaultProps={...Ve.defaultProps};static getDefaultPipelineFactory(e){return e._lumaData.defaultPipelineFactory=e._lumaData.defaultPipelineFactory||new nt(e),e._lumaData.defaultPipelineFactory}device;destroyPolicy;_hashCounter=0;_hashes={};_renderPipelineCache={};_computePipelineCache={};constructor(e){this.device=e,this.destroyPolicy=e.props._factoryDestroyPolicy}createRenderPipeline(e){const t={...Ve.defaultProps,...e},n=this._hashRenderPipeline(t);if(!this._renderPipelineCache[n]){const s=this.device.createRenderPipeline({...t,id:t.id?`${t.id}-cached`:void 0});s.hash=n,this._renderPipelineCache[n]={pipeline:s,useCount:0}}return this._renderPipelineCache[n].useCount++,this._renderPipelineCache[n].pipeline}createComputePipeline(e){const t={...Ie.defaultProps,...e},n=this._hashComputePipeline(t);if(!this._computePipelineCache[n]){const s=this.device.createComputePipeline({...t,id:t.id?`${t.id}-cached`:void 0});s.hash=n,this._computePipelineCache[n]={pipeline:s,useCount:0}}return this._computePipelineCache[n].useCount++,this._computePipelineCache[n].pipeline}release(e){const t=e.hash,n=e instanceof Ie?this._computePipelineCache:this._renderPipelineCache;n[t].useCount--,n[t].useCount===0&&this.destroyPolicy==="unused"&&(n[t].pipeline.destroy(),delete n[t])}_hashComputePipeline(e){return`${this._getHash(e.shader.source)}`}_hashRenderPipeline(e){const t=e.vs?this._getHash(e.vs.source):0,n=e.fs?this._getHash(e.fs.source):0,s="-",r=this._getHash(JSON.stringify(e.bufferLayout));switch(this.device.type){case"webgl":return`${t}/${n}V${s}BL${r}`;default:const a=this._getHash(JSON.stringify(e.parameters));return`${t}/${n}V${s}T${e.topology}P${a}BL${r}`}}_getHash(e){return this._hashes[e]===void 0&&(this._hashes[e]=this._hashCounter++),this._hashes[e]}}class st{static defaultProps={...Xt.defaultProps};static getDefaultShaderFactory(e){return e._lumaData.defaultShaderFactory||=new st(e),e._lumaData.defaultShaderFactory}device;destroyPolicy;_cache={};constructor(e){this.device=e,this.destroyPolicy=e.props._factoryDestroyPolicy}createShader(e){const t=this._hashShader(e);let n=this._cache[t];if(!n){const s=this.device.createShader({...e,id:e.id?`${e.id}-cached`:void 0});this._cache[t]=n={shader:s,useCount:0}}return n.useCount++,n.shader}release(e){const t=this._hashShader(e),n=this._cache[t];n&&(n.useCount--,n.useCount===0&&this.destroyPolicy==="unused"&&(delete this._cache[t],n.shader.destroy()))}_hashShader(e){return`${e.stage}:${e.source}`}}function is(c,e){const t={},n="Values";if(c.attributes.length===0&&!c.varyings?.length)return{"No attributes or varyings":{[n]:"N/A"}};for(const s of c.attributes)if(s){const r=`${s.location} ${s.name}: ${s.type}`;t[`in ${r}`]={[n]:s.stepMode||"vertex"}}for(const s of c.varyings||[]){const r=`${s.location} ${s.name}`;t[`out ${r}`]={[n]:JSON.stringify(s)}}return t}let D=null,$e=null;function as(c,{id:e,minimap:t,opaque:n,top:s="0",left:r="0",rgbaScale:a=1}){D||(D=document.createElement("canvas"),D.id=e,D.title=e,D.style.zIndex="100",D.style.position="absolute",D.style.top=s,D.style.left=r,D.style.border="blue 5px solid",D.style.transform="scaleY(-1)",document.body.appendChild(D),$e=D.getContext("2d")),(D.width!==c.width||D.height!==c.height)&&(D.width=c.width/2,D.height=c.height/2,D.style.width="400px",D.style.height="400px");const i=c.device.readPixelsToArrayWebGL(c),o=$e?.createImageData(c.width,c.height);if(o){for(let u=0;u<i.length;u+=4)o.data[0+u+0]=i[u+0]*a,o.data[0+u+1]=i[u+1]*a,o.data[0+u+2]=i[u+2]*a,o.data[0+u+3]=n?255:i[u+3]*a;$e?.putImageData(o,0,0)}}function qe(c,e,t){if(c===e)return!0;if(!t||!c||!e)return!1;if(Array.isArray(c)){if(!Array.isArray(e)||c.length!==e.length)return!1;for(let n=0;n<c.length;n++)if(!qe(c[n],e[n],t-1))return!1;return!0}if(Array.isArray(e))return!1;if(typeof c=="object"&&typeof e=="object"){const n=Object.keys(c),s=Object.keys(e);if(n.length!==s.length)return!1;for(const r of n)if(!e.hasOwnProperty(r)||!qe(c[r],e[r],t-1))return!1;return!0}return!1}function os(c){return Zt(c)||typeof c=="number"||typeof c=="boolean"}function qt(c){const e={bindings:{},uniforms:{}};return Object.keys(c).forEach(t=>{const n=c[t];os(n)?e.uniforms[t]=n:e.bindings[t]=n}),e}class us{options={disableWarnings:!1};modules;moduleUniforms;moduleBindings;constructor(e,t){Object.assign(this.options,t);const n=Yt(Object.values(e).filter(s=>s.dependencies));for(const s of n)e[s.name]=s;N.log(1,"Creating ShaderInputs with modules",Object.keys(e))(),this.modules=e,this.moduleUniforms={},this.moduleBindings={};for(const[s,r]of Object.entries(e))this._addModule(r),r.name&&s!==r.name&&!this.options.disableWarnings&&N.warn(`Module name: ${s} vs ${r.name}`)()}destroy(){}setProps(e){for(const t of Object.keys(e)){const n=t,s=e[n]||{},r=this.modules[n];if(!r){this.options.disableWarnings||N.warn(`Module ${t} not found`)();continue}const a=this.moduleUniforms[n],i=this.moduleBindings[n],o=r.getUniforms?.(s,a)||s,{uniforms:l,bindings:u}=qt(o);this.moduleUniforms[n]={...a,...l},this.moduleBindings[n]={...i,...u}}}getModules(){return Object.values(this.modules)}getUniformValues(){return this.moduleUniforms}getBindingValues(){const e={};for(const t of Object.values(this.moduleBindings))Object.assign(e,t);return e}getDebugTable(){const e={};for(const[t,n]of Object.entries(this.moduleUniforms))for(const[s,r]of Object.entries(n))e[`${t}.${s}`]={type:this.modules[t].uniformTypes?.[s],value:String(r)};return e}_addModule(e){const t=e.name;this.moduleUniforms[t]=e.defaultUniforms||{},this.moduleBindings[t]={}}}let ls="";async function cs(c,e){const t=new Image;return t.crossOrigin="anonymous",t.src=c.startsWith("http")?c:ls+c,await t.decode(),e?await createImageBitmap(t,e):await createImageBitmap(t)}class De{device;id;texture;sampler;view;ready;isReady=!1;destroyed=!1;resolveReady=()=>{};rejectReady=()=>{};get[Symbol.toStringTag](){return"AsyncTexture"}toString(){return`AsyncTexture:"${this.id}"(${this.isReady?"ready":"loading"})`}constructor(e,t){this.device=e,this.id=t.id||tt("async-texture"),typeof t?.data=="string"&&t.dimension==="2d"&&(t={...t,data:cs(t.data)}),this.ready=new Promise((n,s)=>{this.resolveReady=()=>{this.isReady=!0,n()},this.rejectReady=s}),this.initAsync(t)}async initAsync(e){const t=e.data;let n;try{n=await jt(t)}catch(r){this.rejectReady(r)}if(this.destroyed)return;const s={...e,data:n};this.texture=this.device.createTexture(s),this.sampler=this.texture.sampler,this.view=this.texture.view,this.isReady=!0,this.resolveReady()}destroy(){this.texture&&(this.texture.destroy(),this.texture=null),this.destroyed=!0}resize(e){if(!this.isReady)throw new Error("Cannot resize texture before it is ready");if(e.width===this.texture.width&&e.height===this.texture.height)return!1;if(this.texture){const t=this.texture;this.texture=t.clone(e),t.destroy()}return!0}}async function jt(c){if(c=await c,Array.isArray(c))return await Promise.all(c.map(jt));if(c&&typeof c=="object"&&c.constructor===Object){const e=c,t=await Promise.all(Object.values(e)),n=Object.keys(e),s={};for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s}return c}const ie=2,fs=1e4;class Ht{static defaultProps={...Ve.defaultProps,source:void 0,vs:null,fs:null,id:"unnamed",handle:void 0,userData:{},defines:{},modules:[],moduleSettings:void 0,geometry:null,indexBuffer:null,attributes:{},constantAttributes:{},varyings:[],isInstanced:void 0,instanceCount:0,vertexCount:0,shaderInputs:void 0,pipelineFactory:void 0,shaderFactory:void 0,transformFeedback:void 0,shaderAssembler:Qt.getDefaultShaderAssembler(),debugShaders:void 0,disableWarnings:void 0};device;id;source;vs;fs;pipelineFactory;shaderFactory;userData={};parameters;topology;bufferLayout;isInstanced=void 0;instanceCount=0;vertexCount;indexBuffer=null;bufferAttributes={};constantAttributes={};bindings={};uniforms={};vertexArray;transformFeedback=null;pipeline;shaderInputs;_uniformStore;_attributeInfos={};_gpuGeometry=null;_getModuleUniforms;props;_pipelineNeedsUpdate="newly created";_needsRedraw="initializing";_destroyed=!1;_lastDrawTimestamp=-1;get[Symbol.toStringTag](){return"Model"}toString(){return`Model(${this.id})`}constructor(e,t){this.props={...Ht.defaultProps,...t},t=this.props,this.id=t.id||tt("model"),this.device=e,Object.assign(this.userData,t.userData);const n=Object.fromEntries(this.props.modules?.map(o=>[o.name,o])||[]),s=t.shaderInputs||new us(n,{disableWarnings:this.props.disableWarnings});this.setShaderInputs(s);const r=ps(e),a=(this.props.modules?.length>0?this.props.modules:this.shaderInputs?.getModules())||[];if(this.device.type==="webgpu"&&this.props.source){const{source:o,getUniforms:l}=this.props.shaderAssembler.assembleWGSLShader({platformInfo:r,...this.props,modules:a});this.source=o,this._getModuleUniforms=l,this.props.shaderLayout||=Zn(this.source)}else{const{vs:o,fs:l,getUniforms:u}=this.props.shaderAssembler.assembleGLSLShaderPair({platformInfo:r,...this.props,modules:a});this.vs=o,this.fs=l,this._getModuleUniforms=u}this.vertexCount=this.props.vertexCount,this.instanceCount=this.props.instanceCount,this.topology=this.props.topology,this.bufferLayout=this.props.bufferLayout,this.parameters=this.props.parameters,t.geometry&&this.setGeometry(t.geometry),this.pipelineFactory=t.pipelineFactory||nt.getDefaultPipelineFactory(this.device),this.shaderFactory=t.shaderFactory||st.getDefaultShaderFactory(this.device),this.pipeline=this._updatePipeline(),this.vertexArray=e.createVertexArray({renderPipeline:this.pipeline}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry),"isInstanced"in t&&(this.isInstanced=t.isInstanced),t.instanceCount&&this.setInstanceCount(t.instanceCount),t.vertexCount&&this.setVertexCount(t.vertexCount),t.indexBuffer&&this.setIndexBuffer(t.indexBuffer),t.attributes&&this.setAttributes(t.attributes),t.constantAttributes&&this.setConstantAttributes(t.constantAttributes),t.bindings&&this.setBindings(t.bindings),t.uniforms&&this.setUniformsWebGL(t.uniforms),t.moduleSettings&&this.updateModuleSettingsWebGL(t.moduleSettings),t.transformFeedback&&(this.transformFeedback=t.transformFeedback),Object.seal(this)}destroy(){this._destroyed||(this.pipelineFactory.release(this.pipeline),this.shaderFactory.release(this.pipeline.vs),this.pipeline.fs&&this.shaderFactory.release(this.pipeline.fs),this._uniformStore.destroy(),this._gpuGeometry?.destroy(),this._destroyed=!0)}needsRedraw(){this._getBindingsUpdateTimestamp()>this._lastDrawTimestamp&&this.setNeedsRedraw("contents of bound textures or buffers updated");const e=this._needsRedraw;return this._needsRedraw=!1,e}setNeedsRedraw(e){this._needsRedraw||=e}predraw(){this.updateShaderInputs(),this.pipeline=this._updatePipeline()}draw(e){const t=this._areBindingsLoading();if(t)return N.info(ie,`>>> DRAWING ABORTED ${this.id}: ${t} not loaded`)(),!1;try{e.pushDebugGroup(`${this}.predraw(${e})`),this.predraw()}finally{e.popDebugGroup()}let n;try{e.pushDebugGroup(`${this}.draw(${e})`),this._logDrawCallStart(),this.pipeline=this._updatePipeline();const s=this._getBindings();this.pipeline.setBindings(s,{disableWarnings:this.props.disableWarnings}),je(this.uniforms)||this.pipeline.setUniformsWebGL(this.uniforms);const{indexBuffer:r}=this.vertexArray,a=r?r.byteLength/(r.indexType==="uint32"?4:2):void 0;n=this.pipeline.draw({renderPass:e,vertexArray:this.vertexArray,isInstanced:this.isInstanced,vertexCount:this.vertexCount,instanceCount:this.instanceCount,indexCount:a,transformFeedback:this.transformFeedback||void 0,parameters:this.parameters,topology:this.topology})}finally{e.popDebugGroup(),this._logDrawCallEnd()}return this._logFramebuffer(e),n?(this._lastDrawTimestamp=this.device.timestamp,this._needsRedraw=!1):this._needsRedraw="waiting for resource initialization",n}setGeometry(e){this._gpuGeometry?.destroy();const t=e&&ns(this.device,e);if(t){this.setTopology(t.topology||"triangle-list");const n=new Ne(this.bufferLayout);this.bufferLayout=n.mergeBufferLayouts(t.bufferLayout,this.bufferLayout),this.vertexArray&&this._setGeometryAttributes(t)}this._gpuGeometry=t}setTopology(e){e!==this.topology&&(this.topology=e,this._setPipelineNeedsUpdate("topology"))}setBufferLayout(e){const t=new Ne(this.bufferLayout);this.bufferLayout=this._gpuGeometry?t.mergeBufferLayouts(e,this._gpuGeometry.bufferLayout):e,this._setPipelineNeedsUpdate("bufferLayout"),this.pipeline=this._updatePipeline(),this.vertexArray=this.device.createVertexArray({renderPipeline:this.pipeline}),this._gpuGeometry&&this._setGeometryAttributes(this._gpuGeometry)}setParameters(e){qe(e,this.parameters,2)||(this.parameters=e,this._setPipelineNeedsUpdate("parameters"))}setInstanceCount(e){this.instanceCount=e,this.isInstanced===void 0&&e>0&&(this.isInstanced=!0),this.setNeedsRedraw("instanceCount")}setVertexCount(e){this.vertexCount=e,this.setNeedsRedraw("vertexCount")}setShaderInputs(e){this.shaderInputs=e,this._uniformStore=new _n(this.shaderInputs.modules);for(const[t,n]of Object.entries(this.shaderInputs.modules))if(hs(n)){const s=this._uniformStore.getManagedUniformBuffer(this.device,t);this.bindings[`${t}Uniforms`]=s}this.setNeedsRedraw("shaderInputs")}updateShaderInputs(){this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()),this.setBindings(this.shaderInputs.getBindingValues()),this.setNeedsRedraw("shaderInputs")}setBindings(e){Object.assign(this.bindings,e),this.setNeedsRedraw("bindings")}setTransformFeedback(e){this.transformFeedback=e,this.setNeedsRedraw("transformFeedback")}setIndexBuffer(e){this.vertexArray.setIndexBuffer(e),this.setNeedsRedraw("indexBuffer")}setAttributes(e,t){const n=t?.disableWarnings??this.props.disableWarnings;e.indices&&N.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)(),this.bufferLayout=vn(this.pipeline.shaderLayout,this.bufferLayout);const s=new Ne(this.bufferLayout);for(const[r,a]of Object.entries(e)){const i=s.getBufferLayout(r);if(!i){n||N.warn(`Model(${this.id}): Missing layout for buffer "${r}".`)();continue}const o=s.getAttributeNamesForBuffer(i);let l=!1;for(const u of o){const h=this._attributeInfos[u];if(h){const x=this.device.type==="webgpu"?s.getBufferIndex(h.bufferName):h.location;this.vertexArray.setBuffer(x,a),l=!0}}!l&&!n&&N.warn(`Model(${this.id}): Ignoring buffer "${a.id}" for unknown attribute "${r}"`)()}this.setNeedsRedraw("attributes")}setConstantAttributes(e,t){for(const[n,s]of Object.entries(e)){const r=this._attributeInfos[n];r?this.vertexArray.setConstantWebGL(r.location,s):(t?.disableWarnings??this.props.disableWarnings)||N.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${n}"`)()}this.setNeedsRedraw("constants")}setUniforms(e){this.setUniformsWebGL(e)}setUniformsWebGL(e){je(e)||(this.pipeline.setUniformsWebGL(e),Object.assign(this.uniforms,e)),this.setNeedsRedraw("uniforms")}updateModuleSettingsWebGL(e){const{bindings:t,uniforms:n}=qt(this._getModuleUniforms(e));Object.assign(this.bindings,t),Object.assign(this.uniforms,n),this.setNeedsRedraw("moduleSettings")}_areBindingsLoading(){for(const e of Object.values(this.bindings))if(e instanceof De&&!e.isReady)return e.id;return!1}_getBindings(){const e={};for(const[t,n]of Object.entries(this.bindings))n instanceof De?n.isReady&&(e[t]=n.texture):e[t]=n;return e}_getBindingsUpdateTimestamp(){let e=0;for(const t of Object.values(this.bindings))t instanceof Jt?e=Math.max(e,t.texture.updateTimestamp):t instanceof ne||t instanceof en?e=Math.max(e,t.updateTimestamp):t instanceof De?e=t.texture?Math.max(e,t.texture.updateTimestamp):1/0:t instanceof tn||(e=Math.max(e,t.buffer.updateTimestamp));return e}_setGeometryAttributes(e){const t={...e.attributes};for(const[n]of Object.entries(t))!this.pipeline.shaderLayout.attributes.find(s=>s.name===n)&&n!=="positions"&&delete t[n];this.vertexCount=e.vertexCount,this.setIndexBuffer(e.indices||null),this.setAttributes(e.attributes,{disableWarnings:!0}),this.setAttributes(t,{disableWarnings:this.props.disableWarnings}),this.setNeedsRedraw("geometry attributes")}_setPipelineNeedsUpdate(e){this._pipelineNeedsUpdate||=e,this.setNeedsRedraw(e)}_updatePipeline(){if(this._pipelineNeedsUpdate){let e=null,t=null;this.pipeline&&(N.log(1,`Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(),e=this.pipeline.vs,t=this.pipeline.fs),this._pipelineNeedsUpdate=!1;const n=this.shaderFactory.createShader({id:`${this.id}-vertex`,stage:"vertex",source:this.source||this.vs,debugShaders:this.props.debugShaders});let s=null;this.source?s=n:this.fs&&(s=this.shaderFactory.createShader({id:`${this.id}-fragment`,stage:"fragment",source:this.source||this.fs,debugShaders:this.props.debugShaders})),this.pipeline=this.pipelineFactory.createRenderPipeline({...this.props,bufferLayout:this.bufferLayout,topology:this.topology,parameters:this.parameters,bindings:this._getBindings(),vs:n,fs:s}),this._attributeInfos=nn(this.pipeline.shaderLayout,this.bufferLayout),e&&this.shaderFactory.release(e),t&&this.shaderFactory.release(t)}return this.pipeline}_lastLogTime=0;_logOpen=!1;_logDrawCallStart(){const e=N.level>3?0:fs;N.level<2||Date.now()-this._lastLogTime<e||(this._lastLogTime=Date.now(),this._logOpen=!0,N.group(ie,`>>> DRAWING MODEL ${this.id}`,{collapsed:N.level<=2})())}_logDrawCallEnd(){if(this._logOpen){const e=is(this.pipeline.shaderLayout,this.id);N.table(ie,e)();const t=this.shaderInputs.getDebugTable();for(const[s,r]of Object.entries(this.uniforms))t[s]={value:r};N.table(ie,t)();const n=this._getAttributeDebugTable();N.table(ie,this._attributeInfos)(),N.table(ie,n)(),N.groupEnd(ie)(),this._logOpen=!1}}_drawCount=0;_logFramebuffer(e){const t=this.device.props.debugFramebuffers;if(this._drawCount++,!t)return;const n=e.props.framebuffer;n&&as(n,{id:n.id,minimap:!0})}_getAttributeDebugTable(){const e={};for(const[t,n]of Object.entries(this._attributeInfos)){const s=this.vertexArray.attributes[n.location];e[n.location]={name:t,type:n.shaderType,values:s?this._getBufferOrConstantValues(s,n.bufferDataType):"null"}}if(this.vertexArray.indexBuffer){const{indexBuffer:t}=this.vertexArray,n=t.indexType==="uint32"?new Uint32Array(t.debugData):new Uint16Array(t.debugData);e.indices={name:"indices",type:t.indexType,values:n.toString()}}return e}_getBufferOrConstantValues(e,t){const n=yn(t);return(e instanceof ne?new n(e.debugData):e).toString()}}function hs(c){return!!(c.uniformTypes&&!je(c.uniformTypes))}function ps(c){return{type:c.type,shaderLanguage:c.info.shadingLanguage,shaderLanguageVersion:c.info.shadingLanguageVersion,gpu:c.info.gpu,features:c.features}}function je(c){for(const e in c)return!1;return!0}function yt(c,e){if(!e)return c;const t={...c,...e};if("defines"in e&&(t.defines={...c.defines,...e.defines}),"modules"in e&&(t.modules=(c.modules||[]).concat(e.modules),e.modules.some(n=>n.name==="project64"))){const n=t.modules.findIndex(s=>s.name==="project32");n>=0&&t.modules.splice(n,1)}if("inject"in e)if(!c.inject)t.inject=e.inject;else{const n={...c.inject};for(const s in e.inject)n[s]=(n[s]||"")+e.inject[s];t.inject=n}return t}class Pe{static get componentName(){return Object.prototype.hasOwnProperty.call(this,"extensionName")?this.extensionName:""}constructor(e){e&&(this.opts=e)}equals(e){return this===e?!0:this.constructor===e.constructor&&xt(this.opts,e.opts,1)}getShaders(e){return null}getSubLayerProps(e){const{defaultProps:t}=e.constructor,n={updateTriggers:{}};for(const s in t)if(s in this.props){const r=t[s],a=this.props[s];n[s]=a,r&&r.type==="accessor"&&(n.updateTriggers[s]=this.props.updateTriggers[s],typeof a=="function"&&(n[s]=this.getSubLayerAccessor(a)))}return n}initializeState(e,t){}updateState(e,t){}onNeedsRedraw(e){}getNeedsPickingBuffer(e){return!1}draw(e,t){}finalizeState(e,t){}}Pe.defaultProps={};Pe.extensionName="LayerExtension";const ds={inject:{"vs:#decl":`
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,"vs:#main-end":`
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,"fs:#decl":`
uniform pathStyleUniforms {
float dashAlignMode;
bool dashGapPickable;
} pathStyle;
in vec2 vDashArray;
in float vDashOffset;
`,"fs:#main-start":`
float solidLength = vDashArray.x;
float gapLength = vDashArray.y;
float unitLength = solidLength + gapLength;
float offset;
if (unitLength > 0.0) {
if (pathStyle.dashAlignMode == 0.0) {
offset = vDashOffset;
} else {
unitLength = vPathLength / round(vPathLength / unitLength);
offset = solidLength / 2.0;
}
float unitOffset = mod(vPathPosition.y + offset, unitLength);
if (gapLength > 0.0 && unitOffset > solidLength) {
if (path.capType <= 0.5) {
if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {
discard;
}
} else {
float distToEnd = length(vec2(
min(unitOffset - solidLength, unitLength - unitOffset),
vPathPosition.x
));
if (distToEnd > 1.0) {
if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {
discard;
}
}
}
}
}
`}},ms={inject:{"vs:#decl":`
in float instanceOffsets;
`,"vs:DECKGL_FILTER_SIZE":`
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
size *= offsetWidth;
`,"vs:#main-end":`
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
float offsetDir = sign(instanceOffsets);
vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
vPathPosition.y *= offsetWidth;
vPathLength *= offsetWidth;
`,"fs:#main-start":`
float isInside;
isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
if (isInside == 0.0) {
discard;
}
`}},_s={getDashArray:{type:"accessor",value:[0,0]},getOffset:{type:"accessor",value:0},dashJustified:!1,dashGapPickable:!1};class zt extends Pe{constructor({dash:e=!1,offset:t=!1,highPrecisionDash:n=!1}={}){super({dash:e||n,offset:t,highPrecisionDash:n})}isEnabled(e){return"pathTesselator"in e.state}getShaders(e){if(!e.isEnabled(this))return null;let t={};e.opts.dash&&(t=yt(t,ds)),e.opts.offset&&(t=yt(t,ms));const{inject:n}=t;return{modules:[{name:"pathStyle",inject:n,uniformTypes:{dashAlignMode:"f32",dashGapPickable:"i32"}}]}}initializeState(e,t){const n=this.getAttributeManager();!n||!t.isEnabled(this)||(t.opts.dash&&n.addInstanced({instanceDashArrays:{size:2,accessor:"getDashArray"},instanceDashOffsets:t.opts.highPrecisionDash?{size:1,accessor:"getPath",transform:t.getDashOffsets.bind(this)}:{size:1,update:s=>{s.constant=!0,s.value=[0]}}}),t.opts.offset&&n.addInstanced({instanceOffsets:{size:1,accessor:"getOffset"}}))}updateState(e,t){if(t.isEnabled(this)&&t.opts.dash){const n={dashAlignMode:this.props.dashJustified?1:0,dashGapPickable:!!this.props.dashGapPickable};this.setShaderModuleProps({pathStyle:n})}}getDashOffsets(e){const t=[0],n=this.props.positionFormat==="XY"?2:3,s=Array.isArray(e[0]),r=s?e.length:e.length/n;let a,i;for(let o=0;o<r-1;o++)a=s?e[o]:e.slice(o*n,o*n+n),a=this.projectPosition(a),o>0&&(t[o]=t[o-1]+sn(i,a)),i=a;return t[r-1]=0,t}}zt.defaultProps=_s;zt.extensionName="PathStyleExtension";const gs=`
in float collisionPriorities;

uniform sampler2D collision_texture;

uniform collisionUniforms {
  bool sort;
  bool enabled;
} collision;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision.enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project.viewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`,ys={"vs:#decl":`
  float collision_fade = 1.0;
`,"vs:DECKGL_FILTER_GL_POSITION":`
  if (collision.sort) {
    float collisionPriority = collisionPriorities;
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision.enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `,"vs:DECKGL_FILTER_COLOR":`
  color.a *= collision_fade;
  `},xs=c=>{if(!c||!("dummyCollisionMap"in c))return{};const{enabled:e,collisionFBO:t,drawToCollisionMap:n,dummyCollisionMap:s}=c;return{enabled:e&&!n,sort:!!n,collision_texture:!n&&t?t.colorAttachments[0]:s}},vs={name:"collision",dependencies:[rn],vs:gs,inject:ys,getUniforms:xs,uniformTypes:{sort:"i32",enabled:"i32"}};class bs extends an{renderCollisionMap(e,t){const s=[0,0,0,0],r=[1,1,e.width-2,e.height-2];this.render({...t,clearColor:s,scissorRect:r,target:e,pass:"collision"})}getLayerParameters(e,t,n){return{...e.props.parameters,blend:!1,depthWriteEnabled:!0,depthCompare:"less-equal"}}getShaderModuleProps(){return{collision:{drawToCollisionMap:!0},picking:{isActive:1,isAttribute:!1},lighting:{enabled:!1}}}}const Ue=2;class ws{constructor(){this.id="collision-filter-effect",this.props=null,this.useInPicking=!0,this.order=1,this.channels={},this.collisionFBOs={}}setup(e){this.context=e;const{device:t}=e;this.dummyCollisionMap=t.createTexture({width:1,height:1}),this.collisionFilterPass=new bs(t,{id:"default-collision-filter"})}preRender({effects:e,layers:t,layerFilter:n,viewports:s,onViewportActive:r,views:a,isPicking:i,preRenderStats:o={}}){const{device:l}=this.context;if(i)return;const u=t.filter(({props:{visible:S,collisionEnabled:P}})=>S&&P);if(u.length===0){this.channels={};return}const h=e?.filter(S=>S.useInPicking&&o[S.id]),x=o["mask-effect"]?.didRender,b=this._groupByCollisionGroup(l,u),k=s[0],O=!this.lastViewport||!this.lastViewport.equals(k)||x;for(const S in b){const P=this.collisionFBOs[S],M=b[S],[A,I]=l.canvasContext.getPixelSize();P.resize({width:A/Ue,height:I/Ue}),this._render(M,{effects:h,layerFilter:n,onViewportActive:r,views:a,viewport:k,viewportChanged:O})}}_render(e,{effects:t,layerFilter:n,onViewportActive:s,views:r,viewport:a,viewportChanged:i}){const{collisionGroup:o}=e,l=this.channels[o];if(!l)return;const u=i||e===l||!xt(l.layers,e.layers,1)||e.layerBounds.some((h,x)=>!on(h,l.layerBounds[x]))||e.allLayersLoaded!==l.allLayersLoaded||e.layers.some(h=>h.props.transitions);if(this.channels[o]=e,u){this.lastViewport=a;const h=this.collisionFBOs[o];this.collisionFilterPass.renderCollisionMap(h,{pass:"collision-filter",isPicking:!0,layers:e.layers,effects:t,layerFilter:n,viewports:a?[a]:[],onViewportActive:s,views:r,shaderModuleProps:{collision:{enabled:!0,dummyCollisionMap:this.dummyCollisionMap},project:{devicePixelRatio:h.device.canvasContext.getDevicePixelRatio()/Ue}}})}}_groupByCollisionGroup(e,t){const n={};for(const s of t){const r=s.props.collisionGroup;let a=n[r];a||(a={collisionGroup:r,layers:[],layerBounds:[],allLayersLoaded:!0},n[r]=a),a.layers.push(s),a.layerBounds.push(s.getBounds()),s.isLoaded||(a.allLayersLoaded=!1)}for(const s of Object.keys(n))this.collisionFBOs[s]||this.createFBO(e,s),this.channels[s]||(this.channels[s]=n[s]);for(const s of Object.keys(this.collisionFBOs))n[s]||this.destroyFBO(s);return n}getShaderModuleProps(e){const{collisionGroup:t,collisionEnabled:n}=e.props,{collisionFBOs:s,dummyCollisionMap:r}=this,a=s[t];return{collision:{enabled:n&&!!a,collisionFBO:a,dummyCollisionMap:r}}}cleanup(){this.dummyCollisionMap&&(this.dummyCollisionMap.delete(),this.dummyCollisionMap=void 0),this.channels={};for(const e of Object.keys(this.collisionFBOs))this.destroyFBO(e);this.collisionFBOs={},this.lastViewport=void 0}createFBO(e,t){const{width:n,height:s}=e.gl.canvas,r=e.createTexture({format:"rgba8unorm",width:n,height:s,sampler:{minFilter:"nearest",magFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),a=e.createTexture({format:"depth16unorm",width:n,height:s,mipmaps:!1});this.collisionFBOs[t]=e.createFramebuffer({id:`collision-${t}`,width:n,height:s,colorAttachments:[r],depthStencilAttachment:a})}destroyFBO(e){const t=this.collisionFBOs[e];t.colorAttachments[0]?.destroy(),t.depthStencilAttachment?.destroy(),t.destroy(),delete this.collisionFBOs[e]}}const ks={getCollisionPriority:{type:"accessor",value:0},collisionEnabled:!0,collisionGroup:{type:"string",value:"default"},collisionTestProps:{}};class Gt extends Pe{getShaders(){return{modules:[vs]}}draw({shaderModuleProps:e}){e.collision?.drawToCollisionMap&&(this.props=this.clone(this.props.collisionTestProps).props)}initializeState(e,t){if(this.getAttributeManager()===null)return;this.context.deck?._addDefaultEffect(new ws),this.getAttributeManager().add({collisionPriorities:{size:1,stepMode:"dynamic",accessor:"getCollisionPriority"}})}getNeedsPickingBuffer(){return this.props.collisionEnabled}}Gt.defaultProps=ks;Gt.extensionName="CollisionFilterExtension";export{Gt as C,Pe as L,Ht as M,zt as P,yn as a,Ts as b,ts as f,gn as g,yt as m,tt as u};
