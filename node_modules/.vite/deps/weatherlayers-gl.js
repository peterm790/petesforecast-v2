import {
  colorRampCanvas,
  parsePalette
} from "./chunk-WBP4RSRP.js";
import {
  collision_filter_extension_default,
  path_style_extension_default
} from "./chunk-XQL4K44H.js";
import {
  BufferTransform,
  COORDINATE_SYSTEM,
  CubeGeometry,
  Geometry,
  Model,
  Tesselator,
  UNIT,
  composite_layer_default,
  createIterable,
  gouraudMaterial,
  layer_default,
  lerp,
  lngLatToWorld,
  load,
  log_default,
  phongMaterial,
  picking_default,
  project32_default
} from "./chunk-DZE7JHRV.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut3;
    module.exports.default = earcut3;
    function earcut3(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x2 = data[i];
          y2 = data[i + 1];
          if (x2 < minX) minX = x2;
          if (y2 < minY) minY = y2;
          if (x2 > maxX) maxX = x2;
          if (y2 > maxY) maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      }
      if (last && equals3(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      if (!end) end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals3(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next) break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b2 = ear, c = ear.next;
      if (area(a, b2, c) >= 0) return false;
      var ax = a.x, bx = b2.x, cx = c.x, ay = a.y, by = b2.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b2 = ear, c = ear.next;
      if (area(a, b2, c) >= 0) return false;
      var ax = a.x, bx = b2.x, cx = c.x, ay = a.y, by = b2.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b2 = p.next.next;
        if (!equals3(a, b2) && intersects(a, p, p.next, b2) && locallyInside(a, b2) && locallyInside(b2, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b2;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b2 = a.next.next;
        while (b2 !== a.prev) {
          if (a.i !== b2.i && isValidDiagonal(a, b2)) {
            var c = splitPolygon(a, b2);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b2) {
      return a.x - b2.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            m = p.x < p.next.x ? p : p.next;
            if (x2 === hx) return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m) return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q2, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q2 = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p.z <= q2.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail) tail.nextZ = e;
            else list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x2, y2, minX, minY, invSize) {
      x2 = (x2 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b2) {
      return a.next.i !== b2.i && a.prev.i !== b2.i && !intersectsPolygon(a, b2) && // dones't intersect other edges
      (locallyInside(a, b2) && locallyInside(b2, a) && middleInside(a, b2) && // locally visible
      (area(a.prev, a, b2.prev) || area(a, b2.prev, b2)) || // does not create opposite-facing sectors
      equals3(a, b2) && area(a.prev, a, a.next) > 0 && area(b2.prev, b2, b2.next) > 0);
    }
    function area(p, q2, r) {
      return (q2.y - p.y) * (r.x - q2.x) - (q2.x - p.x) * (r.y - q2.y);
    }
    function equals3(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;
      return false;
    }
    function onSegment(p, q2, r) {
      return q2.x <= Math.max(p.x, r.x) && q2.x >= Math.min(p.x, r.x) && q2.y <= Math.max(p.y, r.y) && q2.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b2) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b2.i && p.next.i !== b2.i && intersects(p, p.next, a, b2)) return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b2) {
      return area(a.prev, a, a.next) < 0 ? area(a, b2, a.next) >= 0 && area(a, a.prev, b2) >= 0 : area(a, b2, a.prev) < 0 || area(a, a.next, b2) < 0;
    }
    function middleInside(a, b2) {
      var p = a, inside = false, px = (a.x + b2.x) / 2, py = (a.y + b2.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b2) {
      var a2 = new Node(a.i, a.x, a.y), b22 = new Node(b2.i, b2.x, b2.y), an2 = a.next, bp = b2.prev;
      a.next = b2;
      b2.prev = a;
      a2.next = an2;
      an2.prev = a2;
      b22.next = a2;
      a2.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i, x2, y2, last) {
      var p = new Node(i, x2, y2);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ) p.prevZ.nextZ = p.nextZ;
      if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x2, y2) {
      this.i = i;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut3.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b2 = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b2 + 1] - data[a + 1]) - (data[a] - data[b2]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j2 = end - dim; i < end; i += dim) {
        sum += (data[j2] - data[i]) * (data[i + 1] + data[j2 + 1]);
        j2 = i;
      }
      return sum;
    }
    earcut3.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j2 = 0; j2 < data[i].length; j2++) {
          for (var d = 0; d < dim; d++) result.vertices.push(data[i][j2][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-uniforms.js
var uniformBlock = `uniform arcUniforms {
  bool greatCircle;
  bool useShortestPath;
  float numSegments;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int widthUnits;
} arc;
`;
var arcUniforms = {
  name: "arc",
  vs: uniformBlock,
  fs: uniformBlock,
  uniformTypes: {
    greatCircle: "f32",
    useShortestPath: "f32",
    numSegments: "f32",
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-vertex.glsl.js
var arc_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-vertex-shader
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;
out vec4 vColor;
out vec2 uv;
out float isValid;
float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
float deltaZ = targetZ - sourceZ;
float dh = distance * instanceHeights;
if (dh == 0.0) {
return sourceZ + deltaZ * ratio;
}
float unitZ = deltaZ / dh;
float p2 = unitZ * unitZ + 1.0;
float dir = step(deltaZ, 0.0);
float z0 = mix(sourceZ, targetZ, dir);
float r = mix(ratio, 1.0 - ratio, dir);
return sqrt(r * (p2 - r)) * dh + z0;
}
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
float getSegmentRatio(float index) {
return smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));
}
vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
float distance = length(source.xy - target.xy);
float z = paraboloid(distance, source.z, target.z, segmentRatio);
float tiltAngle = radians(instanceTilts);
vec2 tiltDirection = normalize(target.xy - source.xy);
vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);
return vec3(
mix(source.xy, target.xy, segmentRatio) + tilt,
z * cos(tiltAngle)
);
}
float getAngularDist (vec2 source, vec2 target) {
vec2 sourceRadians = radians(source);
vec2 targetRadians = radians(target);
vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
vec2 shd_sq = sin_half_delta * sin_half_delta;
float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
return 2.0 * asin(sqrt(a));
}
vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
vec2 lngLat;
if(abs(angularDist - PI) < 0.001) {
lngLat = (1.0 - t) * source.xy + t * target.xy;
} else {
float a = sin((1.0 - t) * angularDist);
float b = sin(t * angularDist);
vec3 p = source3D.yxz * a + target3D.yxz * b;
lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
}
float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);
return vec3(lngLat, z);
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
float segmentIndex = float(gl_VertexID / 2);
float segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;
float segmentRatio = getSegmentRatio(segmentIndex);
float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
float nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));
float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
isValid = 1.0;
uv = vec2(segmentRatio, segmentSide);
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
vec4 curr;
vec4 next;
vec3 source;
vec3 target;
if ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);
vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);
if (abs(currPos.x - prevPos.x) > 180.0) {
indexDir = -1.0;
isValid = 0.0;
} else if (abs(currPos.x - nextPos.x) > 180.0) {
indexDir = 1.0;
isValid = 0.0;
}
nextPos = indexDir < 0.0 ? prevPos : nextPos;
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
if (isValid == 0.0) {
nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
currPos = mix(currPos, nextPos, t);
segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
}
vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
} else {
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
if (arc.useShortestPath) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng > 180.) target_world.x -= 360.;
if (deltaLng < -180.) source_world.x -= 360.;
}
source = project_position(source_world, instanceSourcePositions64Low);
target = project_position(target_world, instanceTargetPositions64Low);
float antiMeridianX = 0.0;
if (arc.useShortestPath) {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
antiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;
}
float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);
if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
isValid = 0.0;
indexDir = sign(segmentRatio - thresholdRatio);
segmentRatio = thresholdRatio;
}
}
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
vec3 currPos = interpolateFlat(source, target, segmentRatio);
vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);
if (arc.useShortestPath) {
if (nextPos.x < antiMeridianX) {
currPos.x += TILE_SIZE;
nextPos.x += TILE_SIZE;
}
}
curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
geometry.position = vec4(currPos, 1.0);
}
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),
arc.widthMinPixels, arc.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(curr, geometry);
gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
vColor = vec4(color.rgb, color.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-fragment.glsl.js
var arc_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
in float isValid;
out vec4 fragColor;
void main(void) {
if (isValid == 0.0) {
discard;
}
fragColor = vColor;
geometry.uv = uv;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer.js
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  getSourcePosition: { type: "accessor", value: (x2) => x2.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x2) => x2.targetPosition },
  getSourceColor: { type: "accessor", value: DEFAULT_COLOR },
  getTargetColor: { type: "accessor", value: DEFAULT_COLOR },
  getWidth: { type: "accessor", value: 1 },
  getHeight: { type: "accessor", value: 1 },
  getTilt: { type: "accessor", value: 0 },
  greatCircle: false,
  numSegments: { type: "number", value: 50, min: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var ArcLayer = class extends layer_default {
  getBounds() {
    return this.getAttributeManager()?.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: arc_layer_vertex_glsl_default, fs: arc_layer_fragment_glsl_default, modules: [project32_default, picking_default, arcUniforms] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceSourceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getSourceColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceTargetColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getTargetColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: true,
        accessor: "getHeight",
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: true,
        accessor: "getTilt",
        defaultValue: 0
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, greatCircle, wrapLongitude, numSegments } = this.props;
    const arcProps = {
      numSegments,
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      greatCircle,
      useShortestPath: wrapLongitude
    };
    const model = this.state.model;
    model.shaderInputs.setProps({ arc: arcProps });
    model.setVertexCount(numSegments * 2);
    model.draw(this.context.renderPass);
  }
  _getModel() {
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-strip",
      isInstanced: true
    });
  }
};
ArcLayer.layerName = "ArcLayer";
ArcLayer.defaultProps = defaultProps;

// node_modules/@deck.gl/layers/dist/bitmap-layer/create-mesh.js
var DEFAULT_INDICES = new Uint32Array([0, 2, 1, 0, 3, 2]);
var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex = 0;
  let index = 0;
  for (let u = 0; u < uCount; u++) {
    const ut2 = u / (uCount - 1);
    for (let v = 0; v < vCount; v++) {
      const vt2 = v / (vCount - 1);
      const p = interpolateQuad(bounds, ut2, vt2);
      positions[vertex * 3 + 0] = p[0];
      positions[vertex * 3 + 1] = p[1];
      positions[vertex * 3 + 2] = p[2] || 0;
      texCoords[vertex * 2 + 0] = ut2;
      texCoords[vertex * 2 + 1] = 1 - vt2;
      if (u > 0 && v > 0) {
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - vCount - 1;
        indices[index++] = vertex - 1;
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - 1;
        indices[index++] = vertex;
      }
      vertex++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  const positions = new Float64Array(12);
  for (let i = 0; i < bounds.length; i++) {
    positions[i * 3 + 0] = bounds[i][0];
    positions[i * 3 + 1] = bounds[i][1];
    positions[i * 3 + 2] = bounds[i][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut2, vt2) {
  return lerp(lerp(quad[0], quad[1], vt2), lerp(quad[3], quad[2], vt2), ut2);
}

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-uniforms.js
var uniformBlock2 = `uniform bitmapUniforms {
  vec4 bounds;
  float coordinateConversion;
  float desaturate;
  vec3 tintColor;
  vec4 transparentColor;
} bitmap;
`;
var bitmapUniforms = {
  name: "bitmap",
  vs: uniformBlock2,
  fs: uniformBlock2,
  uniformTypes: {
    bounds: "vec4<f32>",
    coordinateConversion: "f32",
    desaturate: "f32",
    tintColor: "vec3<f32>",
    transparentColor: "vec4<f32>"
  }
};

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-vertex.js
var bitmap_layer_vertex_default = `#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (bitmap.coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project.commonOrigin.xy;
  } else if (bitmap.coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-fragment.js
var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
var bitmap_layer_fragment_default = `#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), bitmap.desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * bitmap.tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (bitmap.transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + bitmap.transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(bitmap.transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bitmap.bounds[0]) / (bitmap.bounds[2] - bitmap.bounds[0]),
    (pos.y - bitmap.bounds[3]) / (bitmap.bounds[1] - bitmap.bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (bitmap.coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (bitmap.coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * layer.opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer.js
var defaultProps2 = {
  image: { type: "image", value: null, async: true },
  bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  desaturate: { type: "number", min: 0, max: 1, value: 0 },
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: { type: "color", value: [0, 0, 0, 0] },
  tintColor: { type: "color", value: [255, 255, 255] },
  textureParameters: { type: "object", ignore: true, value: null }
};
var BitmapLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: bitmap_layer_vertex_default, fs: bitmap_layer_fragment_default, modules: [project32_default, picking_default, bitmapUniforms] });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.remove(["instancePickingColors"]);
    const noAlloc = true;
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: (attribute) => attribute.value = this.state.mesh.indices,
        noAlloc
      },
      positions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        update: (attribute) => attribute.value = this.state.mesh.positions,
        noAlloc
      },
      texCoords: {
        size: 2,
        update: (attribute) => attribute.value = this.state.mesh.texCoords,
        noAlloc
      }
    });
  }
  updateState({ props, oldProps, changeFlags }) {
    const attributeManager = this.getAttributeManager();
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
    if (props.bounds !== oldProps.bounds) {
      const oldMesh = this.state.mesh;
      const mesh = this._createMesh();
      this.state.model.setVertexCount(mesh.vertexCount);
      for (const key in mesh) {
        if (oldMesh && oldMesh[key] !== mesh[key]) {
          attributeManager.invalidate(key);
        }
      }
      this.setState({ mesh, ...this._getCoordinateUniforms() });
    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
      this.setState(this._getCoordinateUniforms());
    }
  }
  getPickingInfo(params) {
    const { image } = this.props;
    const info = params.info;
    if (!info.color || !image) {
      info.bitmap = null;
      return info;
    }
    const { width, height } = image;
    info.index = 0;
    const uv = unpackUVsFromRGB(info.color);
    info.bitmap = {
      size: { width, height },
      uv,
      pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]
    };
    return info;
  }
  // Override base Layer multi-depth picking logic
  disablePickingIndex() {
    this.setState({ disablePicking: true });
  }
  restorePickingColors() {
    this.setState({ disablePicking: false });
  }
  _updateAutoHighlight(info) {
    super._updateAutoHighlight({
      ...info,
      color: this.encodePickingColor(0)
    });
  }
  _createMesh() {
    const { bounds } = this.props;
    let normalizedBounds = bounds;
    if (isRectangularBounds(bounds)) {
      normalizedBounds = [
        [bounds[0], bounds[1]],
        [bounds[0], bounds[3]],
        [bounds[2], bounds[3]],
        [bounds[2], bounds[1]]
      ];
    }
    return createMesh(normalizedBounds, this.context.viewport.resolution);
  }
  _getModel() {
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-list",
      isInstanced: false
    });
  }
  draw(opts) {
    const { shaderModuleProps } = opts;
    const { model, coordinateConversion, bounds, disablePicking } = this.state;
    const { image, desaturate, transparentColor, tintColor } = this.props;
    if (shaderModuleProps.picking.isActive && disablePicking) {
      return;
    }
    if (image && model) {
      const bitmapProps = {
        bitmapTexture: image,
        bounds,
        coordinateConversion,
        desaturate,
        tintColor: tintColor.slice(0, 3).map((x2) => x2 / 255),
        transparentColor: transparentColor.map((x2) => x2 / 255)
      };
      model.shaderInputs.setProps({ bitmap: bitmapProps });
      model.draw(this.context.renderPass);
    }
  }
  _getCoordinateUniforms() {
    const { LNGLAT, CARTESIAN, DEFAULT } = COORDINATE_SYSTEM;
    let { _imageCoordinateSystem: imageCoordinateSystem } = this.props;
    if (imageCoordinateSystem !== DEFAULT) {
      const { bounds } = this.props;
      if (!isRectangularBounds(bounds)) {
        throw new Error("_imageCoordinateSystem only supports rectangular bounds");
      }
      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
        return { coordinateConversion: -1, bounds };
      }
      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
        const topRight = lngLatToWorld([bounds[2], bounds[3]]);
        return {
          coordinateConversion: 1,
          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
        };
      }
    }
    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }
};
BitmapLayer.layerName = "BitmapLayer";
BitmapLayer.defaultProps = defaultProps2;
var bitmap_layer_default = BitmapLayer;
function unpackUVsFromRGB(color) {
  const [u, v, fracUV] = color;
  const vFrac = (fracUV & 240) / 256;
  const uFrac = (fracUV & 15) / 16;
  return [(u + uFrac) / 256, (v + vFrac) / 256];
}
function isRectangularBounds(bounds) {
  return Number.isFinite(bounds[0]);
}

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-uniforms.js
var uniformBlock3 = `uniform iconUniforms {
  float sizeScale;
  vec2 iconsTextureDim;
  float sizeMinPixels;
  float sizeMaxPixels;
  bool billboard;
  highp int sizeUnits;
  float alphaCutoff;
} icon;
`;
var iconUniforms = {
  name: "icon",
  vs: uniformBlock3,
  fs: uniformBlock3,
  uniformTypes: {
    sizeScale: "f32",
    iconsTextureDim: "vec2<f32>",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    billboard: "f32",
    sizeUnits: "i32",
    alphaCutoff: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * icon.sizeScale, icon.sizeUnits),
icon.sizeMinPixels, icon.sizeMaxPixels
);
float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (icon.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / icon.iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * layer.opacity * vColor.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-manager.js
var DEFAULT_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER = 4;
var noop = () => {
};
var DEFAULT_SAMPLER_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  // LINEAR is the default value but explicitly set it here
  magFilter: "linear",
  // minimize texture boundary artifacts
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
var MISSING_ICON = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return { image: imageData, width, height };
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return { image: ctx.canvas, width, height };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, sampler) {
  const { width: oldWidth, height: oldHeight, device } = texture;
  const newTexture = device.createTexture({
    format: "rgba8unorm",
    width,
    height,
    sampler,
    mipmaps: true
  });
  const commandEncoder = device.createCommandEncoder();
  commandEncoder.copyTextureToTexture({
    sourceTexture: texture,
    destinationTexture: newTexture,
    width: oldWidth,
    height: oldHeight
  });
  commandEncoder.finish();
  texture.destroy();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i = 0; i < columns.length; i++) {
    const { icon, xOffset } = columns[i];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({ icons, buffer, mapping = {}, xOffset = 0, yOffset = 0, rowHeight = 0, canvasWidth }) {
  let columns = [];
  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const { height, width } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const { iterable, objectInfo } = createIterable(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error("Icon is missing.");
    }
    if (!icon.url) {
      throw new Error("Icon url is missing.");
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index };
    }
  }
  return icons;
}
var IconManager = class {
  constructor(device, { onUpdate = noop, onError = noop }) {
    this._loadOptions = null;
    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};
    this._samplerParameters = null;
    this._pendingCount = 0;
    this._autoPacking = false;
    this._xOffset = 0;
    this._yOffset = 0;
    this._rowHeight = 0;
    this._buffer = DEFAULT_BUFFER;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
    this.device = device;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    this._texture?.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || MISSING_ICON;
  }
  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, textureParameters }) {
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== void 0) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      this._texture?.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._samplerParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data, getIcon) {
    if (!this._autoPacking || typeof document === "undefined") {
      return;
    }
    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = this.device.createTexture({
          format: "rgba8unorm",
          width: this._canvasWidth,
          height: this._canvasHeight,
          sampler: this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS,
          mipmaps: true
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._samplerParameters || DEFAULT_SAMPLER_PARAMETERS);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement("canvas");
      this._loadIcons(icons);
    }
  }
  _loadIcons(icons) {
    const ctx = this._canvas.getContext("2d", {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      load(icon.url, this._loadOptions).then((imageData) => {
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const { x: x2, y: y2, width: maxWidth, height: maxHeight } = iconDef;
        const { image, width, height } = resizeImage(ctx, imageData, maxWidth, maxHeight);
        this._texture?.copyExternalImage({
          image,
          x: x2 + (maxWidth - width) / 2,
          y: y2 + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        this._texture.generateMipmap();
        this.onUpdate();
      }).catch((error) => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer.js
var DEFAULT_COLOR2 = [0, 0, 0, 255];
var defaultProps3 = {
  iconAtlas: { type: "image", value: null, async: true },
  iconMapping: { type: "object", value: {}, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  billboard: true,
  sizeUnits: "pixels",
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getIcon: { type: "accessor", value: (x2) => x2.icon },
  getColor: { type: "accessor", value: DEFAULT_COLOR2 },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  onIconError: { type: "function", value: null, optional: true },
  textureParameters: { type: "object", ignore: true, value: null }
};
var IconLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: icon_layer_vertex_glsl_default, fs: icon_layer_fragment_glsl_default, modules: [project32_default, picking_default, iconUniforms] });
  }
  initializeState() {
    this.state = {
      iconManager: new IconManager(this.context.device, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: "uint8",
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR2
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      }
    });
  }
  /* eslint-disable max-statements, complexity */
  updateState(params) {
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
    const { iconManager } = this.state;
    if (typeof iconAtlas === "string") {
      return;
    }
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate("getIcon");
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  /* eslint-enable max-statements, complexity */
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({ uniforms }) {
    const { sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
    const { iconManager } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      const model = this.state.model;
      const iconProps = {
        iconsTexture,
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      };
      model.shaderInputs.setProps({ icon: iconProps });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          // The size must be explicitly passed here otherwise luma.gl
          // will default to assuming that positions are 3D (x,y,z)
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    const onIconError = this.getCurrentLayer()?.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      log_default.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const { width, height, anchorX = width / 2, anchorY = height / 2 } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const { x: x2, y: y2, width, height } = this.state.iconManager.getIconMapping(icon);
    return [x2, y2, width, height];
  }
};
IconLayer.defaultProps = defaultProps3;
IconLayer.layerName = "IconLayer";
var icon_layer_default = IconLayer;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-uniforms.js
var uniformBlockWGSL = (
  /* wgsl */
  `struct LineUniforms {
  widthScale: f32,
  widthMinPixels: f32,
  widthMaxPixels: f32,
  useShortestPath: f32,
  widthUnits: i32,
};

@group(0) @binding(1)
var<uniform> line: LineUniforms;
`
);
var uniformBlockGLSL = (
  /* glsl */
  `uniform lineUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float useShortestPath;
  highp int widthUnits;
} line;
`
);
var lineUniforms = {
  name: "line",
  source: uniformBlockWGSL,
  vs: uniformBlockGLSL,
  fs: uniformBlockGLSL,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    useShortestPath: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.wgsl.js
var shaderWGSL = (
  /* wgsl */
  `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)
struct LayerUniforms {
  opacity: f32,
};
var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// ---------- Helper Structures & Functions ----------

// Placeholder filter functions.
fn deckgl_filter_size(offset: vec3<f32>, geometry: Geometry) -> vec3<f32> {
  return offset;
}
fn deckgl_filter_gl_position(p: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return p;
}
fn deckgl_filter_color(color: vec4<f32>, geometry: Geometry) -> vec4<f32> {
  return color;
}

// Compute an extrusion offset given a line direction (in clipspace),
// an offset direction (-1 or 1), and a width in pixels.
// Assumes a uniform "project" with a viewportSize field is available.
fn getExtrusionOffset(line_clipspace: vec2<f32>, offset_direction: f32, width: f32) -> vec2<f32> {
  // project.viewportSize should be provided as a uniform (not shown here)
  let dir_screenspace = normalize(line_clipspace * project.viewportSize);
  // Rotate by 90: (x,y) becomes (-y,x)
  let rotated = vec2<f32>(-dir_screenspace.y, dir_screenspace.x);
  return rotated * offset_direction * width / 2.0;
}

// Splits the line between two points at a given x coordinate.
// Interpolates the y and z components.
fn splitLine(a: vec3<f32>, b: vec3<f32>, x: f32) -> vec3<f32> {
  let t: f32 = (x - a.x) / (b.x - a.x);
  return vec3<f32>(x, a.yz + t * (b.yz - a.yz));
}

// ---------- Uniforms & Global Structures ----------

// Uniforms for line, layer, and project are assumed to be defined elsewhere.
// For example:
//
// @group(0) @binding(0)
// var<uniform> line: LineUniform;
//
// struct LayerUniform {
//   opacity: f32,
// };
// @group(0) @binding(1)
// var<uniform> layer: LayerUniform;
//
// struct ProjectUniform {
//   viewportSize: vec2<f32>,
// };
// @group(0) @binding(2)
// var<uniform> project: ProjectUniform;



// ---------- Vertex Output Structure ----------

struct Varyings {
  @builtin(position) gl_Position: vec4<f32>,
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>,
};

// ---------- Vertex Shader Entry Point ----------

@vertex
fn vertexMain(
  @location(0) positions: vec3<f32>,
  @location(1) instanceSourcePositions: vec3<f32>,
  @location(2) instanceTargetPositions: vec3<f32>,
  @location(3) instanceSourcePositions64Low: vec3<f32>,
  @location(4) instanceTargetPositions64Low: vec3<f32>,
  @location(5) instanceColors: vec4<f32>,
  @location(6) instancePickingColors: vec3<f32>,
  @location(7) instanceWidths: f32
) -> Varyings {
  var geometry: Geometry;
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  var source_world: vec3<f32> = instanceSourcePositions;
  var target_world: vec3<f32> = instanceTargetPositions;
  var source_world_64low: vec3<f32> = instanceSourcePositions64Low;
  var target_world_64low: vec3<f32> = instanceTargetPositions64Low;

  // Apply shortest-path adjustments if needed.
  if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
    source_world.x = (source_world.x + 180.0 % 360.0) - 180.0;
    target_world.x = (target_world.x + 180.0 % 360.0) - 180.0;
    let deltaLng: f32 = target_world.x - source_world.x;

    if (deltaLng * line.useShortestPath > 180.0) {
      source_world.x = source_world.x + 360.0 * line.useShortestPath;
      source_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      source_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (deltaLng * line.useShortestPath < -180.0) {
      target_world.x = target_world.x + 360.0 * line.useShortestPath;
      target_world = splitLine(source_world, target_world, 180.0 * line.useShortestPath);
      target_world_64low = vec3<f32>(0.0, 0.0, 0.0);
    } else if (line.useShortestPath < 0.0) {
      var abortOut: Varyings;
      abortOut.gl_Position = vec4<f32>(0.0);
      abortOut.vColor = vec4<f32>(0.0);
      abortOut.uv = vec2<f32>(0.0);
      return abortOut;
    }
  }

  // Project Pos and target positions to clip space.
  let sourceResult = project_position_to_clipspace_and_commonspace(source_world, source_world_64low, vec3<f32>(0.0));
  let targetResult = project_position_to_clipspace_and_commonspace(target_world, target_world_64low, vec3<f32>(0.0));
  let sourcePos: vec4<f32> = sourceResult.clipPosition;
  let targetPos: vec4<f32> = targetResult.clipPosition;
  let source_commonspace: vec4<f32> = sourceResult.commonPosition;
  let target_commonspace: vec4<f32> = targetResult.commonPosition;

  // Interpolate along the line segment.
  let segmentIndex: f32 = positions.x;
  let p: vec4<f32> = sourcePos + segmentIndex * (targetPos - sourcePos);
  geometry.position = source_commonspace + segmentIndex * (target_commonspace - source_commonspace);
  let uv: vec2<f32> = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Determine width in pixels.
  let widthPixels: f32 = clamp(
    project_unit_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
    line.widthMinPixels, line.widthMaxPixels
  );

  // Compute extrusion offset.
  let extrusion: vec2<f32> = getExtrusionOffset(targetPos.xy - sourcePos.xy, positions.y, widthPixels);
  let offset: vec3<f32> = vec3<f32>(extrusion, 0.0);

  // Apply deck.gl filter functions.
  let filteredOffset = deckgl_filter_size(offset, geometry);
  let filteredP = deckgl_filter_gl_position(p, geometry);

  let clipOffset: vec2<f32> = project_pixel_size_to_clipspace(filteredOffset.xy);
  let finalPosition: vec4<f32> = filteredP + vec4<f32>(clipOffset, 0.0, 0.0);

  // Compute color.
  var vColor: vec4<f32> = vec4<f32>(instanceColors.rgb, instanceColors.a * layer.opacity);
  // vColor = deckgl_filter_color(vColor, geometry);

  var output: Varyings;
  output.gl_Position = finalPosition;
  output.vColor = vColor;
  output.uv = uv;
  return output;
}

@fragment
fn fragmentMain(
  @location(0) vColor: vec4<f32>,
  @location(1) uv: vec2<f32>
) -> @location(0) vec4<f32> {
  // Create and initialize geometry with the provided uv.
  var geometry: Geometry;
  geometry.uv = uv;

  // Start with the input color.
  var fragColor: vec4<f32> = vColor;

  // Apply the deck.gl filter to the color.
  fragColor = deckgl_filter_color(fragColor, geometry);

  return fragColor;
}
`
);

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-vertex.glsl.js
var line_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (line.useShortestPath > 0.5 || line.useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * line.useShortestPath > 180.) {
source_world.x += 360. * line.useShortestPath;
source_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * line.useShortestPath < -180.) {
target_world.x += 360. * line.useShortestPath;
target_world = splitLine(source_world, target_world, 180. * line.useShortestPath);
target_world_64low = vec3(0.0);
} else if (line.useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * line.widthScale, line.widthUnits),
line.widthMinPixels, line.widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-fragment.glsl.js
var line_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.js
var DEFAULT_COLOR3 = [0, 0, 0, 255];
var defaultProps4 = {
  getSourcePosition: { type: "accessor", value: (x2) => x2.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x2) => x2.targetPosition },
  getColor: { type: "accessor", value: DEFAULT_COLOR3 },
  getWidth: { type: "accessor", value: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var LineLayer = class extends layer_default {
  getBounds() {
    return this.getAttributeManager()?.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: line_layer_vertex_glsl_default, fs: line_layer_fragment_glsl_default, source: shaderWGSL, modules: [project32_default, picking_default, lineUniforms] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;
    const model = this.state.model;
    const lineProps = {
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude ? 1 : 0
    };
    model.shaderInputs.setProps({ line: lineProps });
    model.draw(this.context.renderPass);
    if (wrapLongitude) {
      model.shaderInputs.setProps({ line: { ...lineProps, useShortestPath: -1 } });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
LineLayer.layerName = "LineLayer";
LineLayer.defaultProps = defaultProps4;
var line_layer_default = LineLayer;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-uniforms.js
var uniformBlock4 = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`;
var pointCloudUniforms = {
  name: "pointCloud",
  vs: uniformBlock4,
  fs: uniformBlock4,
  uniformTypes: {
    radiusPixels: "f32",
    sizeUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-vertex.glsl.js
var point_cloud_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-fragment.glsl.js
var point_cloud_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer.js
var DEFAULT_COLOR4 = [0, 0, 0, 255];
var DEFAULT_NORMAL = [0, 0, 1];
var defaultProps5 = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getNormal: { type: "accessor", value: DEFAULT_NORMAL },
  getColor: { type: "accessor", value: DEFAULT_COLOR4 },
  material: true,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function normalizeData(data) {
  const { header, attributes } = data;
  if (!header || !attributes) {
    return;
  }
  data.length = header.vertexCount;
  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }
  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }
  if (attributes.COLOR_0) {
    const { size, value } = attributes.COLOR_0;
    attributes.instanceColors = { size, type: "unorm8", value };
  }
}
var PointCloudLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({
      vs: point_cloud_layer_vertex_glsl_default,
      fs: point_cloud_layer_fragment_glsl_default,
      modules: [project32_default, gouraudMaterial, picking_default, pointCloudUniforms]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: true,
        accessor: "getNormal",
        defaultValue: DEFAULT_NORMAL
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR4
      }
    });
  }
  updateState(params) {
    const { changeFlags, props } = params;
    super.updateState(params);
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
    if (changeFlags.dataChanged) {
      normalizeData(props.data);
    }
  }
  draw({ uniforms }) {
    const { pointSize, sizeUnits } = this.props;
    const model = this.state.model;
    const pointCloudProps = {
      sizeUnits: UNIT[sizeUnits],
      radiusPixels: pointSize
    };
    model.shaderInputs.setProps({ pointCloud: pointCloudProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [];
    for (let i = 0; i < 3; i++) {
      const angle = i / 3 * Math.PI * 2;
      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
    }
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }
};
PointCloudLayer.layerName = "PointCloudLayer";
PointCloudLayer.defaultProps = defaultProps5;

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-uniforms.js
var glslUniformBlock = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`;
var scatterplotUniforms = {
  name: "scatterplot",
  vs: glslUniformBlock,
  fs: glslUniformBlock,
  source: "",
  uniformTypes: {
    radiusScale: "f32",
    radiusMinPixels: "f32",
    radiusMaxPixels: "f32",
    lineWidthScale: "f32",
    lineWidthMinPixels: "f32",
    lineWidthMaxPixels: "f32",
    stroked: "f32",
    filled: "f32",
    antialiasing: "f32",
    billboard: "f32",
    radiusUnits: "i32",
    lineWidthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default = (
  /* glsl */
  `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.wgsl.js
var scatterplot_layer_wgsl_default = (
  /* wgsl */
  `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)

struct LayerUniforms {
  opacity: f32,
};

var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    // discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        // discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    // discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`
);

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR5 = [0, 0, 0, 255];
var defaultProps6 = {
  radiusUnits: "meters",
  radiusScale: { type: "number", min: 0, value: 1 },
  radiusMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  lineWidthUnits: "meters",
  lineWidthScale: { type: "number", min: 0, value: 1 },
  lineWidthMinPixels: { type: "number", min: 0, value: 0 },
  lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getRadius: { type: "accessor", value: 1 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineWidth: { type: "accessor", value: 1 },
  // deprecated
  strokeWidth: { deprecatedFor: "getLineWidth" },
  outline: { deprecatedFor: "stroked" },
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var ScatterplotLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({
      vs: scatterplot_layer_vertex_glsl_default,
      fs: scatterplot_layer_fragment_glsl_default,
      source: scatterplot_layer_wgsl_default,
      modules: [project32_default, picking_default, scatterplotUniforms]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;
    const scatterplotProps = {
      stroked,
      filled,
      billboard,
      antialiasing,
      radiusUnits: UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    };
    const model = this.state.model;
    model.shaderInputs.setProps({ scatterplot: scatterplotProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
ScatterplotLayer.defaultProps = defaultProps6;
ScatterplotLayer.layerName = "ScatterplotLayer";
var scatterplot_layer_default = ScatterplotLayer;

// node_modules/@math.gl/polygon/dist/polygon-utils.js
var WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
var DimIndex = {
  x: 0,
  y: 1,
  z: 2
};
function getPolygonSignedArea(points, options = {}) {
  const { start = 0, end = points.length, plane = "xy" } = options;
  const dim = options.size || 2;
  let area = 0;
  const i0 = DimIndex[plane[0]];
  const i1 = DimIndex[plane[1]];
  for (let i = start, j2 = end - dim; i < end; i += dim) {
    area += (points[i + i0] - points[j2 + i0]) * (points[i + i1] + points[j2 + i1]);
    j2 = i;
  }
  return area / 2;
}
function reversePolygon(points, options) {
  const { start = 0, end = points.length, size = 2 } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i = 0; i < numSwaps; ++i) {
    const b1 = start + i * size;
    const b2 = start + (numPoints - 1 - i) * size;
    for (let j2 = 0; j2 < size; ++j2) {
      const tmp = points[b1 + j2];
      points[b1 + j2] = points[b2 + j2];
      points[b2 + j2] = tmp;
    }
  }
}

// node_modules/@math.gl/polygon/dist/utils.js
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i = 0; i < size; i++) {
      if (target[startIndex - size + i] !== source[i]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i = 0; i < size; i++) {
    target[startIndex + i] = source[i];
  }
  return true;
}
function copy(target, source) {
  const size = source.length;
  for (let i = 0; i < size; i++) {
    target[i] = source[i];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i = 0; i < size; i++) {
    out[i] = positions[startI + i];
  }
  return out;
}

// node_modules/@math.gl/polygon/dist/lineclip.js
function intersect(a, b2, edge, bbox, out = []) {
  let t;
  let snap;
  if (edge & 8) {
    t = (bbox[3] - a[1]) / (b2[1] - a[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox[1] - a[1]) / (b2[1] - a[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox[2] - a[0]) / (b2[0] - a[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox[0] - a[0]) / (b2[0] - a[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i = 0; i < a.length; i++) {
    out[i] = (snap & 1) === i ? bbox[snap] : t * (b2[i] - a[i]) + a[i];
  }
  return out;
}
function bitCode(p, bbox) {
  let code = 0;
  if (p[0] < bbox[0])
    code |= 1;
  else if (p[0] > bbox[2])
    code |= 2;
  if (p[1] < bbox[1])
    code |= 4;
  else if (p[1] > bbox[3])
    code |= 8;
  return code;
}

// node_modules/@math.gl/polygon/dist/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
  const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a = getPointAtIndex(positions, 0, size, startIndex);
  let b2;
  let codeB;
  const cell = getGridCell(a, gridResolution, gridOffset, []);
  const scratchPoint = [];
  push(part, a);
  for (let i = 1; i < numPoints; i++) {
    b2 = getPointAtIndex(positions, i, size, startIndex, b2);
    codeB = bitCode(b2, cell);
    while (codeB) {
      intersect(a, b2, codeB, cell, scratchPoint);
      const codeAlt = bitCode(scratchPoint, cell);
      if (codeAlt) {
        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      push(part, scratchPoint);
      copy(a, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        push(part, a);
      }
      codeB = bitCode(b2, cell);
    }
    push(part, b2);
    copy(a, b2);
  }
  return broken ? result : result[0];
}
var TYPE_INSIDE = 0;
var TYPE_BORDER = 1;
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
  const result = [];
  const queue = [
    {
      pos: positions,
      types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
      holes: holeIndices || []
    }
  ];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const { pos, types, holes } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = { pos: parts[0].pos, types: parts[0].types, holes: [] };
      const polygonHigh = { pos: parts[1].pos, types: parts[1].types, holes: [] };
      queue.push(polygonLow, polygonHigh);
      for (let i = 0; i < holes.length; i++) {
        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = { positions: pos };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i = 0; i < numPoints; i++) {
    p = getPointAtIndex(positions, i, size, startIndex, p);
    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p, edge, bbox, scratchPoint);
      push(resultLow, scratchPoint) && typesLow.push(prevType);
      push(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy(prev, p);
    prevSide = side;
    prevType = type;
  }
  return [
    lowPointCount ? { pos: resultLow, types: edgeTypes && typesLow } : null,
    highPointCount ? { pos: resultHigh, types: edgeTypes && typesHigh } : null
  ];
}
function getGridCell(p, gridResolution, gridOffset, out) {
  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < endIndex; i += size) {
    const x2 = positions[i];
    const y2 = positions[i + 1];
    minX = x2 < minX ? x2 : minX;
    maxX = x2 > maxX ? x2 : maxX;
    minY = y2 < minY ? y2 : minY;
    maxY = y2 > maxY ? y2 : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
function concatInPlace(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr1.push(arr2[i]);
  }
  return arr1;
}

// node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js
var DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize2 = true } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const { size = 2, normalize: normalize2 = true, edgeTypes = false } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i = splitIndex; i < srcEndIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    for (let i = srcStartIndex; i < splitIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i = startIndex + 1; i < endIndex; i += size) {
    const lat = Math.abs(positions[i]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p = getPointAtIndex(positions, 0, size, startIndex);
    p[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p);
    p[1] = Math.sign(p[1]) * maxLatitude;
    push(positions, p);
    p[0] = firstLng;
    push(positions, p);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i = startIndex; i < endIndex; i += size) {
    lng = positions[i];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i = 0; i < pointCount; i++) {
    refLng = positions[i * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i = 0; i < pointCount; i++) {
    positions[i * size] += delta;
  }
}

// node_modules/@deck.gl/layers/dist/column-layer/column-geometry.js
var ColumnGeometry = class extends Geometry {
  constructor(props) {
    const { indices, attributes } = tesselateColumn(props);
    super({
      ...props,
      indices,
      // @ts-expect-error
      attributes
    });
  }
};
function tesselateColumn(props) {
  const { radius, height = 1, nradial = 10 } = props;
  let { vertices } = props;
  if (vertices) {
    log_default.assert(vertices.length >= nradial);
    vertices = vertices.flatMap((v) => [v[0], v[1]]);
    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
  }
  const isExtruded = height > 0;
  const vertsAroundEdge = nradial + 1;
  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
  const stepAngle = Math.PI * 2 / nradial;
  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  let i = 0;
  if (isExtruded) {
    for (let j2 = 0; j2 < vertsAroundEdge; j2++) {
      const a = j2 * stepAngle;
      const vertexIndex = j2 % nradial;
      const sin = Math.sin(a);
      const cos = Math.cos(a);
      for (let k2 = 0; k2 < 2; k2++) {
        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
        positions[i + 2] = (1 / 2 - k2) * height;
        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;
        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;
        i += 3;
      }
    }
    positions[i + 0] = positions[i - 3];
    positions[i + 1] = positions[i - 2];
    positions[i + 2] = positions[i - 1];
    i += 3;
  }
  for (let j2 = isExtruded ? 0 : 1; j2 < vertsAroundEdge; j2++) {
    const v = Math.floor(j2 / 2) * Math.sign(0.5 - j2 % 2);
    const a = v * stepAngle;
    const vertexIndex = (v + nradial) % nradial;
    const sin = Math.sin(a);
    const cos = Math.cos(a);
    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
    positions[i + 2] = height / 2;
    normals[i + 2] = 1;
    i += 3;
  }
  if (isExtruded) {
    let index = 0;
    for (let j2 = 0; j2 < nradial; j2++) {
      indices[index++] = j2 * 2 + 0;
      indices[index++] = j2 * 2 + 2;
      indices[index++] = j2 * 2 + 0;
      indices[index++] = j2 * 2 + 1;
      indices[index++] = j2 * 2 + 1;
      indices[index++] = j2 * 2 + 3;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: { size: 3, value: positions },
      NORMAL: { size: 3, value: normals }
    }
  };
}

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-uniforms.js
var uniformBlock5 = `uniform columnUniforms {
  float radius;
  float angle;
  vec2 offset;
  bool extruded;
  bool stroked;
  bool isStroke;
  float coverage;
  float elevationScale;
  float edgeDistance;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int radiusUnits;
  highp int widthUnits;
} column;
`;
var columnUniforms = {
  name: "column",
  vs: uniformBlock5,
  fs: uniformBlock5,
  uniformTypes: {
    radius: "f32",
    angle: "f32",
    offset: "vec2<f32>",
    extruded: "f32",
    stroked: "f32",
    isStroke: "f32",
    coverage: "f32",
    elevationScale: "f32",
    edgeDistance: "f32",
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    radiusUnits: "i32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-vertex.glsl.js
var column_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec3 cameraPosition;
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (column.extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
} else if (column.stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),
column.widthMinPixels, column.widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);
if (column.isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = column.radius * column.coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;
if (column.radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
cameraPosition = project.cameraPosition;
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * layer.opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * layer.opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-fragment.glsl.js
var column_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec3 cameraPosition;
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
if (column.extruded && !column.isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/column-layer/column-layer.js
var DEFAULT_COLOR6 = [0, 0, 0, 255];
var defaultProps7 = {
  diskResolution: { type: "number", min: 4, value: 20 },
  vertices: null,
  radius: { type: "number", min: 0, value: 1e3 },
  angle: { type: "number", value: 0 },
  offset: { type: "array", value: [0, 0] },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  elevationScale: { type: "number", min: 0, value: 1 },
  radiusUnits: "meters",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: true,
  wireframe: false,
  filled: true,
  stroked: false,
  flatShading: false,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getLineWidth: { type: "accessor", value: 1 },
  getElevation: { type: "accessor", value: 1e3 },
  material: true,
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var ColumnLayer = class extends layer_default {
  getShaders() {
    const defines = {};
    const { flatShading } = this.props;
    if (flatShading) {
      defines.FLAT_SHADING = 1;
    }
    return super.getShaders({
      vs: column_layer_vertex_glsl_default,
      fs: column_layer_fragment_glsl_default,
      defines,
      modules: [project32_default, flatShading ? phongMaterial : gouraudMaterial, picking_default, columnUniforms]
    });
  }
  /**
   * DeckGL calls initializeState when GL context is available
   * Essentially a deferred constructor
   */
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: "getElevation"
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR6
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR6
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getLineWidth",
        transition: true
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
    if (regenerateModels) {
      this.state.models?.forEach((model) => model.destroy());
      this.setState(this._getModels());
      this.getAttributeManager().invalidateAll();
    }
    const instanceCount = this.getNumInstances();
    this.state.fillModel.setInstanceCount(instanceCount);
    this.state.wireframeModel.setInstanceCount(instanceCount);
    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
      this._updateGeometry(props);
    }
  }
  getGeometry(diskResolution, vertices, hasThinkness) {
    const geometry = new ColumnGeometry({
      radius: 1,
      height: hasThinkness ? 2 : 0,
      vertices,
      nradial: diskResolution
    });
    let meanVertexDistance = 0;
    if (vertices) {
      for (let i = 0; i < diskResolution; i++) {
        const p = vertices[i];
        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
        meanVertexDistance += d / diskResolution;
      }
    } else {
      meanVertexDistance = 1;
    }
    this.setState({
      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
    });
    return geometry;
  }
  _getModels() {
    const shaders = this.getShaders();
    const bufferLayout = this.getAttributeManager().getBufferLayouts();
    const fillModel = new Model(this.context.device, {
      ...shaders,
      id: `${this.props.id}-fill`,
      bufferLayout,
      isInstanced: true
    });
    const wireframeModel = new Model(this.context.device, {
      ...shaders,
      id: `${this.props.id}-wireframe`,
      bufferLayout,
      isInstanced: true
    });
    return {
      fillModel,
      wireframeModel,
      models: [wireframeModel, fillModel]
    };
  }
  _updateGeometry({ diskResolution, vertices, extruded, stroked }) {
    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
    this.setState({
      fillVertexCount: geometry.attributes.POSITION.value.length / 3
    });
    const fillModel = this.state.fillModel;
    const wireframeModel = this.state.wireframeModel;
    fillModel.setGeometry(geometry);
    fillModel.setTopology("triangle-strip");
    fillModel.setIndexBuffer(null);
    wireframeModel.setGeometry(geometry);
    wireframeModel.setTopology("line-list");
  }
  draw({ uniforms }) {
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, radiusUnits, elevationScale, extruded, filled, stroked, wireframe, offset, coverage, radius, angle } = this.props;
    const fillModel = this.state.fillModel;
    const wireframeModel = this.state.wireframeModel;
    const { fillVertexCount, edgeDistance } = this.state;
    const columnProps = {
      radius,
      angle: angle / 180 * Math.PI,
      offset,
      extruded,
      stroked,
      coverage,
      elevationScale,
      edgeDistance,
      radiusUnits: UNIT[radiusUnits],
      widthUnits: UNIT[lineWidthUnits],
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels
    };
    if (extruded && wireframe) {
      wireframeModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: true
        }
      });
      wireframeModel.draw(this.context.renderPass);
    }
    if (filled) {
      fillModel.setVertexCount(fillVertexCount);
      fillModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: false
        }
      });
      fillModel.draw(this.context.renderPass);
    }
    if (!extruded && stroked) {
      fillModel.setVertexCount(fillVertexCount * 2 / 3);
      fillModel.shaderInputs.setProps({
        column: {
          ...columnProps,
          isStroke: true
        }
      });
      fillModel.draw(this.context.renderPass);
    }
  }
};
ColumnLayer.layerName = "ColumnLayer";
ColumnLayer.defaultProps = defaultProps7;
var column_layer_default = ColumnLayer;

// node_modules/@deck.gl/layers/dist/column-layer/grid-cell-layer.js
var defaultProps8 = {
  cellSize: { type: "number", min: 0, value: 1e3 },
  offset: { type: "array", value: [1, 1] }
};
var GridCellLayer = class extends column_layer_default {
  _updateGeometry() {
    const geometry = new CubeGeometry();
    this.state.fillModel.setGeometry(geometry);
  }
  draw({ uniforms }) {
    const { elevationScale, extruded, offset, coverage, cellSize, angle, radiusUnits } = this.props;
    const fillModel = this.state.fillModel;
    const columnProps = {
      radius: cellSize / 2,
      radiusUnits: UNIT[radiusUnits],
      angle,
      offset,
      extruded,
      stroked: false,
      coverage,
      elevationScale,
      edgeDistance: 1,
      isStroke: false,
      widthUnits: 0,
      widthScale: 0,
      widthMinPixels: 0,
      widthMaxPixels: 0
    };
    fillModel.shaderInputs.setProps({ column: columnProps });
    fillModel.draw(this.context.renderPass);
  }
};
GridCellLayer.layerName = "GridCellLayer";
GridCellLayer.defaultProps = defaultProps8;

// node_modules/@deck.gl/layers/dist/path-layer/path.js
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length = path.length * size;
    flatPath = new Array(length);
    for (let i = 0; i < path.length; i++) {
      for (let j2 = 0; j2 < size; j2++) {
        flatPath[i * size + j2] = path[i][j2] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, { size, gridResolution });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, { size });
  }
  return flatPath;
}

// node_modules/@deck.gl/layers/dist/path-layer/path-tesselator.js
var START_CAP = 1;
var END_CAP = 2;
var INVALID = 4;
var PathTesselator = class extends Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        // Padding covers shaderAttributes for last segment in largest case fp64
        // additional vertex + hi & low parts, 3 * 6
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: { size: 1, type: Uint8ClampedArray }
      }
    });
  }
  /** Get packed attribute by name */
  get(attributeName) {
    return this.attributes[attributeName];
  }
  /* Implement base Tesselator interface */
  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /* Implement base Tesselator interface */
  normalizeGeometry(path) {
    if (this.normalize) {
      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  /* Implement base Tesselator interface */
  getGeometrySize(path) {
    if (isCut(path)) {
      let size = 0;
      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }
      return size;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  /* Implement base Tesselator interface */
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const { vertexStart, geometrySize } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }
  _updatePositions(path, context) {
    const { positions } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const { vertexStart, geometrySize } = context;
    const p = new Array(3);
    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p);
      positions[i * 3] = p[0];
      positions[i * 3 + 1] = p[1];
      positions[i * 3 + 2] = p[2];
    }
  }
  // Utilities
  /** Returns the number of points in the path */
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  /** Returns a point on the path at the specified index */
  getPointOnPath(path, index, target = []) {
    const { positionSize } = this;
    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }
    const i = index * positionSize;
    target[0] = path[i];
    target[1] = path[i + 1];
    target[2] = positionSize === 3 && path[i + 2] || 0;
    return target;
  }
  // Returns true if the first and last points are identical
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const { positionSize } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
};
function isCut(path) {
  return Array.isArray(path[0]);
}

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-uniforms.js
var uniformBlock6 = `uniform pathUniforms {
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  float jointType;
  float capType;
  float miterLimit;
  bool billboard;
  highp int widthUnits;
} path;
`;
var pathUniforms = {
  name: "path",
  vs: uniformBlock6,
  fs: uniformBlock6,
  uniformTypes: {
    widthScale: "f32",
    widthMinPixels: "f32",
    widthMaxPixels: "f32",
    jointType: "f32",
    capType: "f32",
    miterLimit: "f32",
    billboard: "f32",
    widthUnits: "i32"
  }
};

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !path.billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * path.capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = path.capType;
} else {
vJointType = path.jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * layer.opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * path.widthScale, path.widthUnits),
path.widthMinPixels, path.widthMaxPixels) / 2.0);
vec3 width;
if (path.billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > path.miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer.js
var DEFAULT_COLOR7 = [0, 0, 0, 255];
var defaultProps9 = {
  widthUnits: "meters",
  widthScale: { type: "number", min: 0, value: 1 },
  widthMinPixels: { type: "number", min: 0, value: 0 },
  widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  jointRounded: false,
  capRounded: false,
  miterLimit: { type: "number", min: 0, value: 4 },
  billboard: false,
  _pathType: null,
  getPath: { type: "accessor", value: (object) => object.path },
  getColor: { type: "accessor", value: DEFAULT_COLOR7 },
  getWidth: { type: "accessor", value: 1 },
  // deprecated props
  rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
};
var ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var PathLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: path_layer_vertex_glsl_default, fs: path_layer_fragment_glsl_default, modules: [project32_default, picking_default, pathUniforms] });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    return this.getAttributeManager()?.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      vertexPositions: {
        size: 3,
        // Start filling buffer from 1 vertex in
        vertexOffset: 1,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getPath",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: "uint8",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getWidth",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        accessor: "getColor",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR7
      },
      instancePickingColors: {
        size: 4,
        type: "uint8",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new PathTesselator({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const { pathTesselator } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === "loop",
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d) => d.__source.index === index);
    }
    return info;
  }
  /** Override base Layer method */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { jointRounded, capRounded, billboard, miterLimit, widthUnits, widthScale, widthMinPixels, widthMaxPixels } = this.props;
    const model = this.state.model;
    const pathProps = {
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    };
    model.shaderInputs.setProps({ path: pathProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const SEGMENT_INDICES = [
      // start corner
      0,
      1,
      2,
      // body
      1,
      4,
      2,
      1,
      3,
      4,
      // end corner
      3,
      5,
      4
    ];
    const SEGMENT_POSITIONS = [
      // bevel start corner
      0,
      0,
      // start inner corner
      0,
      -1,
      // start outer corner
      0,
      1,
      // end inner corner
      1,
      -1,
      // end outer corner
      1,
      1,
      // bevel end corner
      1,
      0
    ];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: { value: new Float32Array(SEGMENT_POSITIONS), size: 2 }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("positions");
  }
  calculateSegmentTypes(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("segmentTypes");
  }
};
PathLayer.defaultProps = defaultProps9;
PathLayer.layerName = "PathLayer";
var path_layer_default = PathLayer;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon.js
var import_earcut2 = __toESM(require_earcut(), 1);
var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
var windingOptions = {
  isClosed: true
};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function getPositions(polygon) {
  return "positions" in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return "holeIndices" in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;
  for (let i = 0; i < len; i++) {
    for (let j2 = 0; j2 < size; j2++) {
      target[targetIndex++] = simplePolygon[i][j2] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j2 = 0; j2 < size; j2++) {
      target[targetIndex++] = simplePolygon[0][j2] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ("positions" in polygon) {
    const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return { positions, holeIndices };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return { positions, holeIndices };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area = 0;
  for (let i = 0; i < numVerts; i++) {
    const j2 = (i + 1) % numVerts;
    area += positions[i * 3 + xIndex] * positions[j2 * 3 + yIndex];
    area -= positions[j2 * 3 + xIndex] * positions[i * 3 + yIndex];
  }
  return Math.abs(area / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i = 0; i < numVerts; i++) {
    const o = i * 3;
    const x2 = positions[o + 0];
    const y2 = positions[o + 1];
    const z2 = positions[o + 2];
    positions[o + xIndex] = x2;
    positions[o + yIndex] = y2;
    positions[o + zIndex] = z2;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n = positions.length;
    positions = positions.slice();
    const p = [];
    for (let i = 0; i < n; i += positionSize) {
      p[0] = positions[i];
      p[1] = positions[i + 1];
      if (is3d) {
        p[2] = positions[i + 2];
      }
      const xy = preproject(p);
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
      if (is3d) {
        positions[i + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {
    } else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 2, 0, 1);
    }
  }
  return (0, import_earcut2.default)(positions, holeIndices, positionSize);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon-tesselator.js
var PolygonTesselator = class extends Tesselator {
  constructor(opts) {
    const { fp64, IndexType = Uint32Array } = opts;
    super({
      ...opts,
      attributes: {
        positions: { size: 3, type: fp64 ? Float64Array : Float32Array },
        vertexValid: { type: Uint16Array, size: 1 },
        indices: { type: IndexType, size: 1 }
      }
    });
  }
  /** Get attribute by name */
  get(attributeName) {
    const { attributes } = this;
    if (attributeName === "indices") {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  /** Override base Tesselator method */
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error("missing indices buffer");
    }
  }
  /** Implement base Tesselator interface */
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = normalize(polygon, this.positionSize);
      if (this.opts.resolution) {
        return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  /** Implement base Tesselator interface */
  getGeometrySize(polygon) {
    if (isCut2(polygon)) {
      let size = 0;
      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }
      return size;
    }
    return getPositions(polygon).length / this.positionSize;
  }
  /** Override base Tesselator method */
  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /** Implement base Tesselator interface */
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut2(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      const normalizedPolygon = polygon;
      this._updateIndices(normalizedPolygon, context);
      this._updatePositions(normalizedPolygon, context);
      this._updateVertexValid(normalizedPolygon, context);
    }
  }
  // Flatten the indices array
  _updateIndices(polygon, { geometryIndex, vertexStart: offset, indexStart }) {
    const { attributes, indexStarts, typedArrayManager } = this;
    let target = attributes.indices;
    if (!target || !polygon) {
      return;
    }
    let i = indexStart;
    const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });
    for (let j2 = 0; j2 < indices.length; j2++) {
      target[i++] = indices[j2] + offset;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }
  // Flatten out all the vertices of all the sub subPolygons
  _updatePositions(polygon, { vertexStart, geometrySize }) {
    const { attributes: { positions }, positionSize } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = getPositions(polygon);
    for (let i = vertexStart, j2 = 0; j2 < geometrySize; i++, j2++) {
      const x2 = polygonPositions[j2 * positionSize];
      const y2 = polygonPositions[j2 * positionSize + 1];
      const z2 = positionSize > 2 ? polygonPositions[j2 * positionSize + 2] : 0;
      positions[i * 3] = x2;
      positions[i * 3 + 1] = y2;
      positions[i * 3 + 2] = z2;
    }
  }
  _updateVertexValid(polygon, { vertexStart, geometrySize }) {
    const { positionSize } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j2 = 0; j2 < holeIndices.length; j2++) {
        vertexValid[vertexStart + holeIndices[j2] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
};
function isCut2(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-uniforms.js
var uniformBlock7 = `uniform solidPolygonUniforms {
  bool extruded;
  bool isWireframe;
  float elevationScale;
} solidPolygon;
`;
var solidPolygonUniforms = {
  name: "solidPolygon",
  vs: uniformBlock7,
  fs: uniformBlock7,
  uniformTypes: {
    extruded: "f32",
    isWireframe: "f32",
    elevationScale: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default = `in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
out vec4 vColor;
struct PolygonProps {
vec3 positions;
vec3 positions64Low;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project.commonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = solidPolygon.isWireframe ? lineColors : fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = pickingColors;
if (solidPolygon.extruded) {
pos.z += props.elevations * solidPolygon.elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (solidPolygon.extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * layer.opacity);
} else {
vColor = vec4(colors.rgb, colors.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 vertexPositions;
in vec3 nextVertexPositions;
in vec3 vertexPositions64Low;
in vec3 nextVertexPositions64Low;
in float elevations;
in float instanceVertexValid;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = vertexPositions;
pos64Low = vertexPositions64Low;
nextPos = nextVertexPositions;
nextPos64Low = nextVertexPositions64Low;
#else
pos = nextVertexPositions;
pos64Low = nextVertexPositions64Low;
nextPos = vertexPositions;
nextPos64Low = vertexPositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = elevations * positions.y;
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR8 = [0, 0, 0, 255];
var defaultProps10 = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  _full3d: false,
  elevationScale: { type: "number", min: 0, value: 1 },
  getPolygon: { type: "accessor", value: (f) => f.polygon },
  getElevation: { type: "accessor", value: 1e3 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR8 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR8 },
  material: true
};
var ATTRIBUTE_TRANSITION2 = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var SolidPolygonLayer = class extends layer_default {
  getShaders(type) {
    return super.getShaders({
      vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
      fs: solid_polygon_layer_fragment_glsl_default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
      },
      modules: [project32_default, gouraudMaterial, picking_default, solidPolygonUniforms]
    });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    return this.getAttributeManager()?.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const { viewport } = this.context;
    let { coordinateSystem } = this.props;
    const { _full3d } = this.props;
    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new PolygonTesselator({
        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results
        // Provide a preproject function if the coordinates are in lnglat
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: Uint32Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(["instancePickingColors"]);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateIndices,
        noAlloc
      },
      vertexPositions: {
        size: 3,
        type: "float64",
        stepMode: "dynamic",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getPolygon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          nextVertexPositions: {
            vertexOffset: 1
          }
        }
      },
      instanceVertexValid: {
        size: 1,
        type: "uint16",
        stepMode: "instance",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getElevation"
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR8
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        stepMode: "dynamic",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR8
      },
      pickingColors: {
        size: 4,
        type: "uint8",
        stepMode: "dynamic",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d) => d.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { extruded, filled, wireframe, elevationScale } = this.props;
    const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
    const renderUniforms = {
      extruded: Boolean(extruded),
      elevationScale,
      isWireframe: false
    };
    if (wireframeModel && wireframe) {
      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      wireframeModel.shaderInputs.setProps({ solidPolygon: { ...renderUniforms, isWireframe: true } });
      wireframeModel.draw(this.context.renderPass);
    }
    if (sideModel && filled) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
      sideModel.draw(this.context.renderPass);
    }
    if (topModel && filled) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.shaderInputs.setProps({ solidPolygon: renderUniforms });
      topModel.draw(this.context.renderPass);
    }
  }
  updateState(updateParams) {
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const { props, oldProps, changeFlags } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      this.state.models?.forEach((model) => model.destroy());
      this.setState(this._getModels());
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({ props, oldProps, changeFlags }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const { polygonTesselator } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels() {
    const { id, filled, extruded } = this.props;
    let topModel;
    let sideModel;
    let wireframeModel;
    if (filled) {
      const shaders = this.getShaders("top");
      shaders.defines.NON_INSTANCED_MODEL = 1;
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: false });
      topModel = new Model(this.context.device, {
        ...shaders,
        id: `${id}-top`,
        topology: "triangle-list",
        bufferLayout,
        isIndexed: true,
        userData: {
          excludeAttributes: { instanceVertexValid: true }
        }
      });
    }
    if (extruded) {
      const bufferLayout = this.getAttributeManager().getBufferLayouts({ isInstanced: true });
      sideModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-side`,
        bufferLayout,
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            // top right - top left - bottom right - bottom left
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
      wireframeModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-wireframe`,
        bufferLayout,
        geometry: new Geometry({
          topology: "line-strip",
          attributes: {
            // top right - top left - bottom left - bottom right
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        isInstanced: true,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
    }
    return {
      models: [sideModel, wireframeModel, topModel].filter(Boolean),
      topModel,
      sideModel,
      wireframeModel
    };
  }
  calculateIndices(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get("indices");
  }
  calculatePositions(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get("positions");
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get("vertexValid");
  }
};
SolidPolygonLayer.defaultProps = defaultProps10;
SolidPolygonLayer.layerName = "SolidPolygonLayer";
var solid_polygon_layer_default = SolidPolygonLayer;

// node_modules/@deck.gl/layers/dist/utils.js
function replaceInRange({ data, getIndex, dataRange, replace }) {
  const { startRow = 0, endRow = Infinity } = dataRange;
  const count = data.length;
  let replaceStart = count;
  let replaceEnd = count;
  for (let i = 0; i < count; i++) {
    const row = getIndex(data[i]);
    if (replaceStart > i && row >= startRow) {
      replaceStart = i;
    }
    if (row >= endRow) {
      replaceEnd = i;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
  for (let i = 0; i < replace.length; i++) {
    data[index++] = replace[i];
  }
  if (endChunk) {
    for (let i = 0; i < endChunk.length; i++) {
      data[index++] = endChunk[i];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}

// node_modules/@deck.gl/layers/dist/polygon-layer/polygon-layer.js
var defaultLineColor = [0, 0, 0, 255];
var defaultFillColor = [0, 0, 0, 255];
var defaultProps11 = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: { type: "accessor", value: (f) => f.polygon },
  // Polygon fill color
  getFillColor: { type: "accessor", value: defaultFillColor },
  // Point, line and polygon outline color
  getLineColor: { type: "accessor", value: defaultLineColor },
  // Line and polygon outline accessors
  getLineWidth: { type: "accessor", value: 1 },
  // Polygon extrusion accessor
  getElevation: { type: "accessor", value: 1e3 },
  // Optional material for 'lighting' shader module
  material: true
};
var PolygonLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      paths: [],
      pathsDiff: null
    };
    if (this.props.getLineDashArray) {
      log_default.removed("getLineDashArray", "PathStyleExtension")();
    }
  }
  updateState({ changeFlags }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
        data: paths,
        getIndex: (p) => p.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({ paths, pathsDiff });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }
  _getPaths(dataRange = {}) {
    const { data, getPolygon, positionFormat, _normalize } = this.props;
    const paths = [];
    const positionSize = positionFormat === "XY" ? 2 : 3;
    const { startRow, endRow } = dataRange;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object, objectInfo);
      if (_normalize) {
        polygon = normalize(polygon, positionSize);
      }
      const { holeIndices } = polygon;
      const positions = polygon.positions || polygon;
      if (holeIndices) {
        for (let i = 0; i <= holeIndices.length; i++) {
          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);
          paths.push(this.getSubLayerRow({ path }, object, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({ path: positions }, object, objectInfo.index));
      }
    }
    return paths;
  }
  /* eslint-disable complexity */
  renderLayers() {
    const { data, _dataDiff, stroked, filled, extruded, wireframe, _normalize, _windingOrder, elevationScale, transitions, positionFormat } = this.props;
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified } = this.props;
    const { getFillColor, getLineColor, getLineWidth, getLineDashArray, getElevation, getPolygon, updateTriggers, material } = this.props;
    const { paths, pathsDiff } = this.state;
    const FillLayer = this.getSubLayerClass("fill", solid_polygon_layer_default);
    const StrokeLayer = this.getSubLayerClass("stroke", path_layer_default);
    const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: "fill",
      updateTriggers: updateTriggers && {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        // using a legacy API to invalid lineColor attributes
        // if (extruded && wireframe) has changed
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      // Already normalized
      _pathType: "loop",
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: "stroke",
      updateTriggers: updateTriggers && {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: (x2) => x2.path
    });
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonLayer,
      polygonLineLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonLayer
    ];
  }
};
PolygonLayer.layerName = "PolygonLayer";
PolygonLayer.defaultProps = defaultProps11;

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-binary.js
function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }
  const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: { ...data.properties[propertiesIndex] }
  };
  for (const prop in data.numericProps) {
    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 4);
    const pickingColor = [];
    for (let i = 0; i < featureIds.length; i++) {
      encodePickingColor(featureIds[i], pickingColor);
      pickingColors[key][i * 4 + 0] = pickingColor[0];
      pickingColors[key][i * 4 + 1] = pickingColor[1];
      pickingColors[key][i * 4 + 2] = pickingColor[2];
      pickingColors[key][i * 4 + 3] = 255;
    }
  }
  return pickingColors;
}

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/sdf-uniforms.js
var uniformBlock8 = `uniform sdfUniforms {
  float gamma;
  bool enabled;
  float buffer;
  float outlineBuffer;
  vec4 outlineColor;
} sdf;
`;
var sdfUniforms = {
  name: "sdf",
  vs: uniformBlock8,
  fs: uniformBlock8,
  uniformTypes: {
    gamma: "f32",
    enabled: "f32",
    buffer: "f32",
    outlineBuffer: "f32",
    outlineColor: "vec4<f32>"
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform sampler2D iconsTexture;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf.enabled) {
float distance = alpha;
alpha = smoothstep(sdf.buffer - sdf.gamma, sdf.buffer + sdf.gamma, distance);
if (sdf.outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(sdf.outlineBuffer - sdf.gamma, sdf.outlineBuffer + sdf.gamma, distance);
color = mix(sdf.outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < icon.alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * layer.opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_BUFFER2 = 192 / 256;
var EMPTY_ARRAY = [];
var defaultProps12 = {
  getIconOffsets: { type: "accessor", value: (x2) => x2.offsets },
  alphaCutoff: 1e-3,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: { type: "color", value: [0, 0, 0, 255] }
};
var MultiIconLayer = class extends icon_layer_default {
  getShaders() {
    const shaders = super.getShaders();
    return { ...shaders, modules: [...shaders.modules, sdfUniforms], fs: multi_icon_layer_fragment_glsl_default };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: "getIconOffsets"
      },
      instancePickingColors: {
        type: "uint8",
        size: 3,
        accessor: (object, { index, target: value }) => this.encodePickingColor(index, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    let { outlineColor } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map((x2) => x2 / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
    }
  }
  draw(params) {
    const { sdf, smoothing, outlineWidth } = this.props;
    const { outlineColor } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
    const model = this.state.model;
    const sdfProps = {
      buffer: DEFAULT_BUFFER2,
      outlineBuffer,
      gamma: smoothing,
      enabled: Boolean(sdf),
      outlineColor
    };
    model.shaderInputs.setProps({ sdf: sdfProps });
    super.draw(params);
    if (sdf && outlineWidth) {
      const { iconManager } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        model.shaderInputs.setProps({ sdf: { ...sdfProps, outlineBuffer: DEFAULT_BUFFER2 } });
        model.draw(this.context.renderPass);
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
  }
};
MultiIconLayer.defaultProps = defaultProps12;
MultiIconLayer.layerName = "MultiIconLayer";
var multi_icon_layer_default = MultiIconLayer;

// node_modules/@mapbox/tiny-sdf/index.js
var INF = 1e20;
var TinySDF = class {
  constructor({
    fontSize = 24,
    buffer = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = "sans-serif",
    fontWeight = "normal",
    fontStyle = "normal",
    lang = null
  } = {}) {
    this.buffer = buffer;
    this.cutoff = cutoff;
    this.radius = radius;
    this.lang = lang;
    const size = this.size = fontSize + buffer * 4;
    const canvas = this._createCanvas(size);
    const ctx = this.ctx = canvas.getContext("2d", { willReadFrequently: true });
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = "left";
    ctx.fillStyle = "black";
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Uint16Array(size);
  }
  _createCanvas(size) {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    return canvas;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len = Math.max(width * height, 0);
    const data = new Uint8ClampedArray(len);
    const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
    if (glyphWidth === 0 || glyphHeight === 0) return glyph;
    const { ctx, buffer, gridInner, gridOuter } = this;
    if (this.lang) ctx.lang = this.lang;
    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
    ctx.fillText(char, buffer, buffer + glyphTop);
    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
    gridOuter.fill(INF, 0, len);
    gridInner.fill(0, 0, len);
    for (let y2 = 0; y2 < glyphHeight; y2++) {
      for (let x2 = 0; x2 < glyphWidth; x2++) {
        const a = imgData.data[4 * (y2 * glyphWidth + x2) + 3] / 255;
        if (a === 0) continue;
        const j2 = (y2 + buffer) * width + x2 + buffer;
        if (a === 1) {
          gridOuter[j2] = 0;
          gridInner[j2] = INF;
        } else {
          const d = 0.5 - a;
          gridOuter[j2] = d > 0 ? d * d : 0;
          gridInner[j2] = d < 0 ? d * d : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i = 0; i < len; i++) {
      const d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
      data[i] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
    }
    return glyph;
  }
};
function edt(data, x0, y0, width, height, gridSize, f, v, z2) {
  for (let x2 = x0; x2 < x0 + width; x2++) edt1d(data, y0 * gridSize + x2, gridSize, height, f, v, z2);
  for (let y2 = y0; y2 < y0 + height; y2++) edt1d(data, y2 * gridSize + x0, 1, width, f, v, z2);
}
function edt1d(grid, offset, stride, length, f, v, z2) {
  v[0] = 0;
  z2[0] = -INF;
  z2[1] = INF;
  f[0] = grid[offset];
  for (let q2 = 1, k2 = 0, s = 0; q2 < length; q2++) {
    f[q2] = grid[offset + q2 * stride];
    const q22 = q2 * q2;
    do {
      const r = v[k2];
      s = (f[q2] - f[r] + q22 - r * r) / (q2 - r) / 2;
    } while (s <= z2[k2] && --k2 > -1);
    k2++;
    v[k2] = q2;
    z2[k2] = s;
    z2[k2 + 1] = INF;
  }
  for (let q2 = 0, k2 = 0; q2 < length; q2++) {
    while (z2[k2 + 1] < q2) k2++;
    const r = v[k2];
    const qr = q2 - r;
    grid[offset + q2 * stride] = f[r] + qr * qr;
  }
}

// node_modules/@deck.gl/layers/dist/text-layer/utils.js
var MISSING_CHAR_WIDTH = 32;
var SINGLE_LINE = [];
function nextPowOfTwo2(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping2({ characterSet, getFontWidth, fontHeight, buffer, maxCanvasWidth, mapping = {}, xOffset = 0, yOffset = 0 }) {
  let row = 0;
  let x2 = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x2 + width + buffer * 2 > maxCanvasWidth) {
        x2 = 0;
        row++;
      }
      mapping[char] = {
        x: x2 + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x2 += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x2,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  let width = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = text[i];
    width += mapping[character]?.layoutWidth || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const textWidth = getTextWidth(text, i, i + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i) {
        target.push(i);
      }
      rowStartCharIndex = i;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i = startIndex; i < endIndex; i++) {
    if (text[i] === " ") {
      groupEndCharIndex = i + 1;
    } else if (text[i + 1] === " " || i + 1 === endIndex) {
      groupEndCharIndex = i + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === void 0) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === "break-all") {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x2 = 0;
  let rowHeight = 0;
  for (let i = startIndex; i < endIndex; i++) {
    const character = line[i];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i] = x2 + frame.layoutWidth / 2;
      x2 += frame.layoutWidth;
    } else {
      log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
      leftOffsets[i] = x2;
      x2 += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x2;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x2 = new Array(numCharacters);
  const y2 = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i = 0; i <= numCharacters; i++) {
    const char = characters[i];
    if (char === "\n" || i === numCharacters) {
      lineEndIndex = i;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x2, rowSize);
        for (let j2 = rowStart; j2 < rowEnd; j2++) {
          const rowOffsetLeft = x2[j2] - rowSize[0] / 2;
          const char2 = characters[j2];
          const layoutOffsetY = iconMapping[char2]?.layoutOffsetY || 0;
          y2[j2] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j2] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === "\n") {
      x2[lineStartIndex] = 0;
      y2[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return { x: x2, y: y2, rowWidth, size };
}
function getTextFromBuffer({ value, length, stride, offset, startIndices, characterSet }) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
  const texts = new Array(length);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i = 0; i < characterCount; i++) {
      codes[i] = value[i * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return { texts, characterCount };
}

// node_modules/@deck.gl/layers/dist/text-layer/lru-cache.js
var LRUCache = class {
  constructor(limit = 5) {
    this._cache = {};
    this._order = [];
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index = this._order.indexOf(key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
var DEFAULT_FONT_SETTINGS = {
  fontFamily: "Monaco, monospace",
  fontWeight: "normal",
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 0.9;
var HEIGHT_SCALE = 1.2;
var CACHE_LIMIT = 3;
var cache = new LRUCache(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === "string") {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.textAlign = "left";
}
function setFontAtlasCacheLimit(limit) {
  log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
  cache = new LRUCache(limit);
}
var FontAtlasManager = class {
  constructor() {
    this.props = { ...DEFAULT_FONT_SETTINGS };
  }
  get atlas() {
    return this._atlas;
  }
  // TODO - cut during v9 porting as types reveal this is not correct
  // get texture(): Texture | undefined {
  //   return this._atlas;
  // }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const { fontSize, buffer } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache.set(this._key, fontAtlas);
  }
  // eslint-disable-next-line max-statements
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const { mapping, canvasHeight, xOffset, yOffset } = buildMapping2({
      getFontWidth: (char) => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      }
    });
    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new TinySDF({
        fontSize,
        buffer,
        radius,
        cutoff,
        fontFamily,
        fontWeight: `${fontWeight}`
      });
      for (const char of characterSet) {
        const { data, width, height, glyphTop } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx.createImageData(width, height);
        populateAlphaChannel(data, imageData);
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  _getKey() {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    if (sdf) {
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
    }
    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-uniforms.js
var uniformBlock9 = `uniform textBackgroundUniforms {
  bool billboard;
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  vec4 borderRadius;
  vec4 padding;
  highp int sizeUnits;
  bool stroked;
} textBackground;
`;
var textBackgroundUniforms = {
  name: "textBackground",
  vs: uniformBlock9,
  fs: uniformBlock9,
  uniformTypes: {
    billboard: "f32",
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    borderRadius: "vec4<f32>",
    padding: "vec4<f32>",
    sizeUnits: "i32",
    stroked: "f32"
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-vertex.glsl.js
var text_background_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * textBackground.sizeScale, textBackground.sizeUnits),
textBackground.sizeMinPixels, textBackground.sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + textBackground.padding.xy + textBackground.padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-textBackground.padding.xy, textBackground.padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (textBackground.billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-fragment.glsl.js
var text_background_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
float round_rect(vec2 p, vec2 size, vec4 radii) {
vec2 pixelPositionCB = (p - 0.5) * size;
vec2 sizeCB = size * 0.5;
float maxBorderRadius = min(size.x, size.y) * 0.5;
vec4 borderRadius = vec4(min(radii, maxBorderRadius));
borderRadius.xy =
(pixelPositionCB.x > 0.0) ? borderRadius.xy : borderRadius.zw;
borderRadius.x = (pixelPositionCB.y > 0.0) ? borderRadius.x : borderRadius.y;
vec2 q = abs(pixelPositionCB) - sizeCB + borderRadius.x;
return -(min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - borderRadius.x);
}
float rect(vec2 p, vec2 size) {
vec2 pixelPosition = p * size;
return min(min(pixelPosition.x, size.x - pixelPosition.x),
min(pixelPosition.y, size.y - pixelPosition.y));
}
vec4 get_stroked_fragColor(float dist) {
float isBorder = smoothedge(dist, vLineWidth);
return mix(vFillColor, vLineColor, isBorder);
}
void main(void) {
geometry.uv = uv;
if (textBackground.borderRadius != vec4(0.0)) {
float distToEdge = round_rect(uv, dimensions, textBackground.borderRadius);
if (textBackground.stroked) {
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
float shapeAlpha = smoothedge(-distToEdge, 0.0);
fragColor.a *= shapeAlpha;
} else {
if (textBackground.stroked) {
float distToEdge = rect(uv, dimensions);
fragColor = get_stroked_fragColor(distToEdge);
} else {
fragColor = vFillColor;
}
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer.js
var defaultProps13 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  borderRadius: { type: "object", value: 0 },
  padding: { type: "array", value: [0, 0, 0, 0] },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
  getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineWidth: { type: "accessor", value: 1 }
};
var TextBackgroundLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({ vs: text_background_layer_vertex_glsl_default, fs: text_background_layer_fragment_glsl_default, modules: [project32_default, picking_default, textBackgroundUniforms] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instanceRects: {
        size: 4,
        accessor: "getBoundingRect"
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { changeFlags } = params;
    if (changeFlags.extensionsChanged) {
      this.state.model?.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
    let { padding, borderRadius } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    if (!Array.isArray(borderRadius)) {
      borderRadius = [borderRadius, borderRadius, borderRadius, borderRadius];
    }
    const model = this.state.model;
    const textBackgroundProps = {
      billboard,
      stroked: Boolean(getLineWidth),
      borderRadius,
      padding,
      sizeUnits: UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    };
    model.shaderInputs.setProps({ textBackground: textBackgroundProps });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [0, 0, 1, 0, 0, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        vertexCount: 4,
        attributes: {
          positions: { size: 2, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
TextBackgroundLayer.defaultProps = defaultProps13;
TextBackgroundLayer.layerName = "TextBackgroundLayer";
var text_background_layer_default = TextBackgroundLayer;

// node_modules/@deck.gl/layers/dist/text-layer/text-layer.js
var TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
var ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
var DEFAULT_COLOR9 = [0, 0, 0, 255];
var DEFAULT_LINE_HEIGHT = 1;
var defaultProps14 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
  getBorderColor: { type: "accessor", value: DEFAULT_COLOR9 },
  getBorderWidth: { type: "accessor", value: 0 },
  backgroundBorderRadius: { type: "object", value: 0 },
  backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
  characterSet: { type: "object", value: DEFAULT_FONT_SETTINGS.characterSet },
  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: { type: "number", value: 0, min: 0 },
  outlineColor: { type: "color", value: DEFAULT_COLOR9 },
  fontSettings: { type: "object", value: {}, compare: 1 },
  // auto wrapping options
  wordBreak: "break-word",
  maxWidth: { type: "number", value: -1 },
  getText: { type: "accessor", value: (x2) => x2.text },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR9 },
  getSize: { type: "accessor", value: 32 },
  getAngle: { type: "accessor", value: 0 },
  getTextAnchor: { type: "accessor", value: "middle" },
  getAlignmentBaseline: { type: "accessor", value: "center" },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  // deprecated
  backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
};
var TextLayer = class extends composite_layer_default {
  constructor() {
    super(...arguments);
    this.getBoundingRect = (object, objectInfo) => {
      let { size: [width, height] } = this.transformParagraph(object, objectInfo);
      const { fontSize } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    };
    this.getIconOffsets = (object, objectInfo) => {
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const { x: x2, y: y2, rowWidth, size: [width, height] } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x2.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i = 0; i < numCharacters; i++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x2[i];
        offsets[index++] = (anchorY - 1) * height / 2 + y2[i];
      }
      return offsets;
    };
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new FontAtlasManager()
    };
    if (this.props.maxWidth > 0) {
      log_default.once(1, "v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
    }
  }
  // eslint-disable-next-line complexity
  updateState(params) {
    const { props, oldProps, changeFlags } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({ info }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  /** Returns true if font has changed */
  _updateFontAtlas() {
    const { fontSettings, fontFamily, fontWeight } = this.props;
    const { fontAtlasManager, characterSet } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  // Text strings are variable width objects
  // Count characters and start offsets
  _updateText() {
    const { data, characterSet } = this.props;
    const textBuffer = data.attributes?.getText;
    let { getText } = this.props;
    let startIndices = data.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
    if (textBuffer && startIndices) {
      const { texts, characterCount } = getTextFromBuffer({
        ...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
        // @ts-ignore if data.attribute is defined then length is expected
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_2, { index }) => texts[index];
    } else {
      const { iterable, objectInfo } = createIterable(data);
      startIndices = [0];
      numInstances = 0;
      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || "");
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  /** There are two size systems in this layer:
  
      + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
        The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
        in layer props is roughly equivalent to font-size: 24px in CSS.
      + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
        which depends on how large each character is drawn into the font atlas. This is controlled by
        fontSettings.fontSize (default 64) and most users do not set it manually.
        These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
  
      All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
  /** Calculate the size and position of each character in a text string.
   * Values are in texture size */
  transformParagraph(object, objectInfo) {
    const { fontAtlasManager } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const { wordBreak, lineHeight, maxWidth } = this.props;
    const paragraph = getText(object, objectInfo) || "";
    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const { startIndices, numInstances, getText, fontAtlasManager: { scale, atlas, mapping }, styleVersion } = this.state;
    const { data, _dataDiff, getPosition, getColor, getSize, getAngle, getPixelOffset, getBackgroundColor, getBorderColor, getBorderWidth, backgroundBorderRadius, backgroundPadding, background, billboard, fontSettings, outlineWidth, outlineColor, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, transitions, updateTriggers } = this.props;
    const CharactersLayerClass = this.getSubLayerClass("characters", multi_icon_layer_default);
    const BackgroundLayerClass = this.getSubLayerClass("background", text_background_layer_default);
    return [
      background && new BackgroundLayerClass({
        // background props
        getFillColor: getBackgroundColor,
        getLineColor: getBorderColor,
        getLineWidth: getBorderWidth,
        borderRadius: backgroundBorderRadius,
        padding: backgroundPadding,
        // props shared with characters layer
        getPosition,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getSize: transitions.getSize,
          getFillColor: transitions.getBackgroundColor,
          getLineColor: transitions.getBorderColor,
          getLineWidth: transitions.getBorderWidth,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "background",
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getSize: updateTriggers.getSize,
          getFillColor: updateTriggers.getBackgroundColor,
          getLineColor: updateTriggers.getBorderColor,
          getLineWidth: updateTriggers.getBorderWidth,
          getPixelOffset: updateTriggers.getPixelOffset,
          getBoundingRect: {
            getText: updateTriggers.getText,
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data: (
          // @ts-ignore (2339) attribute is not defined on all data types
          data.attributes && data.attributes.background ? (
            // @ts-ignore (2339) attribute is not defined on all data types
            { length: data.length, attributes: data.attributes.background }
          ) : data
        ),
        _dataDiff,
        // Maintain the same background behavior as <=8.3. Remove in v9?
        autoHighlight: false,
        getBoundingRect: this.getBoundingRect
      }),
      new CharactersLayerClass({
        sdf: fontSettings.sdf,
        smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
        outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
        outlineColor,
        iconAtlas: atlas,
        iconMapping: mapping,
        getPosition,
        getColor,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale: sizeScale * scale,
        sizeUnits,
        sizeMinPixels: sizeMinPixels * scale,
        sizeMaxPixels: sizeMaxPixels * scale,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "characters",
        updateTriggers: {
          all: updateTriggers.getText,
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getIconOffsets: {
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data,
        _dataDiff,
        startIndices,
        numInstances,
        getIconOffsets: this.getIconOffsets,
        getIcon: getText
      })
    ];
  }
  static set fontAtlasCacheLimit(limit) {
    setFontAtlasCacheLimit(limit);
  }
};
TextLayer.defaultProps = defaultProps14;
TextLayer.layerName = "TextLayer";
var text_layer_default = TextLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/sub-layer-map.js
var POINT_LAYER = {
  circle: {
    type: scatterplot_layer_default,
    props: {
      filled: "filled",
      stroked: "stroked",
      lineWidthMaxPixels: "lineWidthMaxPixels",
      lineWidthMinPixels: "lineWidthMinPixels",
      lineWidthScale: "lineWidthScale",
      lineWidthUnits: "lineWidthUnits",
      pointRadiusMaxPixels: "radiusMaxPixels",
      pointRadiusMinPixels: "radiusMinPixels",
      pointRadiusScale: "radiusScale",
      pointRadiusUnits: "radiusUnits",
      pointAntialiasing: "antialiasing",
      pointBillboard: "billboard",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor",
      getLineWidth: "getLineWidth",
      getPointRadius: "getRadius"
    }
  },
  icon: {
    type: icon_layer_default,
    props: {
      iconAtlas: "iconAtlas",
      iconMapping: "iconMapping",
      iconSizeMaxPixels: "sizeMaxPixels",
      iconSizeMinPixels: "sizeMinPixels",
      iconSizeScale: "sizeScale",
      iconSizeUnits: "sizeUnits",
      iconAlphaCutoff: "alphaCutoff",
      iconBillboard: "billboard",
      getIcon: "getIcon",
      getIconAngle: "getAngle",
      getIconColor: "getColor",
      getIconPixelOffset: "getPixelOffset",
      getIconSize: "getSize"
    }
  },
  text: {
    type: text_layer_default,
    props: {
      textSizeMaxPixels: "sizeMaxPixels",
      textSizeMinPixels: "sizeMinPixels",
      textSizeScale: "sizeScale",
      textSizeUnits: "sizeUnits",
      textBackground: "background",
      textBackgroundPadding: "backgroundPadding",
      textFontFamily: "fontFamily",
      textFontWeight: "fontWeight",
      textLineHeight: "lineHeight",
      textMaxWidth: "maxWidth",
      textOutlineColor: "outlineColor",
      textOutlineWidth: "outlineWidth",
      textWordBreak: "wordBreak",
      textCharacterSet: "characterSet",
      textBillboard: "billboard",
      textFontSettings: "fontSettings",
      getText: "getText",
      getTextAngle: "getAngle",
      getTextColor: "getColor",
      getTextPixelOffset: "getPixelOffset",
      getTextSize: "getSize",
      getTextAnchor: "getTextAnchor",
      getTextAlignmentBaseline: "getAlignmentBaseline",
      getTextBackgroundColor: "getBackgroundColor",
      getTextBorderColor: "getBorderColor",
      getTextBorderWidth: "getBorderWidth"
    }
  }
};
var LINE_LAYER = {
  type: path_layer_default,
  props: {
    lineWidthUnits: "widthUnits",
    lineWidthScale: "widthScale",
    lineWidthMinPixels: "widthMinPixels",
    lineWidthMaxPixels: "widthMaxPixels",
    lineJointRounded: "jointRounded",
    lineCapRounded: "capRounded",
    lineMiterLimit: "miterLimit",
    lineBillboard: "billboard",
    getLineColor: "getColor",
    getLineWidth: "getWidth"
  }
};
var POLYGON_LAYER = {
  type: solid_polygon_layer_default,
  props: {
    extruded: "extruded",
    filled: "filled",
    wireframe: "wireframe",
    elevationScale: "elevationScale",
    material: "material",
    _full3d: "_full3d",
    getElevation: "getElevation",
    getFillColor: "getFillColor",
    getLineColor: "getLineColor"
  }
};
function getDefaultProps({ type, props }) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const { transitions, updateTriggers } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith("get")) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson.js
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  log_default.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{ geometry: geojson }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const { startRow = 0, endRow = features.length } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];
    const { geometry } = feature;
    if (!geometry) {
      continue;
    }
    if (geometry.type === "GeometryCollection") {
      log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
      const { geometries } = geometry;
      for (let i = 0; i < geometries.length; i++) {
        const subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const { type, coordinates } = geometry;
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
  if (!validateGeometry(type, coordinates)) {
    log_default.warn(`${type} coordinates are malformed`)();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach((point) => {
        pointFeatures.push(wrapFeature({
          geometry: { type: "Point", coordinates: point }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach((path) => {
        lineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach((path) => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach((polygon) => {
        polygonFeatures.push(wrapFeature({
          geometry: { type: "Polygon", coordinates: polygon }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: { type: "LineString", coordinates: path }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
var COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer-props.js
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f) {
  return f.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const { points, lines, polygons } = geojsonBinary;
  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = "open";
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 4,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = "open";
  return layerProps;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js
var FEATURE_TYPES = ["points", "linestrings", "polygons"];
var defaultProps15 = {
  ...getDefaultProps(POINT_LAYER.circle),
  ...getDefaultProps(POINT_LAYER.icon),
  ...getDefaultProps(POINT_LAYER.text),
  ...getDefaultProps(LINE_LAYER),
  ...getDefaultProps(POLYGON_LAYER),
  // Overwrite sub layer defaults
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: { type: "object", value: null },
  iconMapping: { type: "object", value: {} },
  getIcon: { type: "accessor", value: (f) => f.properties.icon },
  getText: { type: "accessor", value: (f) => f.properties.text },
  // Self props
  pointType: "circle",
  // TODO: deprecated, remove in v9
  getRadius: { deprecatedFor: "getPointRadius" }
};
var GeoJsonLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {},
      featuresDiff: {}
    };
  }
  updateState({ props, changeFlags }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const { data } = this.props;
    const binary = data && "points" in data && "polygons" in data && "lines" in data;
    this.setState({ binary });
    if (binary) {
      this._updateStateBinary({ props, changeFlags });
    } else {
      this._updateStateJSON({ props, changeFlags });
    }
  }
  _updateStateBinary({ props, changeFlags }) {
    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
    this.setState({ layerProps });
  }
  _updateStateJSON({ props, changeFlags }) {
    const features = getGeojsonFeatures(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push(replaceInRange({
            data: newFeatures[key],
            getIndex: (f) => f.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = separateGeojsonFeatures(features, wrapFeature);
    }
    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index, sourceLayer } = info;
    info.featureType = FEATURE_TYPES.find((ft2) => sourceLayer.id.startsWith(`${this.id}-${ft2}-`));
    if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = `${this.id}-points-`;
    const sourceIsPoints = info.featureType === "points";
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    const { extruded, wireframe } = this.props;
    const { layerProps } = this.state;
    const id = "polygons-fill";
    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons?.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    const { extruded, stroked } = this.props;
    const { layerProps } = this.state;
    const polygonStrokeLayerId = "polygons-stroke";
    const lineStringsLayerId = "linestrings";
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = forwardProps(this, LINE_LAYER.props);
      return [
        PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
          id: polygonStrokeLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.polygonsOutline),
        LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
          id: lineStringsLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.lines)
      ];
    }
    return null;
  }
  _renderPointLayers() {
    const { pointType } = this.props;
    const { layerProps, binary } = this.state;
    let { highlightedObjectIndex } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex((d) => d.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split("+"));
    const pointLayers = [];
    for (const type of types) {
      const id = `points-${type}`;
      const PointLayerMapping = POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points?.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = forwardProps(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === "text" && binary) {
          const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            // @ts-expect-error TODO - type binary data
            data: { ...pointsLayerProps.data, attributes: rest }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const { extruded } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonFillLayer,
      lineLayers,
      pointLayers,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonFillLayer
    ];
  }
  getSubLayerAccessor(accessor) {
    const { binary } = this.state;
    if (!binary || typeof accessor !== "function") {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const { data, index } = info;
      const feature = binaryToFeatureForAccesor(data, index);
      return accessor(feature, info);
    };
  }
};
GeoJsonLayer.layerName = "GeoJsonLayer";
GeoJsonLayer.defaultProps = defaultProps15;

// node_modules/geodesy-fn/dist/geodesy-fn.js
var DEFAULT_RADIUS = 6371e3;
function equals2(position1, position2) {
  if (Math.abs(position1[0] - position2[0]) > Number.EPSILON)
    return false;
  if (Math.abs(position1[1] - position2[1]) > Number.EPSILON)
    return false;
  return true;
}
function toRadians(value) {
  return value / 180 * Math.PI;
}
function toDegrees(value) {
  return value / Math.PI * 180;
}
function wrap360(value) {
  return (value + 360) % 360;
}
function distance(start, destination, radius = DEFAULT_RADIUS) {
  const R2 = radius;
  const 1 = toRadians(start[1]), 1 = toRadians(start[0]);
  const 2 = toRadians(destination[1]), 2 = toRadians(destination[0]);
  const  = 2 - 1;
  const  = 2 - 1;
  const a = Math.sin( / 2) * Math.sin( / 2) + Math.cos(1) * Math.cos(2) * Math.sin( / 2) * Math.sin( / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const d = R2 * c;
  return d;
}
function initialBearing(start, destination) {
  if (equals2(start, destination))
    return NaN;
  const 1 = toRadians(start[1]);
  const 2 = toRadians(destination[1]);
  const  = toRadians(destination[0] - start[0]);
  const x2 = Math.cos(1) * Math.sin(2) - Math.sin(1) * Math.cos(2) * Math.cos();
  const y2 = Math.sin() * Math.cos(2);
  const  = Math.atan2(y2, x2);
  const bearing = toDegrees();
  return wrap360(bearing);
}
function destinationPoint(start, distance2, bearing, radius = DEFAULT_RADIUS) {
  const  = distance2 / radius;
  const  = toRadians(bearing);
  const 1 = toRadians(start[1]), 1 = toRadians(start[0]);
  const sin2 = Math.sin(1) * Math.cos() + Math.cos(1) * Math.sin() * Math.cos();
  const 2 = Math.asin(sin2);
  const y2 = Math.sin() * Math.sin() * Math.cos(1);
  const x2 = Math.cos() - Math.sin(1) * sin2;
  const 2 = 1 + Math.atan2(y2, x2);
  const lat = toDegrees(2);
  const lon = toDegrees(2);
  return [lon, lat];
}

// node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep, target) {
  const pendingListeners = /* @__PURE__ */ new Map();
  ep.addEventListener("message", function handleMessage(ev) {
    const { data } = ev;
    if (!data || !data.id) {
      return;
    }
    const resolver = pendingListeners.get(data.id);
    if (!resolver) {
      return;
    }
    try {
      resolver(data);
    } finally {
      pendingListeners.delete(data.id);
    }
  });
  return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, pendingListeners, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          pendingListeners.clear();
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r = requestResponseMessage(ep, pendingListeners, {
          type: "GET",
          path: path.map((p) => p.toString())
        }).then(fromWireValue);
        return r.then.bind(r);
      }
      return createProxy(ep, pendingListeners, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, pendingListeners, {
        type: "SET",
        path: [...path, prop].map((p) => p.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path[path.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, pendingListeners, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, pendingListeners, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "APPLY",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, pendingListeners, {
        type: "CONSTRUCT",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    pendingListeners.set(id, resolve);
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// node_modules/rollup-plugin-worker-factory/src/browser.js
var browserWorkerPolyFill = function(workerObj) {
  workerObj.on = workerObj.addEventListener;
  workerObj.off = workerObj.removeEventListener;
  return workerObj;
};
var createObjectURL = function(str) {
  try {
    return URL.createObjectURL(new Blob([str], { type: "application/javascript" }));
  } catch (e) {
    const blob = new BlobBuilder();
    blob.append(str);
    return URL.createObjectURL(blob.getBlob());
  }
};
var factory = function(code) {
  return function() {
    const objectUrl = createObjectURL(code);
    const worker = browserWorkerPolyFill(new Worker(objectUrl));
    worker.objURL = objectUrl;
    const terminate = worker.terminate;
    worker.on = worker.addEventListener;
    worker.off = worker.removeEventListener;
    worker.terminate = function() {
      URL.revokeObjectURL(objectUrl);
      return terminate.call(this);
    };
    return worker;
  };
};
var transform = function(code) {
  return `var browserWorkerPolyFill = ${browserWorkerPolyFill.toString()};
browserWorkerPolyFill(self);
` + code;
};

// node_modules/@mapbox/sphericalmercator/dist/esm/constants.js
var D2R = Math.PI / 180;
var R2D = 180 / Math.PI;
var A = 6378137;
var MAXEXTENT = 20037508342789244e-9;
var SPHERICAL_MERCATOR_SRS = "900913";
var WGS84 = "WGS84";

// node_modules/@mapbox/sphericalmercator/dist/esm/index.js
var cache2 = {};
function isFloat(n) {
  return Number(n) === n && n % 1 !== 0;
}
var SphericalMercator = class {
  #size;
  #expansion;
  #Bc;
  #Cc;
  #zc;
  #Ac;
  constructor(options = {}) {
    this.#size = options.size || 256;
    this.#expansion = options.antimeridian ? 2 : 1;
    if (!cache2[this.#size]) {
      let size = this.#size;
      const c = cache2[this.#size] = {};
      c.Bc = [];
      c.Cc = [];
      c.zc = [];
      c.Ac = [];
      for (let d = 0; d < 30; d++) {
        c.Bc.push(size / 360);
        c.Cc.push(size / (2 * Math.PI));
        c.zc.push(size / 2);
        c.Ac.push(size);
        size *= 2;
      }
    }
    this.#Bc = cache2[this.#size].Bc;
    this.#Cc = cache2[this.#size].Cc;
    this.#zc = cache2[this.#size].zc;
    this.#Ac = cache2[this.#size].Ac;
  }
  px(ll, zoom) {
    if (isFloat(zoom)) {
      const size = this.#size * Math.pow(2, zoom);
      const d = size / 2;
      const bc = size / 360;
      const cc = size / (2 * Math.PI);
      const ac = size;
      const f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);
      let x2 = d + ll[0] * bc;
      let y2 = d + 0.5 * Math.log((1 + f) / (1 - f)) * -cc;
      x2 > ac * this.#expansion && (x2 = ac * this.#expansion);
      y2 > ac && (y2 = ac);
      return [x2, y2];
    } else {
      const d = this.#zc[zoom];
      const f = Math.min(Math.max(Math.sin(D2R * ll[1]), -0.9999), 0.9999);
      let x2 = Math.round(d + ll[0] * this.#Bc[zoom]);
      let y2 = Math.round(d + 0.5 * Math.log((1 + f) / (1 - f)) * -this.#Cc[zoom]);
      x2 > this.#Ac[zoom] * this.#expansion && (x2 = this.#Ac[zoom] * this.#expansion);
      y2 > this.#Ac[zoom] && (y2 = this.#Ac[zoom]);
      return [x2, y2];
    }
  }
  ll(px, zoom) {
    if (isFloat(zoom)) {
      const size = this.#size * Math.pow(2, zoom);
      const bc = size / 360;
      const cc = size / (2 * Math.PI);
      const zc = size / 2;
      const g = (px[1] - zc) / -cc;
      const lon = (px[0] - zc) / bc;
      const lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);
      return [lon, lat];
    } else {
      const g = (px[1] - this.#zc[zoom]) / -this.#Cc[zoom];
      const lon = (px[0] - this.#zc[zoom]) / this.#Bc[zoom];
      const lat = R2D * (2 * Math.atan(Math.exp(g)) - 0.5 * Math.PI);
      return [lon, lat];
    }
  }
  convert(bbox, to) {
    if (to === SPHERICAL_MERCATOR_SRS) {
      return [
        ...this.forward(bbox.slice(0, 2)),
        ...this.forward(bbox.slice(2, 4))
      ];
    } else {
      return [
        ...this.inverse(bbox.slice(0, 2)),
        ...this.inverse(bbox.slice(2, 4))
      ];
    }
  }
  inverse(xy) {
    return [
      xy[0] * R2D / A,
      (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-xy[1] / A))) * R2D
    ];
  }
  forward(ll) {
    const xy = [
      A * ll[0] * D2R,
      A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * ll[1] * D2R))
    ];
    xy[0] > MAXEXTENT && (xy[0] = MAXEXTENT);
    xy[0] < -MAXEXTENT && (xy[0] = -MAXEXTENT);
    xy[1] > MAXEXTENT && (xy[1] = MAXEXTENT);
    xy[1] < -MAXEXTENT && (xy[1] = -MAXEXTENT);
    return xy;
  }
  bbox(x2, y2, zoom, tmsStyle, srs) {
    if (tmsStyle) {
      y2 = Math.pow(2, zoom) - 1 - y2;
    }
    const ll = [x2 * this.#size, (+y2 + 1) * this.#size];
    const ur = [(+x2 + 1) * this.#size, y2 * this.#size];
    const bbox = [...this.ll(ll, zoom), ...this.ll(ur, zoom)];
    if (srs === SPHERICAL_MERCATOR_SRS)
      return this.convert(bbox, SPHERICAL_MERCATOR_SRS);
    return bbox;
  }
  xyz(bbox, zoom, tmsStyle, srs) {
    const box = srs === SPHERICAL_MERCATOR_SRS ? this.convert(bbox, WGS84) : bbox;
    const ll = [box[0], box[1]];
    const ur = [box[2], box[3]];
    const px_ll = this.px(ll, zoom);
    const px_ur = this.px(ur, zoom);
    const x2 = [
      Math.floor(px_ll[0] / this.#size),
      Math.floor((px_ur[0] - 1) / this.#size)
    ];
    const y2 = [
      Math.floor(px_ur[1] / this.#size),
      Math.floor((px_ll[1] - 1) / this.#size)
    ];
    const bounds = {
      minX: Math.min.apply(Math, x2) < 0 ? 0 : Math.min.apply(Math, x2),
      minY: Math.min.apply(Math, y2) < 0 ? 0 : Math.min.apply(Math, y2),
      maxX: Math.max.apply(Math, x2),
      maxY: Math.max.apply(Math, y2)
    };
    if (tmsStyle) {
      const tms = {
        minY: Math.pow(2, zoom) - 1 - bounds.maxY,
        maxY: Math.pow(2, zoom) - 1 - bounds.minY
      };
      bounds.minY = tms.minY;
      bounds.maxY = tms.maxY;
    }
    return bounds;
  }
};

// node_modules/icomesh/index.js
function icomesh(order = 4, uvMap = false) {
  if (order > 10) throw new Error(`Max order is 10, but given ${order}.`);
  const f = (1 + Math.sqrt(5)) / 2;
  const T2 = Math.pow(4, order);
  const numVertices = 10 * T2 + 2;
  const numDuplicates = !uvMap ? 0 : order === 0 ? 3 : Math.pow(2, order) * 3 + 9;
  const vertices = new Float32Array((numVertices + numDuplicates) * 3);
  vertices.set(Float32Array.of(
    -1,
    f,
    0,
    1,
    f,
    0,
    -1,
    -f,
    0,
    1,
    -f,
    0,
    0,
    -1,
    f,
    0,
    1,
    f,
    0,
    -1,
    -f,
    0,
    1,
    -f,
    f,
    0,
    -1,
    f,
    0,
    1,
    -f,
    0,
    -1,
    -f,
    0,
    1
  ));
  let triangles = Uint16Array.of(
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    11,
    10,
    2,
    5,
    11,
    4,
    1,
    5,
    9,
    7,
    1,
    8,
    10,
    7,
    6,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    9,
    8,
    1,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7
  );
  let v = 12;
  const midCache = order ? /* @__PURE__ */ new Map() : null;
  function addMidPoint(a, b2) {
    const key = Math.floor((a + b2) * (a + b2 + 1) / 2 + Math.min(a, b2));
    const i = midCache.get(key);
    if (i !== void 0) {
      midCache.delete(key);
      return i;
    }
    midCache.set(key, v);
    vertices[3 * v + 0] = (vertices[3 * a + 0] + vertices[3 * b2 + 0]) * 0.5;
    vertices[3 * v + 1] = (vertices[3 * a + 1] + vertices[3 * b2 + 1]) * 0.5;
    vertices[3 * v + 2] = (vertices[3 * a + 2] + vertices[3 * b2 + 2]) * 0.5;
    return v++;
  }
  let trianglesPrev = triangles;
  const IndexArray = order > 5 ? Uint32Array : Uint16Array;
  for (let i = 0; i < order; i++) {
    const prevLen = trianglesPrev.length;
    triangles = new IndexArray(prevLen * 4);
    for (let k2 = 0; k2 < prevLen; k2 += 3) {
      const v1 = trianglesPrev[k2 + 0];
      const v2 = trianglesPrev[k2 + 1];
      const v3 = trianglesPrev[k2 + 2];
      const a = addMidPoint(v1, v2);
      const b2 = addMidPoint(v2, v3);
      const c = addMidPoint(v3, v1);
      let t = k2 * 4;
      triangles[t++] = v1;
      triangles[t++] = a;
      triangles[t++] = c;
      triangles[t++] = v2;
      triangles[t++] = b2;
      triangles[t++] = a;
      triangles[t++] = v3;
      triangles[t++] = c;
      triangles[t++] = b2;
      triangles[t++] = a;
      triangles[t++] = b2;
      triangles[t++] = c;
    }
    trianglesPrev = triangles;
  }
  for (let i = 0; i < numVertices * 3; i += 3) {
    const v1 = vertices[i + 0];
    const v2 = vertices[i + 1];
    const v3 = vertices[i + 2];
    const m = 1 / Math.sqrt(v1 * v1 + v2 * v2 + v3 * v3);
    vertices[i + 0] *= m;
    vertices[i + 1] *= m;
    vertices[i + 2] *= m;
  }
  if (!uvMap) return { vertices, triangles };
  const uv = new Float32Array((numVertices + numDuplicates) * 2);
  for (let i = 0; i < numVertices; i++) {
    uv[2 * i + 0] = Math.atan2(vertices[3 * i + 2], vertices[3 * i]) / (2 * Math.PI) + 0.5;
    uv[2 * i + 1] = Math.asin(vertices[3 * i + 1]) / Math.PI + 0.5;
  }
  const duplicates = /* @__PURE__ */ new Map();
  function addDuplicate(i, uvx, uvy, cached) {
    if (cached) {
      const dupe = duplicates.get(i);
      if (dupe !== void 0) return dupe;
    }
    vertices[3 * v + 0] = vertices[3 * i + 0];
    vertices[3 * v + 1] = vertices[3 * i + 1];
    vertices[3 * v + 2] = vertices[3 * i + 2];
    uv[2 * v + 0] = uvx;
    uv[2 * v + 1] = uvy;
    if (cached) duplicates.set(i, v);
    return v++;
  }
  for (let i = 0; i < triangles.length; i += 3) {
    const a = triangles[i + 0];
    const b2 = triangles[i + 1];
    const c = triangles[i + 2];
    let ax = uv[2 * a];
    let bx = uv[2 * b2];
    let cx = uv[2 * c];
    const ay = uv[2 * a + 1];
    const by = uv[2 * b2 + 1];
    const cy = uv[2 * c + 1];
    if (bx - ax >= 0.5 && ay !== 1) bx -= 1;
    if (cx - bx > 0.5) cx -= 1;
    if (ax > 0.5 && ax - cx > 0.5 || ax === 1 && cy === 0) ax -= 1;
    if (bx > 0.5 && bx - ax > 0.5) bx -= 1;
    if (ay === 0 || ay === 1) {
      ax = (bx + cx) / 2;
      if (ay === bx) uv[2 * a] = ax;
      else triangles[i + 0] = addDuplicate(a, ax, ay, false);
    } else if (by === 0 || by === 1) {
      bx = (ax + cx) / 2;
      if (by === ax) uv[2 * b2] = bx;
      else triangles[i + 1] = addDuplicate(b2, bx, by, false);
    } else if (cy === 0 || cy === 1) {
      cx = (ax + bx) / 2;
      if (cy === ax) uv[2 * c] = cx;
      else triangles[i + 2] = addDuplicate(c, cx, cy, false);
    }
    if (ax !== uv[2 * a] && ay !== 0 && ay !== 1) triangles[i + 0] = addDuplicate(a, ax, ay, true);
    if (bx !== uv[2 * b2] && by !== 0 && by !== 1) triangles[i + 1] = addDuplicate(b2, bx, by, true);
    if (cx !== uv[2 * c] && cy !== 0 && cy !== 1) triangles[i + 2] = addDuplicate(c, cx, cy, true);
  }
  return { vertices, triangles, uv };
}

// node_modules/kdbush/index.js
var ARRAY_TYPES = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
];
var VERSION = 1;
var HEADER_SIZE = 8;
var KDBush = class _KDBush {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(data) {
    if (!(data instanceof ArrayBuffer)) {
      throw new Error("Data must be an instance of ArrayBuffer.");
    }
    const [magic, versionAndType] = new Uint8Array(data, 0, 2);
    if (magic !== 219) {
      throw new Error("Data does not appear to be in a KDBush format.");
    }
    const version = versionAndType >> 4;
    if (version !== VERSION) {
      throw new Error(`Got v${version} data when expected v${VERSION}.`);
    }
    const ArrayType = ARRAY_TYPES[versionAndType & 15];
    if (!ArrayType) {
      throw new Error("Unrecognized array type.");
    }
    const [nodeSize] = new Uint16Array(data, 2, 1);
    const [numItems] = new Uint32Array(data, 4, 1);
    return new _KDBush(numItems, nodeSize, ArrayType, data);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {
    if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);
    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
    this.ArrayType = ArrayType;
    this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;
    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;
    const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;
    const padCoords = (8 - idsByteSize % 8) % 8;
    if (arrayTypeIndex < 0) {
      throw new Error(`Unexpected typed array class: ${ArrayType}.`);
    }
    if (data && data instanceof ArrayBuffer) {
      this.data = data;
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = numItems * 2;
      this._finished = true;
    } else {
      this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = 0;
      this._finished = false;
      new Uint8Array(this.data, 0, 2).set([219, (VERSION << 4) + arrayTypeIndex]);
      new Uint16Array(this.data, 2, 1)[0] = nodeSize;
      new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(x2, y2) {
    const index = this._pos >> 1;
    this.ids[index] = index;
    this.coords[this._pos++] = x2;
    this.coords[this._pos++] = y2;
    return index;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const numAdded = this._pos >> 1;
    if (numAdded !== this.numItems) {
      throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);
    }
    sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);
    this._finished = true;
    return this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(minX, minY, maxX, maxY) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids, coords, nodeSize } = this;
    const stack = [0, ids.length - 1, 0];
    const result = [];
    while (stack.length) {
      const axis = stack.pop() || 0;
      const right = stack.pop() || 0;
      const left = stack.pop() || 0;
      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          const x3 = coords[2 * i];
          const y3 = coords[2 * i + 1];
          if (x3 >= minX && x3 <= maxX && y3 >= minY && y3 <= maxY) result.push(ids[i]);
        }
        continue;
      }
      const m = left + right >> 1;
      const x2 = coords[2 * m];
      const y2 = coords[2 * m + 1];
      if (x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY) result.push(ids[m]);
      if (axis === 0 ? minX <= x2 : minY <= y2) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(1 - axis);
      }
      if (axis === 0 ? maxX >= x2 : maxY >= y2) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(1 - axis);
      }
    }
    return result;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(qx, qy, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids, coords, nodeSize } = this;
    const stack = [0, ids.length - 1, 0];
    const result = [];
    const r2 = r * r;
    while (stack.length) {
      const axis = stack.pop() || 0;
      const right = stack.pop() || 0;
      const left = stack.pop() || 0;
      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
        }
        continue;
      }
      const m = left + right >> 1;
      const x2 = coords[2 * m];
      const y2 = coords[2 * m + 1];
      if (sqDist(x2, y2, qx, qy) <= r2) result.push(ids[m]);
      if (axis === 0 ? qx - r <= x2 : qy - r <= y2) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(1 - axis);
      }
      if (axis === 0 ? qx + r >= x2 : qy + r >= y2) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(1 - axis);
      }
    }
    return result;
  }
};
function sort(ids, coords, nodeSize, left, right, axis) {
  if (right - left <= nodeSize) return;
  const m = left + right >> 1;
  select(ids, coords, m, left, right, axis);
  sort(ids, coords, nodeSize, left, m - 1, 1 - axis);
  sort(ids, coords, nodeSize, m + 1, right, 1 - axis);
}
function select(ids, coords, k2, left, right, axis) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k2 - left + 1;
      const z2 = Math.log(n);
      const s = 0.5 * Math.exp(2 * z2 / 3);
      const sd = 0.5 * Math.sqrt(z2 * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k2 - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k2 + (n - m) * s / n + sd));
      select(ids, coords, k2, newLeft, newRight, axis);
    }
    const t = coords[2 * k2 + axis];
    let i = left;
    let j2 = right;
    swapItem(ids, coords, left, k2);
    if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);
    while (i < j2) {
      swapItem(ids, coords, i, j2);
      i++;
      j2--;
      while (coords[2 * i + axis] < t) i++;
      while (coords[2 * j2 + axis] > t) j2--;
    }
    if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j2);
    else {
      j2++;
      swapItem(ids, coords, j2, right);
    }
    if (j2 <= k2) left = j2 + 1;
    if (k2 <= j2) right = j2 - 1;
  }
}
function swapItem(ids, coords, i, j2) {
  swap(ids, i, j2);
  swap(coords, 2 * i, 2 * j2);
  swap(coords, 2 * i + 1, 2 * j2 + 1);
}
function swap(arr, i, j2) {
  const tmp = arr[i];
  arr[i] = arr[j2];
  arr[j2] = tmp;
}
function sqDist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}

// node_modules/geokdbush/node_modules/tinyqueue/index.js
var TinyQueue = class {
  constructor(data = [], compare = defaultCompare) {
    this.data = data;
    this.length = this.data.length;
    this.compare = compare;
    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
  }
  push(item) {
    this.data.push(item);
    this.length++;
    this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return void 0;
    const top = this.data[0];
    const bottom = this.data.pop();
    this.length--;
    if (this.length > 0) {
      this.data[0] = bottom;
      this._down(0);
    }
    return top;
  }
  peek() {
    return this.data[0];
  }
  _up(pos) {
    const { data, compare } = this;
    const item = data[pos];
    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current = data[parent];
      if (compare(item, current) >= 0) break;
      data[pos] = current;
      pos = parent;
    }
    data[pos] = item;
  }
  _down(pos) {
    const { data, compare } = this;
    const halfLength = this.length >> 1;
    const item = data[pos];
    while (pos < halfLength) {
      let left = (pos << 1) + 1;
      let best = data[left];
      const right = left + 1;
      if (right < this.length && compare(data[right], best) < 0) {
        left = right;
        best = data[right];
      }
      if (compare(best, item) >= 0) break;
      data[pos] = best;
      pos = left;
    }
    data[pos] = item;
  }
};
function defaultCompare(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
}

// node_modules/geokdbush/index.js
var earthRadius = 6371;
var rad = Math.PI / 180;
function around(index, lng, lat, maxResults = Infinity, maxDistance = Infinity, predicate) {
  let maxHaverSinDist = 1;
  const result = [];
  if (maxResults === void 0) maxResults = Infinity;
  if (maxDistance !== void 0) maxHaverSinDist = haverSin(maxDistance / earthRadius);
  const q2 = new TinyQueue([], compareDist);
  let node = {
    left: 0,
    // left index in the kd-tree array
    right: index.ids.length - 1,
    // right index
    axis: 0,
    // 0 for longitude axis and 1 for latitude axis
    dist: 0,
    // will hold the lower bound of children's distances to the query point
    minLng: -180,
    // bounding box of the node
    minLat: -90,
    maxLng: 180,
    maxLat: 90
  };
  const cosLat = Math.cos(lat * rad);
  while (node) {
    const right = node.right;
    const left = node.left;
    if (right - left <= index.nodeSize) {
      for (let i = left; i <= right; i++) {
        const id = index.ids[i];
        if (!predicate || predicate(id)) {
          const dist = haverSinDist(lng, lat, index.coords[2 * i], index.coords[2 * i + 1], cosLat);
          q2.push({ id, dist });
        }
      }
    } else {
      const m = left + right >> 1;
      const midLng = index.coords[2 * m];
      const midLat = index.coords[2 * m + 1];
      const id = index.ids[m];
      if (!predicate || predicate(id)) {
        const dist = haverSinDist(lng, lat, midLng, midLat, cosLat);
        q2.push({ id, dist });
      }
      const nextAxis = (node.axis + 1) % 2;
      const leftNode = {
        left,
        right: m - 1,
        axis: nextAxis,
        minLng: node.minLng,
        minLat: node.minLat,
        maxLng: node.axis === 0 ? midLng : node.maxLng,
        maxLat: node.axis === 1 ? midLat : node.maxLat,
        dist: 0
      };
      const rightNode = {
        left: m + 1,
        right,
        axis: nextAxis,
        minLng: node.axis === 0 ? midLng : node.minLng,
        minLat: node.axis === 1 ? midLat : node.minLat,
        maxLng: node.maxLng,
        maxLat: node.maxLat,
        dist: 0
      };
      leftNode.dist = boxDist(lng, lat, cosLat, leftNode);
      rightNode.dist = boxDist(lng, lat, cosLat, rightNode);
      q2.push(leftNode);
      q2.push(rightNode);
    }
    while (q2.length && q2.peek().id != null) {
      const candidate = q2.pop();
      if (candidate.dist > maxHaverSinDist) return result;
      result.push(candidate.id);
      if (result.length === maxResults) return result;
    }
    node = q2.pop();
  }
  return result;
}
function boxDist(lng, lat, cosLat, node) {
  const minLng = node.minLng;
  const maxLng = node.maxLng;
  const minLat = node.minLat;
  const maxLat = node.maxLat;
  if (lng >= minLng && lng <= maxLng) {
    if (lat < minLat) return haverSin((lat - minLat) * rad);
    if (lat > maxLat) return haverSin((lat - maxLat) * rad);
    return 0;
  }
  const haverSinDLng = Math.min(haverSin((lng - minLng) * rad), haverSin((lng - maxLng) * rad));
  const extremumLat = vertexLat(lat, haverSinDLng);
  if (extremumLat > minLat && extremumLat < maxLat) {
    return haverSinDistPartial(haverSinDLng, cosLat, lat, extremumLat);
  }
  return Math.min(
    haverSinDistPartial(haverSinDLng, cosLat, lat, minLat),
    haverSinDistPartial(haverSinDLng, cosLat, lat, maxLat)
  );
}
function compareDist(a, b2) {
  return a.dist - b2.dist;
}
function haverSin(theta) {
  const s = Math.sin(theta / 2);
  return s * s;
}
function haverSinDistPartial(haverSinDLng, cosLat1, lat1, lat2) {
  return cosLat1 * Math.cos(lat2 * rad) * haverSinDLng + haverSin((lat1 - lat2) * rad);
}
function haverSinDist(lng1, lat1, lng2, lat2, cosLat1) {
  const haverSinDLng = haverSin((lng1 - lng2) * rad);
  return haverSinDistPartial(haverSinDLng, cosLat1, lat1, lat2);
}
function vertexLat(lat, haverSinDLng) {
  const cosDLng = 1 - 2 * haverSinDLng;
  if (cosDLng <= 0) return lat > 0 ? 90 : -90;
  return Math.atan(Math.tan(lat * rad) / cosDLng) / rad;
}

// node_modules/weatherlayers-gl/dist/weatherlayers-deck.min.js
var y = "2025.8.0";
var b = "2025-08-08T06:36:22.687Z";
var w = /* @__PURE__ */ new Map();
function x(e, t) {
  w.set(e, t);
}
var T = { INWARD: "INWARD", OUTWARD: "OUTWARD" };
var M = { VALUE: "VALUE", CARDINAL: "CARDINAL", CARDINAL2: "CARDINAL2", CARDINAL3: "CARDINAL3" };
var P = { [M.CARDINAL]: ["N", "E", "S", "W"], [M.CARDINAL2]: ["N", "NE", "E", "SE", "S", "SW", "W", "NW"], [M.CARDINAL3]: ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"] };
function D(e, t) {
  if (!t) return `${Math.round(e)}`;
  const { scale: n = 1, offset: a = 0, decimals: i = 0 } = t, o = n * e + a;
  return `${i ? Math.round(o * 10 ** i) / 10 ** i : Math.round(o)}`;
}
function O(e) {
  return e.unit.replace("^2", "").replace("^3", "");
}
function S(e, t) {
  return `${D(e, t)}${O(t)}`;
}
function V(e, t, n) {
  if (t === T.OUTWARD && (e += 180), n === M.VALUE) return `${Math.round(e % 360)}`;
  if (n === M.CARDINAL || n === M.CARDINAL2 || n === M.CARDINAL3) {
    const t2 = P[n], a = 360 / t2.length;
    return t2[Math.floor((e % 360 + a / 2) / a) % t2.length];
  }
  throw new Error("Invalid state");
}
var U = 1;
var N = [255, 255, 255];
var L = '"Helvetica Neue", Arial, Helvetica, sans-serif';
var F = 12;
var k = [255, 255, 255];
var Z = 1;
var J = [13, 13, 13];
var R = D;
var W = 40;
var q = [255, 255, 255];
function X(e, t) {
  const n = {};
  for (const a in e) if (void 0 === e[a] && a in t) {
    const e2 = t[a];
    e2 && ("value" in e2 ? e2.value && (n[a] = e2.value) : n[a] = e2);
  }
  return Object.freeze({ ...e, ...n });
}
var K = class {
  constructor(e) {
    this._running = false, this._raf = void 0, this._lastFrameTime = 0, this._config = e;
  }
  getConfig() {
    return { ...this._config };
  }
  setConfig(e) {
    this._config = e;
  }
  updateConfig(e) {
    this.setConfig({ ...this._config, ...e });
  }
  get running() {
    return this._running;
  }
  toggle(e = !this._running) {
    e ? this.start() : this.stop();
  }
  start() {
    this._running || (this._running = true, this._raf = window.requestAnimationFrame((() => this.step())));
  }
  stop() {
    this._running && (this._running = false, this._raf && (window.cancelAnimationFrame(this._raf), this._raf = void 0));
  }
  step() {
    const e = 1e3 / (this._config.fps ?? 30), t = Date.now(), n = t - this._lastFrameTime;
    n > e && (this._lastFrameTime = t - n % e, this._config.onUpdate()), this._running && (this._raf = window.requestAnimationFrame((() => this.step())));
  }
};
var G = /* @__PURE__ */ new Map();
var z = new class {
  constructor() {
    this.queue = Promise.resolve();
  }
  async run(e) {
    const t = this.queue;
    let n;
    this.queue = new Promise(((e2) => {
      n = e2;
    }));
    try {
      return await t, await e();
    } finally {
      n();
    }
  }
}();
async function j(e, t) {
  const n = await (async function(e2) {
    if (w.has(e2)) return w.get(e2);
    try {
      if ("geotiff" === e2) return await import("./geotiff-26IVMNB7.js");
    } catch (t2) {
      throw new Error(`Optional dependency '${e2}' is missing, install it with a package manager or provide with \`setLibrary('${e2}', library)\``, { cause: t2 });
    }
  })("geotiff");
  let a;
  try {
    a = await n.fromUrl(e, { allowFullFile: true, blockSize: Number.MAX_SAFE_INTEGER, fetch: (e2, n2) => fetch(e2, { ...n2, headers: { ...n2?.headers, ...t?.headers } }) });
  } catch (t2) {
    throw new Error(`Image ${e} can't be decoded.`, { cause: t2 });
  }
  const i = await a.getImage(0), o = await i.readRasters({ interleave: true });
  if (!(o instanceof Uint8Array || o instanceof Uint8ClampedArray || o instanceof Float32Array)) throw new Error("Unsupported data format");
  const r = (function(e2, t2) {
    if (null == t2) return e2;
    const n2 = e2.slice(0);
    for (let e3 = 0; e3 < n2.length; e3++) Math.abs(n2[e3] - t2) < 2 * Number.EPSILON && (n2[e3] = NaN);
    return n2;
  })(o, i.getGDALNoData());
  return { data: r, width: i.getWidth(), height: i.getHeight() };
}
function Y(e) {
  return async (t, n) => {
    if (false === n?.cache) return e(t);
    const a = n?.cache ?? G, i = t + (n?.headers ? ":" + JSON.stringify(n?.headers) : ""), o = a.get(i);
    if (o) return o;
    const r = { ...n, cache: void 0 }, A2 = e(t, r);
    return a.set(i, A2), A2.then(((e2) => {
      a.set(i, e2);
    })), A2;
  };
}
var _ = Y((async (e, t) => {
  if (e.includes(".png") || e.includes(".webp") || e.includes("image/png") || e.includes("image/webp")) return (async function(e2, t2) {
    let n;
    if (t2?.headers) {
      const a2 = await fetch(e2, { headers: t2.headers });
      if (!a2.ok) throw new Error(`URL ${e2} can't be loaded. Status: ${a2.status}`);
      const i2 = await a2.blob();
      n = URL.createObjectURL(i2);
    }
    const a = new Image();
    try {
      await new Promise(((t3, i2) => {
        a.addEventListener("load", t3), a.addEventListener("error", i2), a.crossOrigin = "anonymous", a.src = n ?? e2;
      }));
    } catch (t3) {
      throw new Error(`URL ${e2} can't be loaded.`, { cause: t3 });
    } finally {
      n && URL.revokeObjectURL(n);
    }
    try {
      await z.run((() => a.decode()));
    } catch (t3) {
      throw new Error(`Image ${e2} can't be decoded.`, { cause: t3 });
    }
    const i = document.createElement("canvas");
    i.width = a.width, i.height = a.height;
    const o = i.getContext("2d");
    o.drawImage(a, 0, 0);
    const r = o.getImageData(0, 0, i.width, i.height), { data: A2, width: s, height: l } = r;
    return { data: A2, width: s, height: l };
  })(e, t);
  if (e.includes(".tif") || e.includes("image/tif")) return j(e, t);
  throw new Error("Unsupported data format");
}));
var H = Y((async (e, t) => {
  const n = await fetch(e, { headers: t?.headers });
  if (!n.ok) throw new Error(`URL ${e} can't be loaded. Status: ${n.status}`);
  return n.json();
}));
function $(e, t, n) {
  if (!t) {
    if (0 === n) return e;
    throw new Error("Invalid state");
  }
  if (n <= 0) return e;
  if (n >= 1) return t;
  {
    const a = new Date(e), i = new Date(t);
    return new Date(a.getTime() + (i.getTime() - a.getTime()) * n).toISOString();
  }
}
function ee(e, t, n) {
  if (!t) {
    if (e === n) return 0;
    throw new Error("Invalid state");
  }
  if (n <= e) return 0;
  if (n >= t) return 1;
  {
    const a = new Date(e), i = new Date(t);
    return (new Date(n).getTime() - a.getTime()) / (i.getTime() - a.getTime());
  }
}
function te(e, t) {
  return [...e].reverse().find(((e2) => e2 <= t));
}
function ne(e, t) {
  return e.find(((e2) => e2 >= t));
}
function ae(e, t) {
  const n = new Date(e);
  return new Date(n.getTime() + 1e3 * t * 60 * 60).toISOString();
}
function ie(e, t, n) {
  return [ae(e, t), ae(e, n)];
}
function oe(e) {
  if (!e) return e;
  const t = new Date(e);
  if (!t.getDate()) return e;
  return `${t.getUTCFullYear()}/${`${t.getUTCMonth() + 1}`.padStart(2, "0")}/${`${t.getUTCDate()}`.padStart(2, "0")} ${`${t.getUTCHours()}`.padStart(2, "0")}:${`${t.getUTCMinutes()}`.padStart(2, "0")}UTC`;
}
var re = { NEAREST: "NEAREST", LINEAR: "LINEAR", CUBIC: "CUBIC" };
var Ae = { SCALAR: "SCALAR", VECTOR: "VECTOR" };
var se = { METRIC: "METRIC", METRIC_KILOMETERS: "METRIC_KILOMETERS", IMPERIAL: "IMPERIAL", NAUTICAL: "NAUTICAL" };
var le = { BOTTOM: "BOTTOM", TOP: "TOP", RIGHT: "RIGHT", LEFT: "LEFT" };
function ce(e) {
  return e % 1;
}
function ge(e, t) {
  return e.map(((n, a) => e[a] + t[a]));
}
function ue(e, t) {
  return e.map(((n, a) => e[a] * t));
}
function pe(e, t) {
  return e.map(((n, a) => e[a] * t[a])).reduce(((e2, t2) => e2 + t2));
}
function de(e, t, n) {
  return e === t ? e : e * (1 - n) + t * n;
}
function he(e, t, n) {
  return e.map(((a, i) => de(e[i], t[i], n)));
}
function me(e, t) {
  return t ? e[3] >= 255 : !isNaN(e[0]);
}
function Ce(e, t, n) {
  return t === Ae.VECTOR ? n ? [de(n[0], n[1], e[0] / 255), de(n[0], n[1], e[1] / 255)] : [e[0], e[1]] : [NaN, NaN];
}
function ve(e, t, n) {
  if (t === Ae.VECTOR) {
    const a = Ce(e, t, n);
    return Math.hypot(a[0], a[1]);
  }
  return (function(e2, t2, n2) {
    return t2 === Ae.VECTOR ? 0 : n2 ? de(n2[0], n2[1], e2[0] / 255) : e2[0];
  })(e, t, n);
}
function fe(e, t, n, a, i, o) {
  const { data: r, width: A2, height: s } = e, l = r.length / (A2 * s), c = (n + i + 0.5) / t[0], g = (a + o + 0.5) / t[1], u = Math.max(0, Math.min(A2 - 1, Math.floor(c * A2))), p = Math.max(0, Math.min(s - 1, Math.floor(g * s)));
  return new Array(l).fill(void 0).map(((e2, t2) => r[(u + p * A2) * l + t2]));
}
var Ie = [3, -6, 0, 4].map(((e) => e / 6));
var Ee = [-1, 6, -12, 8].map(((e) => e / 6));
function Be(e) {
  return [e * e * e, e * e, e, 1];
}
function Qe(e, t, n, a, i) {
  const o = ge(ge(ge(ue(e, pe(Ee, Be(i + 1))), ue(t, pe(Ie, Be(i)))), ue(n, pe(Ie, Be(1 - i)))), ue(a, pe(Ee, Be(2 - i))));
  return o[3] = e[3] > 0 && t[3] > 0 && n[3] > 0 && a[3] > 0 ? Math.max(Math.max(Math.max(e[3], t[3]), n[3]), a[3]) : 0, o;
}
function ye(e, t, n, a, i) {
  return n === re.CUBIC ? (function(e2, t2, n2, a2) {
    const i2 = n2 * t2[0] - 0.5, o = a2 * t2[1] - 0.5, r = Math.floor(i2), A2 = Math.floor(o), s = ce(i2), l = ce(o);
    return Qe(Qe(fe(e2, t2, r, A2, -1, -1), fe(e2, t2, r, A2, 0, -1), fe(e2, t2, r, A2, 1, -1), fe(e2, t2, r, A2, 2, -1), s), Qe(fe(e2, t2, r, A2, -1, 0), fe(e2, t2, r, A2, 0, 0), fe(e2, t2, r, A2, 1, 0), fe(e2, t2, r, A2, 2, 0), s), Qe(fe(e2, t2, r, A2, -1, 1), fe(e2, t2, r, A2, 0, 1), fe(e2, t2, r, A2, 1, 1), fe(e2, t2, r, A2, 2, 1), s), Qe(fe(e2, t2, r, A2, -1, 2), fe(e2, t2, r, A2, 0, 2), fe(e2, t2, r, A2, 1, 2), fe(e2, t2, r, A2, 2, 2), s), l);
  })(e, t, a, i) : n === re.LINEAR ? (function(e2, t2, n2, a2) {
    const i2 = n2 * t2[0] - 0.5, o = a2 * t2[1] - 0.5, r = Math.floor(i2), A2 = Math.floor(o), s = ce(i2), l = ce(o);
    return he(he(fe(e2, t2, r, A2, 0, 0), fe(e2, t2, r, A2, 1, 0), s), he(fe(e2, t2, r, A2, 0, 1), fe(e2, t2, r, A2, 1, 1), s), l);
  })(e, t, a, i) : (function(e2, t2, n2, a2) {
    const i2 = n2 * t2[0] - 0.5, o = a2 * t2[1] - 0.5;
    return fe(e2, t2, Math.round(i2), Math.round(o), 0, 0);
  })(e, t, a, i);
}
function be(e, t, n, a, i, o, r, A2) {
  const s = o ? r + 0.5 / n[0] : de(0 + 0.5 / n[0], 1 - 0.5 / n[0], r), l = de(0 + 0.5 / n[1], 1 - 0.5 / n[1], A2);
  if (t && i > 0) {
    return he(ye(e, n, a, s, l), ye(t, n, a, s, l), i);
  }
  return ye(e, n, a, s, l);
}
function we(e, t, n) {
  const a = 1 + Math.max(0, n);
  return [e / a, t / a];
}
var xe = -180;
var Te = 180;
var Me = -85.051129;
var Pe = 85.051129;
var De = [xe, Me, Te, Pe];
function Oe(e, t) {
  let n = ((e + 180) % (a = 360) + a) % a - 180;
  var a;
  return "number" == typeof t && n < t && (n += 360), n;
}
function Se(e) {
  return e[2] - e[0] == 360;
}
function Ve(e, t) {
  return e[0] >= t[0] && e[0] <= t[2] && e[1] >= t[1] && e[1] <= t[3];
}
function Ue(e, t) {
  return { type: "Feature", geometry: { type: "Point", coordinates: e }, properties: t };
}
function Ne(e, t, n) {
  const { image: a, image2: i, imageSmoothing: o, imageInterpolation: r, imageWeight: A2, imageType: s, imageUnscale: l, imageMinValue: c, imageMaxValue: g } = e, { width: u, height: p } = a, d = (function(e2, t2, n2) {
    const a2 = [n2[0], n2[3]], i2 = (n2[2] - n2[0]) / e2, o2 = (n2[3] - n2[1]) / t2;
    return (e3) => {
      const [t3, n3] = e3;
      return [(t3 - a2[0]) / i2, (a2[1] - n3) / o2];
    };
  })(u, p, t), h = we(u, p, o), m = Se(t), C = n.map(((e2) => {
    if (!Ve(e2, t)) return Ue(e2, { value: NaN });
    const n2 = d(e2), o2 = n2[0] / u, C2 = n2[1] / p, v = be(a, i, h, r, A2, m, o2, C2);
    if (!me(v, l)) return Ue(e2, { value: NaN });
    const f = ve(v, s, l);
    if ("number" == typeof c && !isNaN(c) && f < c || "number" == typeof g && !isNaN(g) && f > g) return Ue(e2, { value: NaN });
    if (s === Ae.VECTOR) {
      const t2 = (function(e3, t3, n3) {
        if (t3 === Ae.VECTOR) {
          const a2 = Ce(e3, t3, n3);
          return (360 - (Math.atan2(a2[1], a2[0]) / Math.PI * 180 + 180) - 270) % 360;
        }
        return NaN;
      })(v, s, l);
      return Ue(e2, { value: f, direction: t2 });
    }
    return Ue(e2, { value: f });
  }));
  return { type: "FeatureCollection", features: C };
}
function Le(e, t) {
  const { image: n, image2: a, imageSmoothing: i, imageInterpolation: o, imageWeight: r, imageType: A2, imageUnscale: s, imageMinValue: l, imageMaxValue: c } = e, { width: g, height: u } = n, p = o !== re.NEAREST ? re.NEAREST : o, d = we(g, u, i), h = Se(t), m = new Float32Array(g * u);
  for (let e2 = 0; e2 < u; e2++) for (let t2 = 0; t2 < g; t2++) {
    const i2 = t2 + e2 * g, o2 = be(n, a, d, p, r, h, t2 / g, e2 / u);
    if (!me(o2, s)) {
      m[i2] = NaN;
      continue;
    }
    const C = ve(o2, A2, s);
    "number" == typeof l && !isNaN(l) && C < l || "number" == typeof c && !isNaN(c) && C > c ? m[i2] = NaN : m[i2] = C;
  }
  return { data: m, width: g, height: u };
}
var Fe = 6370972;
function ke(e, t) {
  return distance(e, t, Fe);
}
function Ze(e, t, n) {
  return destinationPoint(e, t, n, Fe);
}
function Je(e) {
  return !!e.resolution;
}
function Re(e) {
  return !Je(e);
}
function We(e, t, n) {
  return !(null != t && e.zoom < t) && !(null != n && e.zoom > n);
}
function qe(e) {
  return [e.longitude, e.latitude];
}
function Xe(e) {
  const t = qe(e);
  return Math.max(ke(t, e.unproject([e.width / 2, 0])), ke(t, e.unproject([0, e.height / 2])), ...e.width > e.height ? [ke(t, e.unproject([e.width / 2 - e.height / 4 * 1, e.height / 2])), ke(t, e.unproject([e.width / 2 - e.height / 2 * 1, e.height / 2])), ke(t, e.unproject([e.width / 2 - e.height / 4 * 3, e.height / 2])), ke(t, e.unproject([e.width / 2 - e.height, e.height / 2]))] : [ke(t, e.unproject([e.width / 2, e.height / 2 - e.width / 4 * 1])), ke(t, e.unproject([e.width / 2, e.height / 2 - e.width / 2 * 1])), ke(t, e.unproject([e.width / 2, e.height / 2 - e.width / 4 * 3])), ke(t, e.unproject([e.width / 2, e.height / 2 - e.width]))]);
}
function Ke(e) {
  return (function(e2) {
    const t = e2[2] - e2[0] < 360 ? Oe(e2[0]) : xe, n = e2[2] - e2[0] < 360 ? Oe(e2[2], t) : Te;
    return [t, Math.max(e2[1], Me), n, Math.min(e2[3], Pe)];
  })(e.getBounds());
}
function Ge(e) {
  return Je(e) ? Math.log2(e.scale) : e.zoom;
}
function ze(e, t) {
  return t * (Je(e) ? -1 : 1);
}
function je(e, t) {
  return t + (Je(e) ? 180 : 0);
}
var Ye = /* @__PURE__ */ new WeakMap();
var _e = /* @__PURE__ */ new WeakMap();
function He(e, t, n = false) {
  const a = n ? Ye : _e, i = a.get(e) ?? (() => {
    const t2 = /* @__PURE__ */ new WeakMap();
    return a.set(e, t2), t2;
  })(), o = i.get(t) ?? (() => {
    const a2 = (function(e2, t2, n2) {
      const { data: a3, width: i2, height: o3 } = t2, r = a3.length / (i2 * o3);
      let A2;
      if (a3 instanceof Uint8Array || a3 instanceof Uint8ClampedArray) if (4 === r) A2 = "rgba8unorm";
      else if (2 === r) A2 = "rg8unorm";
      else {
        if (1 !== r) throw new Error("Unsupported data format");
        A2 = "r8unorm";
      }
      else {
        if (!(a3 instanceof Float32Array)) throw new Error("Unsupported data format");
        if (!e2.features.has("float32-renderable-webgl")) throw new Error("Float textures are required");
        if (2 === r) A2 = "rg32float";
        else {
          if (1 !== r) throw new Error("Unsupported data format");
          A2 = "r32float";
        }
      }
      return { data: a3, width: i2, height: o3, format: A2, mipmaps: false, sampler: { magFilter: "nearest", minFilter: "nearest", addressModeU: n2 ? "repeat" : "clamp-to-edge", addressModeV: "clamp-to-edge", lodMaxClamp: 0 } };
    })(e, t, n), o2 = e.createTexture(a2);
    return i.set(t, o2), o2;
  })();
  return o;
}
var $e = null;
function et(e) {
  return $e || ($e = e.createTexture({ data: new Uint8Array(4), width: 1, height: 1, mipmaps: false })), $e;
}
function tt(t, n) {
  const a = n.domain(), i = [a[0], a[a.length - 1]], o = colorRampCanvas(n);
  return { paletteBounds: i, paletteTexture: t.createTexture({ data: o, sampler: { magFilter: "linear", minFilter: "linear", addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" } }) };
}
function nt(e) {
  return [e[0] / 255, e[1] / 255, e[2] / 255, (e[3] ?? 255) / 255];
}
function at(e) {
  return [e[0], e[1], e[2], 255 * e[3]];
}
var it = "uniform bitmap2Uniforms{vec4 A;bool B;float C;vec4 D;}bitmap2;const float E=512.;const float F=3.1415926536;const float G=E/F/2.;vec2 H(vec2 I){float J=I.x;float K=clamp(I.y,-89.9,89.9);return vec2(radians(J)+F,F+log(tan(F*0.25+radians(K)*0.5)))*G;}vec2 L(vec2 M){M/=G;return degrees(vec2(M.x-F,atan(exp(M.y-F))*2.-F*0.5));}vec4 N(vec3 O,float P){return mix(bitmap2.D,vec4(O,1.),P);}vec2 Q(vec2 R){return vec2((R.x-bitmap2.A[0])/(bitmap2.A[2]-bitmap2.A[0]),(R.y-bitmap2.A[3])/(bitmap2.A[1]-bitmap2.A[3]));}vec2 S(vec2 T,vec2 U){vec2 uv=T;if(bitmap2.C<-0.5){vec2 I=L(U);uv=Q(I);}else if(bitmap2.C>0.5){vec2 V=H(U);uv=Q(V);}return uv;}";
var ot = "A";
var rt = "B";
var At = "C";
var st = "D";
var lt = Math.PI;
var ct = lt / 4;
var gt = lt / 180;
var ut = 512;
function pt(e) {
  const [t, n] = e, a = n * gt;
  return [ut * (t * gt + lt) / (2 * lt), ut * (lt + Math.log(Math.tan(ct + 0.5 * a))) / (2 * lt)];
}
function dt(e = {}) {
  const { LNGLAT: t, CARTESIAN: a, DEFAULT: i } = COORDINATE_SYSTEM;
  let { viewportGlobe: o, bounds: r, _imageCoordinateSystem: A2 } = e;
  if (!(function(e2) {
    return Number.isFinite(e2[0]);
  })(r)) throw new Error("_imageCoordinateSystem only supports rectangular bounds");
  if (A2 !== i) {
    const e2 = o ? t : a;
    if (A2 = A2 === t ? t : a, A2 === t && e2 === a) return { coordinateConversion: -1, bounds: r };
    if (A2 === a && e2 === t) {
      const e3 = pt([r[0], r[1]]), t2 = pt([r[2], r[3]]);
      return { coordinateConversion: 1, bounds: [e3[0], e3[1], t2[0], t2[1]] };
    }
  }
  return { coordinateConversion: 0, bounds: r };
}
var ht = { name: "bitmap2", vs: it, fs: it, uniformTypes: { [ot]: "vec4<f32>", [rt]: "f32", [At]: "f32", [st]: "vec4<f32>" }, getUniforms: function(e = {}) {
  const { bounds: t, coordinateConversion: n } = dt(e);
  return { [ot]: t, [rt]: Se(t) ? 1 : 0, [At]: n, [st]: e.transparentColor ? nt(e.transparentColor) : [0, 0, 0, 0] };
} };
var mt = "uniform sampler2D W;uniform sampler2D X;uniform rasterUniforms{vec2 Y;float Z;float a;float b;float c;vec2 d;float e;float f;}raster;";
var Ct = "W";
var vt = "X";
var ft = "Y";
var It = "Z";
var Et = "a";
var Bt = "b";
var Qt = "c";
var yt = "d";
var bt = "e";
var wt = "f";
var xt = { name: "raster", vs: mt, fs: mt, uniformTypes: { [ft]: "vec2<f32>", [It]: "f32", [Et]: "f32", [Bt]: "f32", [Qt]: "f32", [yt]: "vec2<f32>", [bt]: "f32", [wt]: "f32" }, getUniforms: function(e = {}) {
  return { [Ct]: e.imageTexture, [vt]: e.imageTexture2, [ft]: e.imageTexture ? [e.imageTexture.width, e.imageTexture.height] : [0, 0], [It]: e.imageSmoothing ?? 0, [Et]: Object.values(re).indexOf(e.imageInterpolation ?? re.NEAREST), [Bt]: e.imageTexture2 !== e.imageTexture && e.imageWeight ? e.imageWeight : 0, [Qt]: Object.values(Ae).indexOf(e.imageType ?? Ae.SCALAR), [yt]: e.imageUnscale ?? [0, 0], [bt]: e.imageMinValue ?? Number.MIN_SAFE_INTEGER, [wt]: e.imageMaxValue ?? Number.MAX_SAFE_INTEGER };
} };
var Tt = "uniform sampler2D g;uniform paletteUniforms{vec2 h;vec4 i;}palette;float j(float min,float max,float k){return(k-min)/(max-min);}vec4 l(sampler2D g,vec2 h,vec4 i,float k){if(h[0]<h[1]){float m=j(h[0],h[1],k);return texture(g,vec2(m,0.));}else{return i;}}";
var Mt = "g";
var Pt = "h";
var Dt = "i";
var Ot = { name: "palette", vs: Tt, fs: Tt, uniformTypes: { [Pt]: "vec2<f32>", [Dt]: "vec4<f32>" }, getUniforms: function(e = {}) {
  return { [Mt]: e.paletteTexture, [Pt]: e.paletteBounds ?? [0, 0], [Dt]: e.paletteColor ? nt(e.paletteColor) : [0, 0, 0, 0] };
} };
var St = { imageTexture: { type: "object", value: null }, imageTexture2: { type: "object", value: null }, imageSmoothing: { type: "number", value: 0 }, imageInterpolation: { type: "object", value: re.CUBIC }, imageWeight: { type: "number", value: 0 }, imageType: { type: "object", value: Ae.SCALAR }, imageUnscale: { type: "array", value: null }, imageMinValue: { type: "object", value: null }, imageMaxValue: { type: "object", value: null }, bounds: { type: "array", value: [-180, -90, 180, 90], compare: true }, minZoom: { type: "object", value: null }, maxZoom: { type: "object", value: null }, palette: { type: "object", value: null } };
var Vt = class extends bitmap_layer_default {
  getShaders() {
    const e = super.getShaders();
    return { ...e, fs: "#version 300 es\n#define SHADER_NAME  raster-bitmap-layer-fragment-shader\n#ifdef GL_ES\nprecision highp float;\n#endif\nvec4 AA(sampler2D AB,vec2 AC,vec2 AD,vec2 AE){vec2 uv=(AD+AE+0.5)/AC;return texture(AB,uv);}const vec4 AF=vec4(3.,-6.,0.,4.)/6.;const vec4 AG=vec4(-1.,6.,-12.,8.)/6.;vec4 AH(float J){return vec4(J*J*J,J*J,J,1.);}vec4 AI(vec4 AJ,vec4 AK,vec4 AL,vec4 AM,float AN){vec4 O=AJ*dot(AG,AH(AN+1.))+AK*dot(AF,AH(AN))+AL*dot(AF,AH(1.-AN))+AM*dot(AG,AH(2.-AN));O.a=(AJ.a>0.&&AK.a>0.&&AL.a>0.&&AM.a>0.)?max(max(max(AJ.a,AK.a),AL.a),AM.a):0.;return O;}vec4 AO(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP);vec2 AQ=fract(AP);return AI(AI(AA(AB,AC,AD,vec2(-1,-1)),AA(AB,AC,AD,vec2(0,-1)),AA(AB,AC,AD,vec2(1,-1)),AA(AB,AC,AD,vec2(2,-1)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,0)),AA(AB,AC,AD,vec2(0,0)),AA(AB,AC,AD,vec2(1,0)),AA(AB,AC,AD,vec2(2,0)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,1)),AA(AB,AC,AD,vec2(0,1)),AA(AB,AC,AD,vec2(1,1)),AA(AB,AC,AD,vec2(2,1)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,2)),AA(AB,AC,AD,vec2(0,2)),AA(AB,AC,AD,vec2(1,2)),AA(AB,AC,AD,vec2(2,2)),AQ.x),AQ.y);}vec4 AR(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP);vec2 AQ=fract(AP);return mix(mix(AA(AB,AC,AD,vec2(0,0)),AA(AB,AC,AD,vec2(1,0)),AQ.x),mix(AA(AB,AC,AD,vec2(0,1)),AA(AB,AC,AD,vec2(1,1)),AQ.x),AQ.y);}vec4 AS(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP+0.5);return AA(AB,AC,AD,vec2(0,0));}vec4 AT(sampler2D AB,vec2 AC,float a,vec2 uv){if(a==2.){return AO(AB,AC,uv);}if(a==1.){return AR(AB,AC,uv);}else{return AS(AB,AC,uv);}}vec4 AU(sampler2D AB,sampler2D AV,vec2 AC,float a,float b,bool B,vec2 uv){vec2 AW;AW.x=B?uv.x+0.5/AC.x:mix(0.+0.5/AC.x,1.-0.5/AC.x,uv.x);AW.y=mix(0.+0.5/AC.y,1.-0.5/AC.y,uv.y);if(b>0.){vec4 AX=AT(AB,AC,a,AW);vec4 AY=AT(AV,AC,a,AW);return mix(AX,AY,b);}else{return AT(AB,AC,a,AW);}}vec4 AZ(sampler2D AB,sampler2D AV,vec2 Y,float Z,float a,float b,bool B,vec2 uv){float Aa=1.+max(0.,Z);vec2 AC=Y/Aa;return AU(AB,AV,AC,a,b,B,uv);}float Ab(float K,float J){return J==0.?sign(K)*F/2.:atan(K,J);}bool Ac(float k){uint Ad=floatBitsToUint(k);return(Ad&0x7fffffffu)>0x7f800000u;}bool Ae(vec4 AX,vec2 d){if(d[0]<d[1]){return AX.a>=1.;}else{return!Ac(AX.x);}}float Af(vec4 AX,float c,vec2 d){if(c==1.){return 0.;}else{if(d[0]<d[1]){return mix(d[0],d[1],AX.x);}else{return AX.x;}}}vec2 Ag(vec4 AX,float c,vec2 d){if(c==1.){if(d[0]<d[1]){return mix(vec2(d[0]),vec2(d[1]),AX.xy);}else{return AX.xy;}}else{return vec2(0.);}}float Ah(vec4 AX,float c,vec2 d){if(c==1.){vec2 k=Ag(AX,c,d);return length(k);}else{return Af(AX,c,d);}}float Ai(vec4 AX,float c,vec2 d){if(c==1.){vec2 k=Ag(AX,c,d);return mod((360.-(Ab(k.y,k.x)/F*180.+180.))-270.,360.)/360.;}else{return 0.;}}in vec2 vTexCoord;in vec2 vTexPos;out vec4 fragColor;void main(void){vec2 uv=S(vTexCoord,vTexPos);vec4 AX=AZ(W,X,raster.Y,raster.Z,raster.a,raster.b,bitmap2.B,uv);if(!Ae(AX,raster.d)){discard;}float k=Ah(AX,raster.c,raster.d);if((!Ac(raster.e)&&k<raster.e)||(!Ac(raster.f)&&k>raster.f)){discard;}vec4 Aj=l(g,palette.h,palette.i,k);fragColor=N(Aj.rgb,Aj.a*layer.opacity);geometry.uv=uv;DECKGL_FILTER_COLOR(fragColor,geometry);if(bool(picking.isActive)&&!bool(picking.isAttribute)){float m=j(palette.h[0],palette.h[1],k);float Ak=Ai(AX,raster.c,raster.d);fragColor=vec4(m,Ak,0,1);}}", modules: [...e.modules, ht, xt, Ot] };
  }
  updateState(e) {
    const { palette: t } = e.props;
    super.updateState(e), t !== e.oldProps.palette && this._updatePalette();
  }
  draw(e) {
    const { device: t, viewport: n } = this.context, { model: a } = this.state, { imageTexture: i, imageTexture2: o, imageSmoothing: r, imageInterpolation: A2, imageWeight: s, imageType: l, imageUnscale: c, imageMinValue: g, imageMaxValue: u, bounds: p, _imageCoordinateSystem: d, transparentColor: h, minZoom: m, maxZoom: C } = X(this.props, St), { paletteTexture: v, paletteBounds: f } = this.state;
    if (!i) return;
    const I = Je(n);
    a && We(n, m, C) && (a.shaderInputs.setProps({ [ht.name]: { viewportGlobe: I, bounds: p, _imageCoordinateSystem: d, transparentColor: h }, [xt.name]: { imageTexture: i ?? et(t), imageTexture2: o ?? et(t), imageSmoothing: r, imageInterpolation: A2, imageWeight: s, imageType: l, imageUnscale: c, imageMinValue: g, imageMaxValue: u }, [Ot.name]: { paletteTexture: v ?? et(t), paletteBounds: f } }), a.setParameters({ ...a.parameters, cullMode: "back", depthCompare: "always", ...this.props.parameters }), this.props.image = i, super.draw(e), this.props.image = null);
  }
  _updatePalette() {
    const { device: e } = this.context, { palette: n } = X(this.props, St);
    if (!n) return void this.setState({ paletteTexture: void 0, paletteBounds: void 0 });
    const a = parsePalette(n), { paletteBounds: i, paletteTexture: o } = tt(e, a);
    this.setState({ paletteTexture: o, paletteBounds: i });
  }
  _getRasterMagnitudeValue(e, t) {
    return t[0] + e[0] / 255 * (t[1] - t[0]);
  }
  _getRasterDirectionValue(e) {
    const { imageType: t } = X(this.props, St);
    return t === Ae.VECTOR ? e[1] / 255 * 360 : NaN;
  }
  getPickingInfo(e) {
    const t = super.getPickingInfo(e), { imageType: n } = X(this.props, St), { paletteBounds: a } = this.state;
    if (!t.color) return t;
    let i;
    const o = this._getRasterMagnitudeValue(t.color, a ?? [0, 0]);
    if (n === Ae.VECTOR) {
      i = { value: o, direction: this._getRasterDirectionValue(t.color) };
    } else i = { value: o };
    return t.raster = i, t;
  }
};
Vt.layerName = "RasterBitmapLayer", Vt.defaultProps = St;
var Ut = { ...Vt.defaultProps, imageTexture: void 0, imageTexture2: void 0, image: { type: "object", value: null }, image2: { type: "object", value: null }, bounds: { type: "array", value: [-180, -90, 180, 90], compare: true }, gridEnabled: { type: "boolean", value: false } };
var Nt = class extends composite_layer_default {
  renderLayers() {
    const { device: e } = this.context, { props: t, imageTexture: a, imageTexture2: i } = this.state;
    if (!t || !a) return [];
    const { gridEnabled: r } = X(t, Ut);
    let A2;
    if (r) {
      const { positions: e2 } = this.state;
      A2 = new scatterplot_layer_default({ data: e2, getPosition: (e3) => e3, getRadius: 1, getFillColor: [255, 255, 255], radiusUnits: "pixels", opacity: 0.2, parameters: { depthCompare: "always", ...this.props.parameters } });
    }
    return [new Vt(this.props, this.getSubLayerProps({ id: "bitmap", imageTexture: a, imageTexture2: i, _imageCoordinateSystem: COORDINATE_SYSTEM.LNGLAT, image: et(e), image2: et(e) })), ...A2 ? [A2] : []];
  }
  updateState(e) {
    const { image: t, image2: n, imageUnscale: a, bounds: i, gridEnabled: o } = e.props;
    if (super.updateState(e), t && a && !(t.data instanceof Uint8Array || t.data instanceof Uint8ClampedArray)) throw new Error("imageUnscale can be applied to Uint8 data only");
    if (t !== e.oldProps.image || n !== e.oldProps.image2) {
      const { device: e2 } = this.context, { image: t2, image2: n2 } = this.props, a2 = t2 ? He(e2, t2, Se(i)) : null, o2 = n2 ? He(e2, n2, Se(i)) : null;
      this.setState({ imageTexture: a2, imageTexture2: o2 });
    }
    t === e.oldProps.image && o === e.oldProps.gridEnabled || this._updateFeatures(), this.setState({ props: e.props });
  }
  _updateFeatures() {
    const { image: e, bounds: t, gridEnabled: n } = X(this.props, Ut);
    if (e && n) {
      const n2 = [t[0], t[1]], a = [t[2], t[3]], i = a[0] - n2[0], o = a[1] - n2[1], r = e.width, A2 = e.height, s = i / (r - (Se(t) ? 0 : 1)), l = o / (A2 - 1), c = new Array(r * A2).fill(void 0).map(((e2, t2) => [n2[0] + t2 % r * s, n2[1] + Math.floor(t2 / r) * l])), g = (function(e2, t2) {
        return Je(e2) ? t2 : t2.filter(((e3) => Ve(e3, De)));
      })(this.context.viewport, c);
      this.setState({ positions: g });
    }
  }
};
Nt.layerName = "RasterLayer", Nt.defaultProps = Ut;
var Lt = "uniform contourUniforms{float n;float o;float p;}contour;";
var Ft = "n";
var kt = "o";
var Zt = "p";
var Jt = { name: "contour", vs: Lt, fs: Lt, uniformTypes: { [Ft]: "f32", [kt]: "f32", [Zt]: "f32" }, getUniforms: function(e = {}) {
  return { [Ft]: e.interval, [kt]: e.majorInterval, [Zt]: e.width };
} };
var Rt = { imageTexture: { type: "object", value: null }, imageTexture2: { type: "object", value: null }, imageSmoothing: { type: "number", value: 0 }, imageInterpolation: { type: "object", value: re.CUBIC }, imageWeight: { type: "number", value: 0 }, imageType: { type: "object", value: Ae.SCALAR }, imageUnscale: { type: "object", value: null }, imageMinValue: { type: "object", value: null }, imageMaxValue: { type: "object", value: null }, bounds: { type: "array", value: [-180, -90, 180, 90], compare: true }, minZoom: { type: "object", value: null }, maxZoom: { type: "object", value: 10 }, palette: { type: "object", value: null }, color: { type: "color", value: N }, interval: { type: "number", value: 0 }, majorInterval: { type: "number", value: 0 }, width: { type: "number", value: 1 } };
var Wt = class extends bitmap_layer_default {
  getShaders() {
    const e = super.getShaders();
    return { ...e, fs: "#version 300 es\n#define SHADER_NAME  contour-bitmap-layer-fragment-shader\n#ifdef GL_ES\nprecision highp float;\n#endif\nvec4 AA(sampler2D AB,vec2 AC,vec2 AD,vec2 AE){vec2 uv=(AD+AE+0.5)/AC;return texture(AB,uv);}const vec4 AF=vec4(3.,-6.,0.,4.)/6.;const vec4 AG=vec4(-1.,6.,-12.,8.)/6.;vec4 AH(float J){return vec4(J*J*J,J*J,J,1.);}vec4 AI(vec4 AJ,vec4 AK,vec4 AL,vec4 AM,float AN){vec4 O=AJ*dot(AG,AH(AN+1.))+AK*dot(AF,AH(AN))+AL*dot(AF,AH(1.-AN))+AM*dot(AG,AH(2.-AN));O.a=(AJ.a>0.&&AK.a>0.&&AL.a>0.&&AM.a>0.)?max(max(max(AJ.a,AK.a),AL.a),AM.a):0.;return O;}vec4 AO(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP);vec2 AQ=fract(AP);return AI(AI(AA(AB,AC,AD,vec2(-1,-1)),AA(AB,AC,AD,vec2(0,-1)),AA(AB,AC,AD,vec2(1,-1)),AA(AB,AC,AD,vec2(2,-1)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,0)),AA(AB,AC,AD,vec2(0,0)),AA(AB,AC,AD,vec2(1,0)),AA(AB,AC,AD,vec2(2,0)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,1)),AA(AB,AC,AD,vec2(0,1)),AA(AB,AC,AD,vec2(1,1)),AA(AB,AC,AD,vec2(2,1)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,2)),AA(AB,AC,AD,vec2(0,2)),AA(AB,AC,AD,vec2(1,2)),AA(AB,AC,AD,vec2(2,2)),AQ.x),AQ.y);}vec4 AR(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP);vec2 AQ=fract(AP);return mix(mix(AA(AB,AC,AD,vec2(0,0)),AA(AB,AC,AD,vec2(1,0)),AQ.x),mix(AA(AB,AC,AD,vec2(0,1)),AA(AB,AC,AD,vec2(1,1)),AQ.x),AQ.y);}vec4 AS(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP+0.5);return AA(AB,AC,AD,vec2(0,0));}vec4 AT(sampler2D AB,vec2 AC,float a,vec2 uv){if(a==2.){return AO(AB,AC,uv);}if(a==1.){return AR(AB,AC,uv);}else{return AS(AB,AC,uv);}}vec4 AU(sampler2D AB,sampler2D AV,vec2 AC,float a,float b,bool B,vec2 uv){vec2 AW;AW.x=B?uv.x+0.5/AC.x:mix(0.+0.5/AC.x,1.-0.5/AC.x,uv.x);AW.y=mix(0.+0.5/AC.y,1.-0.5/AC.y,uv.y);if(b>0.){vec4 AX=AT(AB,AC,a,AW);vec4 AY=AT(AV,AC,a,AW);return mix(AX,AY,b);}else{return AT(AB,AC,a,AW);}}vec4 AZ(sampler2D AB,sampler2D AV,vec2 Y,float Z,float a,float b,bool B,vec2 uv){float Aa=1.+max(0.,Z);vec2 AC=Y/Aa;return AU(AB,AV,AC,a,b,B,uv);}float Ab(float K,float J){return J==0.?sign(K)*F/2.:atan(K,J);}bool Ac(float k){uint Ad=floatBitsToUint(k);return(Ad&0x7fffffffu)>0x7f800000u;}bool Ae(vec4 AX,vec2 d){if(d[0]<d[1]){return AX.a>=1.;}else{return!Ac(AX.x);}}float Af(vec4 AX,float c,vec2 d){if(c==1.){return 0.;}else{if(d[0]<d[1]){return mix(d[0],d[1],AX.x);}else{return AX.x;}}}vec2 Ag(vec4 AX,float c,vec2 d){if(c==1.){if(d[0]<d[1]){return mix(vec2(d[0]),vec2(d[1]),AX.xy);}else{return AX.xy;}}else{return vec2(0.);}}float Ah(vec4 AX,float c,vec2 d){if(c==1.){vec2 k=Ag(AX,c,d);return length(k);}else{return Af(AX,c,d);}}float Ai(vec4 AX,float c,vec2 d){if(c==1.){vec2 k=Ag(AX,c,d);return mod((360.-(Ab(k.y,k.x)/F*180.+180.))-270.,360.)/360.;}else{return 0.;}}in vec2 vTexCoord;in vec2 vTexPos;out vec4 fragColor;void main(void){vec2 uv=S(vTexCoord,vTexPos);vec4 AX=AZ(W,X,raster.Y,raster.Z,raster.a,raster.b,bitmap2.B,uv);if(!Ae(AX,raster.d)){discard;}float k=Ah(AX,raster.c,raster.d);if((!Ac(raster.e)&&k<raster.e)||(!Ac(raster.f)&&k>raster.f)){discard;}float Aj=contour.o>contour.n?floor(contour.o/contour.n):1.;float Ak=k/contour.n;float Al=(step(fract(Ak/Aj),0.1)+1.)/2.;float Am=contour.p*Al;float An=abs(fract(Ak+0.5)-0.5);float Ao=length(vec2(dFdx(Ak),dFdy(Ak)));float Ap=1.-clamp((An/Ao)+0.5-Am,0.,1.);if(Ao==0.){Ap=0.;}float Aq=Ap*Al;vec4 Ar=l(g,palette.h,palette.i,k);fragColor=vec4(Ar.rgb,Ar.a*Aq*layer.opacity);geometry.uv=uv;DECKGL_FILTER_COLOR(fragColor,geometry);}", modules: [...e.modules, ht, xt, Ot, Jt] };
  }
  updateState(e) {
    const { palette: t } = e.props;
    super.updateState(e), t !== e.oldProps.palette && this._updatePalette();
  }
  draw(e) {
    const { device: t, viewport: n } = this.context, { model: a } = this.state, { imageTexture: i, imageTexture2: o, imageSmoothing: r, imageInterpolation: A2, imageWeight: s, imageType: l, imageUnscale: c, imageMinValue: g, imageMaxValue: u, bounds: p, _imageCoordinateSystem: d, transparentColor: h, minZoom: m, maxZoom: C, color: v, interval: f, majorInterval: I, width: E } = X(this.props, Rt), { paletteTexture: B, paletteBounds: Q } = this.state;
    if (!i) return;
    const y2 = Je(n);
    a && We(n, m, C) && (a.shaderInputs.setProps({ [ht.name]: { viewportGlobe: y2, bounds: p, _imageCoordinateSystem: d, transparentColor: h }, [xt.name]: { imageTexture: i ?? et(t), imageTexture2: o ?? et(t), imageSmoothing: r, imageInterpolation: A2, imageWeight: s, imageType: l, imageUnscale: c, imageMinValue: g, imageMaxValue: u }, [Ot.name]: { paletteTexture: B ?? et(t), paletteBounds: Q, paletteColor: v }, [Jt.name]: { interval: f, majorInterval: I, width: E } }), a.setParameters({ ...a.parameters, cullMode: "back", depthCompare: "always", ...this.props.parameters }), this.props.image = i, super.draw(e), this.props.image = null);
  }
  _updatePalette() {
    const { device: e } = this.context, { palette: n } = X(this.props, Rt);
    if (!n) return void this.setState({ paletteTexture: void 0, paletteBounds: void 0 });
    const a = parsePalette(n), { paletteBounds: i, paletteTexture: o } = tt(e, a);
    this.setState({ paletteTexture: o, paletteBounds: i });
  }
};
Wt.layerName = "ContourBitmapLayer", Wt.defaultProps = Rt;
var qt = { ...Wt.defaultProps, imageTexture: void 0, imageTexture2: void 0, image: { type: "object", value: null }, image2: { type: "object", value: null } };
var Xt = class extends composite_layer_default {
  renderLayers() {
    const { device: e } = this.context, { props: t, imageTexture: a, imageTexture2: i } = this.state;
    return t && a ? [new Wt(this.props, this.getSubLayerProps({ id: "bitmap", imageTexture: a, imageTexture2: i, _imageCoordinateSystem: COORDINATE_SYSTEM.LNGLAT, image: et(e), image2: et(e) }))] : [];
  }
  updateState(e) {
    const { image: t, image2: n, imageUnscale: a, bounds: i } = e.props;
    if (super.updateState(e), t && a && !(t.data instanceof Uint8Array || t.data instanceof Uint8ClampedArray)) throw new Error("imageUnscale can be applied to Uint8 data only");
    if (t !== e.oldProps.image || n !== e.oldProps.image2) {
      const { device: e2 } = this.context, { image: t2, image2: n2 } = this.props, a2 = t2 ? He(e2, t2, Se(i)) : null, o = n2 ? He(e2, n2, Se(i)) : null;
      this.setState({ imageTexture: a2, imageTexture2: o });
    }
    this.setState({ props: e.props });
  }
};
Xt.layerName = "ContourLayer", Xt.defaultProps = qt;
var Kt = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
function Gt(e = 20) {
  return new Array(e).fill(void 0).map((() => Kt.charAt(Math.floor(62 * Math.random())))).join("");
}
var zt = transform((jt = function() {
  const e = Symbol("Comlink.proxy"), t = Symbol("Comlink.endpoint"), n = Symbol("Comlink.releaseProxy"), a = Symbol("Comlink.finalizer"), i = Symbol("Comlink.thrown"), o = (e2) => "object" == typeof e2 && null !== e2 || "function" == typeof e2, r = { canHandle: (t2) => o(t2) && t2[e], serialize(e2) {
    const { port1: t2, port2: n2 } = new MessageChannel();
    return s(e2, t2), [n2, [n2]];
  }, deserialize: (e2) => (e2.start(), (function(e3, t2) {
    const n2 = /* @__PURE__ */ new Map();
    return e3.addEventListener("message", (function(e4) {
      const { data: t3 } = e4;
      if (!t3 || !t3.id) return;
      const a2 = n2.get(t3.id);
      if (a2) try {
        a2(t3);
      } finally {
        n2.delete(t3.id);
      }
    })), d(e3, n2, [], t2);
  })(e2)) }, A2 = /* @__PURE__ */ new Map([["proxy", r], ["throw", { canHandle: (e2) => o(e2) && i in e2, serialize({ value: e2 }) {
    let t2;
    return t2 = e2 instanceof Error ? { isError: true, value: { message: e2.message, name: e2.name, stack: e2.stack } } : { isError: false, value: e2 }, [t2, []];
  }, deserialize(e2) {
    if (e2.isError) throw Object.assign(new Error(e2.value.message), e2.value);
    throw e2.value;
  } }]]);
  function s(t2, n2 = globalThis, o2 = ["*"]) {
    n2.addEventListener("message", (function r2(A3) {
      if (!A3 || !A3.data) return;
      if (!(function(e2, t3) {
        for (const n3 of e2) {
          if (t3 === n3 || "*" === n3) return true;
          if (n3 instanceof RegExp && n3.test(t3)) return true;
        }
        return false;
      })(o2, A3.origin)) return void console.warn(`Invalid origin '${A3.origin}' for comlink proxy`);
      const { id: c2, type: g2, path: u2 } = Object.assign({ path: [] }, A3.data), p2 = (A3.data.argumentList || []).map(f);
      let d2;
      try {
        const n3 = u2.slice(0, -1).reduce(((e2, t3) => e2[t3]), t2), a2 = u2.reduce(((e2, t3) => e2[t3]), t2);
        switch (g2) {
          case "GET":
            d2 = a2;
            break;
          case "SET":
            n3[u2.slice(-1)[0]] = f(A3.data.value), d2 = true;
            break;
          case "APPLY":
            d2 = a2.apply(n3, p2);
            break;
          case "CONSTRUCT":
            d2 = (function(t3) {
              return Object.assign(t3, { [e]: true });
            })(new a2(...p2));
            break;
          case "ENDPOINT":
            {
              const { port1: e2, port2: n4 } = new MessageChannel();
              s(t2, n4), d2 = C(e2, [e2]);
            }
            break;
          case "RELEASE":
            d2 = void 0;
            break;
          default:
            return;
        }
      } catch (e2) {
        d2 = { value: e2, [i]: 0 };
      }
      Promise.resolve(d2).catch(((e2) => ({ value: e2, [i]: 0 }))).then(((e2) => {
        const [i2, o3] = v(e2);
        n2.postMessage(Object.assign(Object.assign({}, i2), { id: c2 }), o3), "RELEASE" === g2 && (n2.removeEventListener("message", r2), l(n2), a in t2 && "function" == typeof t2[a] && t2[a]());
      })).catch(((e2) => {
        const [t3, a2] = v({ value: new TypeError("Unserializable return value"), [i]: 0 });
        n2.postMessage(Object.assign(Object.assign({}, t3), { id: c2 }), a2);
      }));
    })), n2.start && n2.start();
  }
  function l(e2) {
    (function(e3) {
      return "MessagePort" === e3.constructor.name;
    })(e2) && e2.close();
  }
  function c(e2) {
    if (e2) throw new Error("Proxy has been released and is not useable");
  }
  function g(e2) {
    return I(e2, /* @__PURE__ */ new Map(), { type: "RELEASE" }).then((() => {
      l(e2);
    }));
  }
  const u = /* @__PURE__ */ new WeakMap(), p = "FinalizationRegistry" in globalThis && new FinalizationRegistry(((e2) => {
    const t2 = (u.get(e2) || 0) - 1;
    u.set(e2, t2), 0 === t2 && g(e2);
  }));
  function d(e2, a2, i2 = [], o2 = function() {
  }) {
    let r2 = false;
    const A3 = new Proxy(o2, { get(t2, o3) {
      if (c(r2), o3 === n) return () => {
        !(function(e3) {
          p && p.unregister(e3);
        })(A3), g(e2), a2.clear(), r2 = true;
      };
      if ("then" === o3) {
        if (0 === i2.length) return { then: () => A3 };
        const t3 = I(e2, a2, { type: "GET", path: i2.map(((e3) => e3.toString())) }).then(f);
        return t3.then.bind(t3);
      }
      return d(e2, a2, [...i2, o3]);
    }, set(t2, n2, o3) {
      c(r2);
      const [A4, s2] = v(o3);
      return I(e2, a2, { type: "SET", path: [...i2, n2].map(((e3) => e3.toString())), value: A4 }, s2).then(f);
    }, apply(n2, o3, A4) {
      c(r2);
      const s2 = i2[i2.length - 1];
      if (s2 === t) return I(e2, a2, { type: "ENDPOINT" }).then(f);
      if ("bind" === s2) return d(e2, a2, i2.slice(0, -1));
      const [l2, g2] = h(A4);
      return I(e2, a2, { type: "APPLY", path: i2.map(((e3) => e3.toString())), argumentList: l2 }, g2).then(f);
    }, construct(t2, n2) {
      c(r2);
      const [o3, A4] = h(n2);
      return I(e2, a2, { type: "CONSTRUCT", path: i2.map(((e3) => e3.toString())), argumentList: o3 }, A4).then(f);
    } });
    return (function(e3, t2) {
      const n2 = (u.get(t2) || 0) + 1;
      u.set(t2, n2), p && p.register(e3, t2, e3);
    })(A3, e2), A3;
  }
  function h(e2) {
    const t2 = e2.map(v);
    return [t2.map(((e3) => e3[0])), (n2 = t2.map(((e3) => e3[1])), Array.prototype.concat.apply([], n2))];
    var n2;
  }
  const m = /* @__PURE__ */ new WeakMap();
  function C(e2, t2) {
    return m.set(e2, t2), e2;
  }
  function v(e2) {
    for (const [t2, n2] of A2) if (n2.canHandle(e2)) {
      const [a2, i2] = n2.serialize(e2);
      return [{ type: "HANDLER", name: t2, value: a2 }, i2];
    }
    return [{ type: "RAW", value: e2 }, m.get(e2) || []];
  }
  function f(e2) {
    switch (e2.type) {
      case "HANDLER":
        return A2.get(e2.name).deserialize(e2.value);
      case "RAW":
        return e2.value;
    }
  }
  function I(e2, t2, n2, a2) {
    return new Promise(((i2) => {
      const o2 = new Array(4).fill(0).map((() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))).join("-");
      t2.set(o2, i2), e2.start && e2.start(), e2.postMessage(Object.assign({ id: o2 }, n2), a2);
    }));
  }
  const E = 6371e3;
  function B(e2) {
    return e2 / 180 * Math.PI;
  }
  const Q = 6370972;
  function y2(e2, t2) {
    return (function(e3, t3, n2 = E) {
      const a2 = n2, i2 = B(e3[1]), o2 = B(e3[0]), r2 = B(t3[1]), A3 = r2 - i2, s2 = B(t3[0]) - o2, l2 = Math.sin(A3 / 2) * Math.sin(A3 / 2) + Math.cos(i2) * Math.cos(r2) * Math.sin(s2 / 2) * Math.sin(s2 / 2);
      return a2 * (2 * Math.atan2(Math.sqrt(l2), Math.sqrt(1 - l2)));
    })(e2, t2, Q);
  }
  const b2 = { NEAREST: "NEAREST", LINEAR: "LINEAR", CUBIC: "CUBIC" }, w2 = { VECTOR: "VECTOR" };
  function x2(e2) {
    return e2 % 1;
  }
  function T2(e2, t2) {
    return e2.map(((n2, a2) => e2[a2] + t2[a2]));
  }
  function M2(e2, t2) {
    return e2.map(((n2, a2) => e2[a2] * t2));
  }
  function P2(e2, t2) {
    return e2.map(((n2, a2) => e2[a2] * t2[a2])).reduce(((e3, t3) => e3 + t3));
  }
  function D2(e2, t2, n2) {
    return e2 === t2 ? e2 : e2 * (1 - n2) + t2 * n2;
  }
  function O2(e2, t2, n2) {
    return e2.map(((a2, i2) => D2(e2[i2], t2[i2], n2)));
  }
  function S2(e2, t2) {
    return t2 ? e2[3] >= 255 : !isNaN(e2[0]);
  }
  function V2(e2, t2, n2) {
    if (t2 === w2.VECTOR) {
      const a2 = (function(e3, t3, n3) {
        return t3 === w2.VECTOR ? n3 ? [D2(n3[0], n3[1], e3[0] / 255), D2(n3[0], n3[1], e3[1] / 255)] : [e3[0], e3[1]] : [NaN, NaN];
      })(e2, t2, n2);
      return Math.hypot(a2[0], a2[1]);
    }
    return (function(e3, t3, n3) {
      return t3 === w2.VECTOR ? 0 : n3 ? D2(n3[0], n3[1], e3[0] / 255) : e3[0];
    })(e2, t2, n2);
  }
  function U2(e2, t2, n2, a2, i2, o2) {
    const { data: r2, width: A3, height: s2 } = e2, l2 = r2.length / (A3 * s2), c2 = (n2 + i2 + 0.5) / t2[0], g2 = (a2 + o2 + 0.5) / t2[1], u2 = Math.max(0, Math.min(A3 - 1, Math.floor(c2 * A3))), p2 = Math.max(0, Math.min(s2 - 1, Math.floor(g2 * s2)));
    return new Array(l2).fill(void 0).map(((e3, t3) => r2[(u2 + p2 * A3) * l2 + t3]));
  }
  const N2 = [3, -6, 0, 4].map(((e2) => e2 / 6)), L2 = [-1, 6, -12, 8].map(((e2) => e2 / 6));
  function F2(e2) {
    return [e2 * e2 * e2, e2 * e2, e2, 1];
  }
  function k2(e2, t2, n2, a2, i2) {
    const o2 = T2(T2(T2(M2(e2, P2(L2, F2(i2 + 1))), M2(t2, P2(N2, F2(i2)))), M2(n2, P2(N2, F2(1 - i2)))), M2(a2, P2(L2, F2(2 - i2))));
    return o2[3] = e2[3] > 0 && t2[3] > 0 && n2[3] > 0 && a2[3] > 0 ? Math.max(Math.max(Math.max(e2[3], t2[3]), n2[3]), a2[3]) : 0, o2;
  }
  function Z2(e2, t2, n2, a2, i2) {
    return n2 === b2.CUBIC ? (function(e3, t3, n3, a3) {
      const i3 = n3 * t3[0] - 0.5, o2 = a3 * t3[1] - 0.5, r2 = Math.floor(i3), A3 = Math.floor(o2), s2 = x2(i3), l2 = x2(o2);
      return k2(k2(U2(e3, t3, r2, A3, -1, -1), U2(e3, t3, r2, A3, 0, -1), U2(e3, t3, r2, A3, 1, -1), U2(e3, t3, r2, A3, 2, -1), s2), k2(U2(e3, t3, r2, A3, -1, 0), U2(e3, t3, r2, A3, 0, 0), U2(e3, t3, r2, A3, 1, 0), U2(e3, t3, r2, A3, 2, 0), s2), k2(U2(e3, t3, r2, A3, -1, 1), U2(e3, t3, r2, A3, 0, 1), U2(e3, t3, r2, A3, 1, 1), U2(e3, t3, r2, A3, 2, 1), s2), k2(U2(e3, t3, r2, A3, -1, 2), U2(e3, t3, r2, A3, 0, 2), U2(e3, t3, r2, A3, 1, 2), U2(e3, t3, r2, A3, 2, 2), s2), l2);
    })(e2, t2, a2, i2) : n2 === b2.LINEAR ? (function(e3, t3, n3, a3) {
      const i3 = n3 * t3[0] - 0.5, o2 = a3 * t3[1] - 0.5, r2 = Math.floor(i3), A3 = Math.floor(o2), s2 = x2(i3), l2 = x2(o2);
      return O2(O2(U2(e3, t3, r2, A3, 0, 0), U2(e3, t3, r2, A3, 1, 0), s2), O2(U2(e3, t3, r2, A3, 0, 1), U2(e3, t3, r2, A3, 1, 1), s2), l2);
    })(e2, t2, a2, i2) : (function(e3, t3, n3, a3) {
      const i3 = n3 * t3[0] - 0.5, o2 = a3 * t3[1] - 0.5;
      return U2(e3, t3, Math.round(i3), Math.round(o2), 0, 0);
    })(e2, t2, a2, i2);
  }
  function J2(e2, t2, n2, a2, i2, o2, r2, A3) {
    const s2 = o2 ? r2 + 0.5 / n2[0] : D2(0 + 0.5 / n2[0], 1 - 0.5 / n2[0], r2), l2 = D2(0 + 0.5 / n2[1], 1 - 0.5 / n2[1], A3);
    return t2 && i2 > 0 ? O2(Z2(e2, n2, a2, s2, l2), Z2(t2, n2, a2, s2, l2), i2) : Z2(e2, n2, a2, s2, l2);
  }
  function R2(e2, t2) {
    const { image: n2, image2: a2, imageSmoothing: i2, imageInterpolation: o2, imageWeight: r2, imageType: A3, imageUnscale: s2, imageMinValue: l2, imageMaxValue: c2 } = e2, { width: g2, height: u2 } = n2, p2 = o2 !== b2.NEAREST ? b2.NEAREST : o2, d2 = (function(e3, t3, n3) {
      const a3 = 1 + Math.max(0, n3);
      return [e3 / a3, t3 / a3];
    })(g2, u2, i2), h2 = (function(e3) {
      return e3[2] - e3[0] == 360;
    })(t2), m2 = new Float32Array(g2 * u2);
    for (let e3 = 0; e3 < u2; e3++) for (let t3 = 0; t3 < g2; t3++) {
      const i3 = t3 + e3 * g2, o3 = J2(n2, a2, d2, p2, r2, h2, t3 / g2, e3 / u2);
      if (!S2(o3, s2)) {
        m2[i3] = NaN;
        continue;
      }
      const C2 = V2(o3, A3, s2);
      "number" == typeof l2 && !isNaN(l2) && C2 < l2 || "number" == typeof c2 && !isNaN(c2) && C2 > c2 ? m2[i3] = NaN : m2[i3] = C2;
    }
    return { data: m2, width: g2, height: u2 };
  }
  function W2(e2, t2, n2) {
    let { data: a2, width: i2, height: o2 } = e2;
    const r2 = 1e3 * n2, A3 = (function(e3, t3, n3) {
      const a3 = [n3[0], n3[3]], i3 = (n3[2] - n3[0]) / e3, o3 = (n3[3] - n3[1]) / t3;
      return (e4) => {
        const [t4, n4] = e4;
        return [a3[0] + t4 * i3, a3[1] - n4 * o3];
      };
    })(i2, o2, t2);
    a2 = (function(e3, t3, n3) {
      const a3 = new Float32Array(e3.length);
      for (let i3 = 0; i3 < n3; i3++) for (let o3 = 0; o3 < t3; o3++) {
        const r3 = o3 + i3 * t3;
        if (o3 >= 1 && o3 <= t3 - 2 && i3 >= 1 && i3 <= n3 - 2) {
          const n4 = [e3[o3 - 1 + (i3 - 1) * t3], e3[o3 + (i3 - 1) * t3], e3[o3 + 1 + (i3 - 1) * t3], e3[o3 - 1 + i3 * t3], e3[o3 + i3 * t3], e3[o3 + 1 + i3 * t3], e3[o3 - 1 + (i3 + 1) * t3], e3[o3 + (i3 + 1) * t3], e3[o3 + 1 + (i3 - 1) * t3]];
          a3[r3] = n4.reduce(((e4, t4) => e4 + t4), 0) / n4.length;
        } else a3[r3] = e3[r3];
      }
      return a3;
    })(a2, i2, o2);
    let s2 = [], l2 = [];
    for (let e3 = 1; e3 < o2 - 1; e3++) for (let t3 = 1; t3 < i2 - 1; t3++) {
      const n3 = a2[t3 + e3 * i2];
      if (!isNaN(n3) && n3 >= a2[t3 + 1 + e3 * i2] && n3 >= a2[t3 + 1 + (e3 + 1) * i2] && n3 >= a2[t3 + (e3 + 1) * i2] && n3 >= a2[t3 - 1 + (e3 + 1) * i2] && n3 > a2[t3 - 1 + e3 * i2] && n3 > a2[t3 - 1 + (e3 - 1) * i2] && n3 > a2[t3 + (e3 - 1) * i2] && n3 > a2[t3 + 1 + (e3 - 1) * i2]) {
        const a3 = A3([t3, e3]);
        s2.push({ position: a3, value: n3 });
      }
      if (!isNaN(n3) && n3 <= a2[t3 + 1 + e3 * i2] && n3 <= a2[t3 + 1 + (e3 + 1) * i2] && n3 <= a2[t3 + (e3 + 1) * i2] && n3 <= a2[t3 - 1 + (e3 + 1) * i2] && n3 < a2[t3 - 1 + e3 * i2] && n3 < a2[t3 - 1 + (e3 - 1) * i2] && n3 < a2[t3 + (e3 - 1) * i2] && n3 < a2[t3 + 1 + (e3 - 1) * i2]) {
        const a3 = A3([t3, e3]);
        l2.push({ position: a3, value: n3 });
      }
    }
    s2 = s2.sort(((e3, t3) => t3.value - e3.value)), l2 = l2.sort(((e3, t3) => e3.value - t3.value));
    const c2 = [...s2];
    for (let e3 = 0; e3 < c2.length; e3++) {
      const t3 = c2[e3];
      if (t3) for (let n3 = e3 + 1; n3 < c2.length; n3++) {
        const e4 = c2[n3];
        e4 && y2(t3.position, e4.position) < r2 && (c2[n3] = void 0);
      }
    }
    s2 = c2.filter(((e3) => !!e3));
    const g2 = [...l2];
    for (let e3 = 0; e3 < g2.length; e3++) {
      const t3 = g2[e3];
      if (t3) for (let n3 = e3 + 1; n3 < g2.length; n3++) {
        const e4 = g2[n3];
        e4 && y2(t3.position, e4.position) < r2 && (g2[n3] = void 0);
      }
    }
    return l2 = g2.filter(((e3) => !!e3)), new Float32Array([s2.length, ...s2.map(((e3) => [...e3.position, e3.value])).flat(), l2.length, ...l2.map(((e3) => [...e3.position, e3.value])).flat()]);
  }
  s({ getHighLowPointData(e2, t2, n2, a2, i2, o2, r2, A3, s2, l2, c2, g2, u2, p2, d2) {
    const h2 = (function(e3, t3, n3) {
      return W2(R2(e3, t3), t3, n3);
    })({ image: { data: e2, width: t2, height: n2 }, image2: a2 ? { data: a2, width: i2, height: o2 } : null, imageSmoothing: r2, imageInterpolation: A3, imageWeight: s2, imageType: l2, imageUnscale: c2, imageMinValue: g2, imageMaxValue: u2 }, p2, d2);
    return C(h2, [h2.buffer]);
  } });
}, jt.toString().replace(/^function.+?{/, "").slice(0, -1)));
var jt;
var Yt = factory(zt);
var _t = { LOW: "L", HIGH: "H" };
var Ht = wrap(Yt());
function $t(e, t) {
  return { type: "Feature", geometry: { type: "Point", coordinates: e }, properties: t };
}
async function en(e, t, n) {
  const { image: a, image2: i, imageSmoothing: o, imageInterpolation: r, imageWeight: A2, imageType: s, imageUnscale: l, imageMinValue: c, imageMaxValue: g } = e, { data: u, width: p, height: d } = a, { data: h = null, width: C = null, height: v = null } = i || {}, f = u.slice(0), I = h ? h.slice(0) : null, E = (function(e2) {
    let t2 = 0;
    const n2 = [], a2 = e2[t2++];
    for (let i3 = 0; i3 < a2; i3++) {
      const a3 = [e2[t2++], e2[t2++]], i4 = e2[t2++];
      n2.push($t(a3, { type: _t.HIGH, value: i4 }));
    }
    const i2 = e2[t2++];
    for (let a3 = 0; a3 < i2; a3++) {
      const a4 = [e2[t2++], e2[t2++]], i3 = e2[t2++];
      n2.push($t(a4, { type: _t.LOW, value: i3 }));
    }
    return n2;
  })(await Ht.getHighLowPointData(transfer(f, [f.buffer]), p, d, I ? transfer(I, [I.buffer]) : null, C, v, o, r, A2, s, l, c, g, t, n));
  return { type: "FeatureCollection", features: E };
}
var tn = "high-low-label";
function nn(e, t, n) {
  return e.properties.type === _t.HIGH ? Math.round((e.properties.value - n) / n * 100) : Math.round((t - e.properties.value) / t * 100);
}
var an = { image: { type: "object", value: null }, image2: { type: "object", value: null }, imageSmoothing: { type: "number", value: 0 }, imageInterpolation: { type: "object", value: re.CUBIC }, imageWeight: { type: "number", value: 0 }, imageType: { type: "object", value: Ae.SCALAR }, imageUnscale: { type: "array", value: null }, imageMinValue: { type: "object", value: null }, imageMaxValue: { type: "object", value: null }, bounds: { type: "array", value: [-180, -90, 180, 90], compare: true }, minZoom: { type: "object", value: null }, maxZoom: { type: "object", value: null }, radius: { type: "number", value: 0 }, unitFormat: { type: "object", value: null }, textFormatFunction: { type: "function", value: R }, textFontFamily: { type: "object", value: L }, textSize: { type: "number", value: 12 }, textColor: { type: "color", value: k }, textOutlineWidth: { type: "number", value: 1 }, textOutlineColor: { type: "color", value: J }, palette: { type: "object", value: null } };
var on = class extends composite_layer_default {
  renderLayers() {
    const { viewport: e } = this.context, { props: t, visiblePoints: n, minValue: a, maxValue: i } = this.state;
    if (!t || !n || "number" != typeof a || "number" != typeof i) return [];
    const { unitFormat: o, textFormatFunction: A2, textFontFamily: s, textSize: l, textColor: g, textOutlineWidth: u, textOutlineColor: p } = X(t, an), { paletteScale: d } = this.state;
    return [new text_layer_default(this.getSubLayerProps({ id: "type", data: n, getPixelOffset: [0, -ze(e, 1.2 * l / 2)], getPosition: (e2) => e2.geometry.coordinates, getText: (e2) => e2.properties.type, getSize: 1.2 * l, getColor: (e2) => d ? at(d(e2.properties.value).rgba()) : g, getAngle: je(e, 0), outlineWidth: u, outlineColor: p, fontFamily: s, fontSettings: { sdf: true }, billboard: false, extensions: [new collision_filter_extension_default()], collisionEnabled: true, collisionGroup: tn, collisionTestProps: { sizeScale: 5 }, getCollisionPriority: (e2) => nn(e2, a, i), parameters: { cullMode: "front", depthCompare: "always", ...this.props.parameters } })), new text_layer_default(this.getSubLayerProps({ id: "value", data: n, getPixelOffset: [0, ze(e, 1.2 * l / 2)], getPosition: (e2) => e2.geometry.coordinates, getText: (e2) => A2(e2.properties.value, o), getSize: l, getColor: (e2) => d ? at(d(e2.properties.value).rgba()) : g, getAngle: je(e, 0), outlineWidth: u, outlineColor: p, fontFamily: s, fontSettings: { sdf: true }, billboard: false, extensions: [new collision_filter_extension_default()], collisionEnabled: true, collisionGroup: tn, collisionTestProps: { sizeScale: 5 }, getCollisionPriority: (e2) => nn(e2, a, i), parameters: { cullMode: "front", depthCompare: "always", ...this.props.parameters } }))];
  }
  shouldUpdateState(e) {
    return super.shouldUpdateState(e) || e.changeFlags.viewportChanged;
  }
  updateState(e) {
    const { image: t, image2: n, imageSmoothing: a, imageInterpolation: i, imageWeight: o, imageType: r, imageUnscale: A2, imageMinValue: s, imageMaxValue: l, minZoom: c, maxZoom: g, radius: u, unitFormat: p, textFormatFunction: d, textFontFamily: h, textSize: m, textColor: C, textOutlineWidth: v, textOutlineColor: f, palette: I, visible: E } = e.props;
    super.updateState(e), u && E ? (t === e.oldProps.image && n === e.oldProps.image2 && a === e.oldProps.imageSmoothing && i === e.oldProps.imageInterpolation && o === e.oldProps.imageWeight && r === e.oldProps.imageType && A2 === e.oldProps.imageUnscale && s === e.oldProps.imageMinValue && l === e.oldProps.imageMaxValue && u === e.oldProps.radius && E === e.oldProps.visible || this._updateFeatures(), (c !== e.oldProps.minZoom || g !== e.oldProps.maxZoom || e.changeFlags.viewportChanged) && this._updateVisibleFeatures(), I !== e.oldProps.palette && this._updatePalette(), p === e.oldProps.unitFormat && d === e.oldProps.textFormatFunction && h === e.oldProps.textFontFamily && m === e.oldProps.textSize && C === e.oldProps.textColor && v === e.oldProps.textOutlineWidth && f === e.oldProps.textOutlineColor || this._redrawVisibleFeatures(), this.setState({ props: e.props })) : this.setState({ points: void 0, visiblePoints: void 0, minValue: void 0, maxValue: void 0 });
  }
  async _updateFeatures() {
    const { image: e, image2: t, imageSmoothing: n, imageInterpolation: a, imageType: i, imageUnscale: o, imageMinValue: r, imageMaxValue: A2, imageWeight: s, bounds: l, radius: c } = X(this.props, an);
    if (!e) return;
    const g = Gt();
    this.state.requestId = g;
    const u = { image: e, image2: t, imageSmoothing: n, imageInterpolation: a, imageWeight: s, imageType: i, imageUnscale: o, imageMinValue: r, imageMaxValue: A2 }, p = (await en(u, l, c)).features;
    if (this.state.requestId !== g) return;
    const d = p.map(((e2) => e2.properties.value)), h = Math.min(...d), m = Math.max(...d);
    this.setState({ points: p, minValue: h, maxValue: m }), this._updateVisibleFeatures();
  }
  _updateVisibleFeatures() {
    const { viewport: e } = this.context, { minZoom: t, maxZoom: n } = X(this.props, an), { points: a } = this.state;
    if (!a) return;
    let i;
    i = We(e, t, n) ? a : [], this.setState({ visiblePoints: i });
  }
  _updatePalette() {
    const { palette: e } = X(this.props, an);
    if (!e) return this.setState({ paletteScale: void 0 }), void this._redrawVisibleFeatures();
    const n = parsePalette(e);
    this.setState({ paletteScale: n }), this._redrawVisibleFeatures();
  }
  _redrawVisibleFeatures() {
    this.setState({ visiblePoints: Array.isArray(this.state.visiblePoints) ? Array.from(this.state.visiblePoints) : this.state.visiblePoints });
  }
};
on.layerName = "HighLowCompositeLayer", on.defaultProps = an;
var rn = { ...on.defaultProps };
var An = class extends composite_layer_default {
  renderLayers() {
    const { props: e } = this.state;
    return e ? [new on(this.props, this.getSubLayerProps({ id: "composite" }))] : [];
  }
  updateState(e) {
    const { image: t, imageUnscale: n } = e.props;
    if (super.updateState(e), t && n && !(t.data instanceof Uint8Array || t.data instanceof Uint8ClampedArray)) throw new Error("imageUnscale can be applied to Uint8 data only");
    this.setState({ props: e.props });
  }
};
An.layerName = "HighLowLayer", An.defaultProps = rn;
var sn = { COLD: "COLD", WARM: "WARM", OCCLUDED: "OCCLUDED", STATIONARY: "STATIONARY" };
var ln = { iconAtlas: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGoAAAAqCAYAAABbec77AAAFsmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgeG1wOkNyZWF0ZURhdGU9IjIwMjMtMDMtMTBUMTQ6NDI6NTYrMDEwMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjMtMDMtMjVUMDk6MDY6NTgrMDE6MDAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjMtMDMtMjVUMDk6MDY6NTgrMDE6MDAiCiAgIHBob3Rvc2hvcDpEYXRlQ3JlYXRlZD0iMjAyMy0wMy0xMFQxNDo0Mjo1NiswMTAwIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEi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", iconMapping: { COLD: { x: 2, y: 2, width: 50, height: 38, anchorY: 35, mask: true }, WARM: { x: 54, y: 2, width: 50, height: 38, anchorY: 35, mask: true } } };
function cn(e, t) {
  for (let n = e.length - 1; n >= 0; n--) if (t.call(e, e[n], n, e)) return n;
  return -1;
}
var gn = { data: { type: "array", value: [] }, minZoom: { type: "object", value: null }, maxZoom: { type: "object", value: null }, getType: { type: "function", value: null }, getPath: { type: "function", value: null }, width: { type: "number", value: 2 }, coldColor: { type: "color", value: [0, 0, 255] }, warmColor: { type: "color", value: [255, 0, 0] }, occludedColor: { type: "color", value: [148, 0, 211] }, iconSize: { type: "number", value: 15 }, _debug: { type: "boolean", value: false } };
var un = class extends composite_layer_default {
  renderLayers() {
    const { viewport: e } = this.context, { props: t, visibleFrontLines: n, visibleDebugFrontPoints: a } = this.state;
    if (!t || !n || !a) return [];
    const { getType: i, getPath: o, width: l, coldColor: u, warmColor: p, occludedColor: d, iconSize: h, _debug: m } = X(t, gn);
    if (!i || !o) return [];
    const { iconStyle: C, iconAtlasTexture: v } = this.state;
    if (!C || !v) return [];
    const f = { [sn.COLD]: u, [sn.WARM]: p, [sn.OCCLUDED]: d, [sn.STATIONARY]: u };
    return [new path_layer_default(this.getSubLayerProps({ id: "path", data: n, getPath: (e2) => [e2.startPosition, ...e2.icons.map(((e3) => e3.position)), e2.endPosition], getColor: (e2) => f[i(e2.d)], getWidth: l, widthUnits: "pixels" })), new path_layer_default(this.getSubLayerProps({ id: "path-stationary-warm", data: n.filter(((e2) => i(e2.d) === sn.STATIONARY)), getPath: (e2) => [e2.startPosition, ...e2.icons.map(((e3) => e3.position)), e2.endPosition], getColor: p, getWidth: l, widthUnits: "pixels", extensions: [new path_style_extension_default({ dash: true, highPrecisionDash: true })], getDashArray: [45, 45] })), new icon_layer_default(this.getSubLayerProps({ id: "icon", data: n.flatMap(((e2) => e2.icons)), getPosition: (e2) => e2.position, getIcon: (e2) => i(e2.d) === sn.OCCLUDED || i(e2.d) === sn.STATIONARY ? e2.alternate ? sn.COLD : sn.WARM : i(e2.d), getSize: h, getColor: (e2) => i(e2.d) === sn.STATIONARY ? e2.alternate ? f[sn.COLD] : f[sn.WARM] : f[i(e2.d)], getAngle: (t2) => i(t2.d) === sn.STATIONARY ? t2.alternate ? je(e, t2.direction) : je(e, t2.direction + 180) : je(e, t2.direction), iconAtlas: v, iconMapping: C.iconMapping, billboard: false, extensions: [new collision_filter_extension_default()], collisionEnabled: true, collisionGroup: "front-icon", collisionTestProps: { sizeScale: 5 }, getCollisionPriority: (e2) => e2.priority })), ...m ? [new text_layer_default(this.getSubLayerProps({ id: "text", data: a, getPosition: (e2) => e2.position, getText: (e2) => `${e2.index}`, getSize: 12, getColor: k, getAngle: je(e, 0), outlineWidth: 1, outlineColor: J, fontFamily: L, fontSettings: { sdf: true }, billboard: false }))] : []];
  }
  shouldUpdateState(e) {
    return super.shouldUpdateState(e) || e.changeFlags.viewportChanged;
  }
  updateState(e) {
    const { data: t, getType: n, getPath: a, minZoom: i, maxZoom: o } = e.props;
    super.updateState(e), t && n && a ? (this.state.iconStyle || this._updateIconStyle(), t === e.oldProps.data && a === e.oldProps.getPath || this._updateFeatures(), (i !== e.oldProps.minZoom || o !== e.oldProps.maxZoom || e.changeFlags.viewportChanged) && this._updateVisibleFeatures(), this.setState({ props: e.props })) : this.setState({ features: void 0, debugFeatures: void 0, visibleFeatures: void 0, visibleDebugFeatures: void 0 });
  }
  async _updateIconStyle() {
    const { device: e } = this.context;
    this.setState({ iconStyle: ln });
    const t = He(e, await _(ln.iconAtlas));
    this.setState({ iconAtlasTexture: t });
  }
  _updateFeatures() {
    const { data: e, getPath: t } = X(this.props, gn);
    if (!t) return;
    const n = e.map(((e2) => (function(e3, t2) {
      const n2 = t2, a2 = n2.slice(0, -1).map(((e4, t3) => ke(n2[t3], n2[t3 + 1]))).reduce(((e4, t3) => [...e4, e4[e4.length - 1] + t3]), [0]);
      let i = [];
      for (let e4 = 1, t3 = a2[a2.length - 1] / 3; t3 > 5e3; e4++, t3 /= 3) {
        const o2 = 3 ** e4;
        for (let r = 1; r < o2; r++) {
          if (e4 > 1 && r % 3 == 0) continue;
          const o3 = r * t3, A2 = cn(a2, ((e5) => e5 <= o3));
          if (-1 === A2 || A2 === n2.length - 1) throw new Error("Invalid state");
          const s = A2 + 1, l = n2[A2], c = n2[s], g = a2[A2], u = initialBearing(l, c), p = Ze(l, o3 - g, u), h = 90 - u, m = 100 - e4;
          i.push({ distance: o3, position: p, direction: h, priority: m });
        }
      }
      i = i.sort(((e4, t3) => e4.distance - t3.distance));
      const o = i.map(((t3, n3) => ({ d: e3, ...t3, alternate: n3 % 2 == 0 })));
      return { d: e3, startPosition: t2[0], endPosition: t2[t2.length - 1], icons: o };
    })(e2, t(e2)))), a = e.flatMap(((e2) => t(e2).map(((t2, n2) => ({ d: e2, position: t2, index: n2 })))));
    this.setState({ frontLines: n, debugFrontPoints: a }), this._updateVisibleFeatures();
  }
  _updateVisibleFeatures() {
    const { viewport: e } = this.context, { minZoom: t, maxZoom: n } = X(this.props, gn), { frontLines: a, debugFrontPoints: i } = this.state;
    if (!a || !i) return;
    let o, r;
    We(e, t, n) ? (o = a, r = i) : (o = [], r = []), this.setState({ visibleFrontLines: o, visibleDebugFrontPoints: r });
  }
};
un.layerName = "FrontCompositeLayer", un.defaultProps = gn;
var pn = { ...un.defaultProps };
var dn = class extends composite_layer_default {
  renderLayers() {
    return [new un(this.props, this.getSubLayerProps({ id: "composite" }))];
  }
};
dn.layerName = "FrontLayer", dn.defaultProps = pn;
var hn = /* @__PURE__ */ new Map();
var mn = /* @__PURE__ */ new Map();
function Cn(e, t = 0) {
  let n;
  if (Je(e)) {
    n = (function(e2, t2, n2) {
      const a = 7;
      n2 = Math.min(Math.max(n2 - 2, 0), a);
      const i = hn.get(n2) ?? (() => {
        const { uv: e3 } = icomesh(n2, true), t3 = [];
        for (let n3 = 0; n3 < e3.length; n3 += 2) {
          const a2 = e3[n3], i2 = e3[n3 + 1];
          if (0 === a2) continue;
          if (i2 <= 0 || i2 >= 1) continue;
          const o2 = 360 * a2 - 180, r2 = 180 * i2 - 90;
          t3.push([o2, r2]);
        }
        return t3.push([0, -90]), t3.push([0, 90]), t3;
      })(), o = mn.get(n2) ?? (() => {
        const e3 = new KDBush(i.length, void 0, Float32Array);
        for (let t3 = 0; t3 < i.length; t3++) {
          const n3 = i[t3];
          e3.add(n3[0], n3[1]);
        }
        return e3.finish(), e3;
      })(), r = around(o, e2[0], e2[1], void 0, t2 / 1e3).map(((e3) => i[e3]));
      return r;
    })(qe(e), Xe(e), Math.floor(Ge(e) + t + 1));
  } else {
    if (!Re(e)) throw new Error("Invalid state");
    n = (function(e2, t2) {
      const n2 = new SphericalMercator({ size: 1, antimeridian: true }), a = [...n2.px([e2[0], e2[1]], t2), ...n2.px([e2[2], e2[3]], t2)];
      [a[1], a[3]] = [a[3], a[1]];
      const i = 2 ** t2, o = a[2] - a[0] + 1, r = a[3] - a[1] + 1, A2 = [];
      for (let e3 = 0; e3 < r; e3++) for (let r2 = 0; r2 < o; r2++) {
        const o2 = a[0] + r2, s = [o2, a[1] + e3 + (o2 % 2 == 1 ? 0.5 : 0)];
        if (0 === s[0]) continue;
        if (s[1] <= 0 || s[1] >= i) continue;
        const l = n2.ll([s[0], s[1]], t2);
        l[0] = Oe(l[0]), A2.push(l);
      }
      return A2;
    })(Ke(e), Math.floor(Ge(e) + t));
  }
  return n;
}
var vn = { VALUE: "VALUE", ARROW: "ARROW", WIND_BARB: "WIND_BARB" };
var fn = /* @__PURE__ */ new Map([[vn.ARROW, { iconAtlas: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAFtGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgeG1wOkNyZWF0ZURhdGU9IjIwMjMtMDMtMTBUMTQ6NDE6MjYrMDEwMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDItMTFUMjM6Mzc6NTErMDE6MDAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDItMTFUMjM6Mzc6NTErMDE6MDAiCiAgIHBob3Rvc2hvcDpEYXRlQ3JlYXRlZD0iMjAyMy0wMy0xMFQxNDo0MToyNiswMTAwIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEi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", iconMapping: { 0: { x: 0, y: 0, width: 100, height: 100, mask: true } } }], [vn.WIND_BARB, { iconAtlas: "data:image/png;base64,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YOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYOCvs1WZAAECBAgQIECAAAECBAhsJmDg34zehQkQIECAAAECBAgQIECAQJ2Agb/OVmUCBAgQIECAAAECBAgQILCZgIF/M3oXJkCAAAECBAgQIECAAAECdQIG/jpblQkQIECAAAECBAgQIECAwGYCBv7N6F2YAAECBAgQIECAAAECBAjUCRj462xVJkCAAAECBAgQIECAAAECmwkY+Dejd2ECBAgQIECAAAECBAgQIFAnYODPs/2hiHgur9ziSk9GxMuLX+UFownI6Wgdb3O/ctpm30ZbtZyO1vE29yunbfZttFXLaWHHDfx5uFsFdRryn46It/O2olLHAnLacXM72pqcdtTMjrcipx03t6OtyWlHzex4K3Ja2FwDfx7u2kGdBvxp0Heqn9fDESrJ6Qhdbn+Pctp+D0fYgZyO0OX29yin7fdwhB3IaWGXDfx5uGsG1al+Xt9GqySno3W8zf3KaZt9G23Vcjpax9vcr5y22bfRVi2nhR038OfhrhFUp/p5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AQIECBBIEDDwJyAa+PMQVSoXODRInbqoU/3ylrjAAQEDv1gQIECAAAECBBIEDPwJiAb+PESVygXmDvxO9ctb4QInBAz84kGAAAECBAgQSBAw8CcgGvjzEFUqF5gz8DvVL2+DC5wRMPCLCAECBAgQIEAgQcDAn4Bo4M9DVKlc4NTA71S/nN8FZgoY+GdCeRoBAgQIECBA4JSAgT8vH96g5lmqVCdwbOB3ql9nrvJyAffT5WZeQYAAAQIECBD4gICBPy8U3qDmWapUJ3Aop69GxGN1l1SZwGIB99PFZF5AgAABAgQIEPiggIE/LxXeoOZZqlQnIKd1tirnCchpnqVKBAgQIECAwMACBv685nuDmmepUp2AnNbZqpwnIKd5lioRIECAAAECAwsY+POa7w1qnqVKdQJyWmercp6AnOZZqkSAAAECBAgMLGDgz2u+N6h5lirVCchpna3KeQJymmepEgECBAgQIDCwgIE/r/neoOZZqlQnIKd1tirnCchpnqVKBAgQIECAwMACBv685nuDmmepUp2AnNbZqpwnIKd5lioRIECAAAECAwsY+POa7w1qnqVKdQJyWmercp6AnOZZqkSAAAECBAgMLGDgz2u+N6h5lirVCchpna3KeQJymmepEgECBAgQIDCwgIE/r/neoOZZqlQnIKd1tirnCchpnqVKBAgQIECAwMACBv685nuDmmepUp2AnNbZqpwnIKd5lioRIECAAAECAwsY+POa7w1qnqVKdQJyWmercp6AnOZZqkSAAAECBAgMLGDgz2u+N6h5lirVCchpna3KeQJymmepEgECBAgQIDCwgIE/r/neoOZZqlQnIKd1tirnCchpnqVKBAgQIECAwMACBv685nuDmmepUp2AnNbZqpwnIKd5lioRIECAAAECAwsY+Aduvq0TIECAAAECBAgQIECAQL8CBv5+e2tnBAgQIECAAAECBAgQIDCwgIF/4ObbOgECBAgQIECAAAECBAj0K2Dg77e3dkaAAAECBAgQIECAAAECAwsY+Aduvq0TIECAAAECBAgQIECAQL8CBv5+e2tnBAgQIECAAAECBAgQIDCwgIF/4ObbOgECBAgQIECAAAECBAj0K2Dg77e3dkaAAAECBAgQIECAAAECAwsY+Aduvq0TIECAAAECBAgQIECAQL8CBv5+e2tnBAgQIECAAAECBAgQIDCwgIF/4ObbOgECBAgQIECAAAECBAj0K2Dg77e3dkaAAAECBAgQIECAAAECAwsY+Aduvq0TIECAAAECBAgQIECAQL8CBv5+e2tnBAgQIECAAAECBAgQIDCwgIF/4ObbOgECBAgQIECAAAECBAj0K2Dg77e3dkaAAAECBAgQIECAAAECAwsY+Aduvq0TIECAAAECBAgQIECAQL8CBv5+e2tnBAgQIECAAAECBAgQIDCwgIF/4ObbOgECBAgQIECAAAECBAj0K2Dg77e3dkaAAAECBAgQIECAAAECAwsY+Aduvq0TIECAAAECBAgQIECAQL8CBv5+e2tnBAgQIECAAAECBAgQIDCwgIF/4ObbOgECBAgQIECAAAECBAj0K2Dg77e3dkaAAAECBAgQIECAAAECAwsY+Aduvq0TIECAAAECBAgQIECAQL8CBv5+e2tnBAgQIECAAAECBAgQIPD/t1/HBAAAAAjC+re2hyyC8yIsIPjD55tOgAABAgQIECBAgAABAr8Cgv/3W8sIECBAgAABAgQIECBAICwg+MPnm06AAAECBAgQIECAAAECvwKC//dbywgQIECAAAECBAgQIEAgLCD4w+ebToAAAQIECBAgQIAAAQK/AoL/91vLCBAgQIAAAQIECBAgQCAsIPjD55tOgAABAgQIECBAgAABAr8Cgv/3W8sIECBAgAABAgQIECBAICwg+MPnm06AAAECBAgQIECAAAECvwKC//dbywgQIECAAAECBAgQIEAgLCD4w+ebToAAAQIECBAgQIAAAQK/AgOYR34g/YMI8gAAAABJRU5ErkJggg==", iconMapping: { 0: { x: 0, y: 0, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 1: { x: 170, y: 0, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 2: { x: 340, y: 0, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 3: { x: 510, y: 0, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 4: { x: 680, y: 0, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 5: { x: 850, y: 0, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 6: { x: 0, y: 170, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 7: { x: 170, y: 170, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 8: { x: 340, y: 170, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 9: { x: 510, y: 170, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 10: { x: 680, y: 170, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 11: { x: 850, y: 170, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 12: { x: 0, y: 340, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 13: { x: 170, y: 340, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 14: { x: 340, y: 340, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 15: { x: 510, y: 340, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 16: { x: 680, y: 340, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 17: { x: 850, y: 340, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 18: { x: 0, y: 510, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 19: { x: 170, y: 510, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true }, 20: { x: 340, y: 510, width: 170, height: 170, anchorX: 85, anchorY: 133, mask: true } }, iconBounds: [0, 51.444] }]]);
var In = { image: { type: "object", value: null }, image2: { type: "object", value: null }, imageSmoothing: { type: "number", value: 0 }, imageInterpolation: { type: "object", value: re.CUBIC }, imageWeight: { type: "number", value: 0 }, imageType: { type: "object", value: Ae.SCALAR }, imageUnscale: { type: "array", value: null }, imageMinValue: { type: "object", value: null }, imageMaxValue: { type: "object", value: null }, bounds: { type: "array", value: [-180, -90, 180, 90], compare: true }, minZoom: { type: "object", value: null }, maxZoom: { type: "object", value: null }, style: { type: "object", value: vn.VALUE }, density: { type: "number", value: 0 }, unitFormat: { type: "object", value: null }, textFormatFunction: { type: "function", value: R }, textFontFamily: { type: "object", value: L }, textSize: { type: "number", value: 12 }, textColor: { type: "color", value: k }, textOutlineWidth: { type: "number", value: 1 }, textOutlineColor: { type: "color", value: J }, iconBounds: { type: "array", value: null }, iconSize: { type: "object", value: 40 }, iconColor: { type: "color", value: q }, palette: { type: "object", value: null } };
var En = class extends composite_layer_default {
  renderLayers() {
    const { viewport: e } = this.context, { props: t, visiblePoints: n } = this.state;
    if (!t || !n) return [];
    const { style: a, unitFormat: i, textFormatFunction: o, textFontFamily: A2, textSize: l, textColor: c, textOutlineWidth: g, textOutlineColor: u, iconSize: p, iconColor: d } = X(t, In), { paletteScale: h } = this.state;
    if (fn.has(a)) {
      const { iconStyle: a2, iconAtlasTexture: i2 } = this.state;
      if (!a2 || !i2) return [];
      const o2 = Object.keys(a2.iconMapping).length, r = t.iconBounds ?? a2.iconBounds ?? [0, 0], A3 = r[1] - r[0], l2 = (e2) => (e2 - r[0]) / A3, c2 = Array.isArray(p) ? p[1] - p[0] : 0;
      return [new icon_layer_default(this.getSubLayerProps({ id: "icon", data: n, getPosition: (e2) => e2.geometry.coordinates, getIcon: (e2) => `${Math.min(Math.max(Math.floor(l2(e2.properties.value) * o2), 0), o2 - 1)}`, getSize: (e2) => Array.isArray(p) ? p[0] + l2(e2.properties.value) * c2 : p, getColor: (e2) => h ? at(h(e2.properties.value).rgba()) : d, getAngle: (t2) => je(e, t2.properties.direction ? 360 - t2.properties.direction : 0), iconAtlas: i2, iconMapping: a2.iconMapping, billboard: false, parameters: { cullMode: "front", depthCompare: "always", ...this.props.parameters } }))];
    }
    return [new text_layer_default(this.getSubLayerProps({ id: "text", data: n, getPosition: (e2) => e2.geometry.coordinates, getText: (e2) => o(e2.properties.value, i), getSize: l, getColor: (e2) => h ? at(h(e2.properties.value).rgba()) : c, getAngle: je(e, 0), outlineWidth: g, outlineColor: u, fontFamily: A2, fontSettings: { sdf: true }, billboard: false, parameters: { cullMode: "front", depthCompare: "always", ...this.props.parameters } }))];
  }
  shouldUpdateState(e) {
    return super.shouldUpdateState(e) || e.changeFlags.viewportChanged;
  }
  initializeState() {
    this._updatePositions();
  }
  updateState(e) {
    const { image: t, image2: n, imageSmoothing: a, imageInterpolation: i, imageWeight: o, imageType: r, imageUnscale: A2, imageMinValue: s, imageMaxValue: l, minZoom: c, maxZoom: g, style: u, density: p, unitFormat: d, textFormatFunction: h, textFontFamily: m, textSize: C, textColor: v, textOutlineWidth: f, textOutlineColor: I, iconSize: E, iconColor: B, palette: Q, visible: y2 } = e.props;
    super.updateState(e), y2 ? (this.state.iconStyle && u === e.oldProps.style || this._updateIconStyle(), (p !== e.oldProps.density || e.changeFlags.viewportChanged) && this._updatePositions(), t === e.oldProps.image && n === e.oldProps.image2 && a === e.oldProps.imageSmoothing && i === e.oldProps.imageInterpolation && o === e.oldProps.imageWeight && r === e.oldProps.imageType && A2 === e.oldProps.imageUnscale && s === e.oldProps.imageMinValue && l === e.oldProps.imageMaxValue && y2 === e.oldProps.visible || this._updateFeatures(), (c !== e.oldProps.minZoom || g !== e.oldProps.maxZoom || e.changeFlags.viewportChanged) && this._updateVisibleFeatures(), Q !== e.oldProps.palette && this._updatePalette(), d === e.oldProps.unitFormat && h === e.oldProps.textFormatFunction && m === e.oldProps.textFontFamily && C === e.oldProps.textSize && v === e.oldProps.textColor && f === e.oldProps.textOutlineWidth && I === e.oldProps.textOutlineColor && E === e.oldProps.iconSize && B === e.oldProps.iconColor || this._redrawVisibleFeatures(), this.setState({ props: e.props })) : this.setState({ points: void 0, visiblePoints: void 0 });
  }
  async _updateIconStyle() {
    const { device: e } = this.context, { style: t } = X(this.props, In), n = fn.get(t);
    if (!n) return void this.setState({ iconStyle: void 0, iconAtlasTexture: void 0 });
    this.setState({ iconStyle: n });
    const a = He(e, await _(n.iconAtlas));
    this.setState({ iconAtlasTexture: a });
  }
  _updatePositions() {
    const { viewport: e } = this.context, { density: t } = X(this.props, In), n = Cn(e, t + 3);
    this.setState({ positions: n }), this._updateFeatures();
  }
  _updateFeatures() {
    const { image: e, image2: t, imageSmoothing: n, imageInterpolation: a, imageWeight: i, imageType: o, imageUnscale: r, imageMinValue: A2, imageMaxValue: s, bounds: l } = X(this.props, In), { positions: c } = this.state;
    if (!e || !c) return;
    const g = Ne({ image: e, image2: t, imageSmoothing: n, imageInterpolation: a, imageWeight: i, imageType: o, imageUnscale: r, imageMinValue: A2, imageMaxValue: s }, l, c).features.filter(((e2) => !isNaN(e2.properties.value)));
    this.setState({ points: g }), this._updateVisibleFeatures();
  }
  _updateVisibleFeatures() {
    const { viewport: e } = this.context, { minZoom: t, maxZoom: n } = X(this.props, In), { points: a } = this.state;
    if (!a) return;
    let i;
    i = We(e, t, n) ? a : [], this.setState({ visiblePoints: i });
  }
  _updatePalette() {
    const { palette: e } = X(this.props, In);
    if (!e) return this.setState({ paletteScale: void 0 }), void this._redrawVisibleFeatures();
    const n = parsePalette(e);
    this.setState({ paletteScale: n }), this._redrawVisibleFeatures();
  }
  _redrawVisibleFeatures() {
    this.setState({ visiblePoints: Array.isArray(this.state.visiblePoints) ? Array.from(this.state.visiblePoints) : this.state.visiblePoints });
  }
};
En.layerName = "GridCompositeLayer", En.defaultProps = In;
var Bn = { ...En.defaultProps };
var Qn = class extends composite_layer_default {
  renderLayers() {
    const { props: e } = this.state;
    return e ? [new En(this.props, this.getSubLayerProps({ id: "composite" }))] : [];
  }
  updateState(e) {
    const { image: t, imageUnscale: n } = e.props;
    if (super.updateState(e), t && n && !(t.data instanceof Uint8Array || t.data instanceof Uint8ClampedArray)) throw new Error("imageUnscale can be applied to Uint8 data only");
    this.setState({ props: e.props });
  }
};
Qn.layerName = "GridLayer", Qn.defaultProps = Bn;
var yn = "uniform particleUniforms{float q;vec2 r;float s;vec4 t;float u;float v;float w;float x;float y;float z;}particle;";
var bn = "q";
var wn = "r";
var xn = "s";
var Tn = "t";
var Mn = "u";
var Pn = "v";
var Dn = "w";
var On = "x";
var Sn = "y";
var Vn = "z";
var Un = { name: "particle", vs: yn, fs: yn, uniformTypes: { [bn]: "f32", [wn]: "vec2<f32>", [xn]: "f32", [Tn]: "vec4<f32>", [Mn]: "f32", [Pn]: "f32", [Dn]: "f32", [On]: "f32", [Sn]: "f32", [Vn]: "f32" }, getUniforms: function(e = {}) {
  return { [bn]: e.viewportGlobe ? 1 : 0, [wn]: e.viewportGlobeCenter ?? [0, 0], [xn]: e.viewportGlobeRadius ?? 0, [Tn]: e.viewportBounds ?? [0, 0, 0, 0], [Mn]: e.viewportZoomChangeFactor ?? 0, [Pn]: e.numParticles, [Dn]: e.maxAge, [On]: e.speedFactor, [Sn]: e.time, [Vn]: e.seed };
} };
var Nn = "sourcePosition";
var Ln = "targetPosition";
var Fn = "sourceColor";
var kn = "targetColor";
var Zn = { imageTexture: { type: "object", value: null }, imageTexture2: { type: "object", value: null }, imageSmoothing: { type: "number", value: 0 }, imageInterpolation: { type: "object", value: re.CUBIC }, imageWeight: { type: "number", value: 0 }, imageType: { type: "object", value: Ae.VECTOR }, imageUnscale: { type: "array", value: null }, imageMinValue: { type: "object", value: null }, imageMaxValue: { type: "object", value: null }, bounds: { type: "array", value: [-180, -90, 180, 90], compare: true }, minZoom: { type: "object", value: null }, maxZoom: { type: "object", value: 15 }, palette: { type: "object", value: null }, color: { type: "color", value: N }, numParticles: { type: "number", min: 1, max: 1e6, value: 5e3 }, maxAge: { type: "number", min: 1, max: 255, value: 10 }, speedFactor: { type: "number", min: 0, max: 50, value: 1 }, width: { type: "number", value: 1 }, animate: true, wrapLongitude: true };
var Jn = class extends line_layer_default {
  getShaders() {
    const e = super.getShaders();
    return { ...e, inject: { ...e.inject, "vs:#decl": (e.inject?.["vs:#decl"] || "") + "\n          in float instanceOpacities;\n          out float drop;\n          const float DROP_POSITION_Z = -1.;\n        ", "vs:#main-start": (e.inject?.["vs:#main-start"] || "") + "\n          drop = float(instanceSourcePositions.z == DROP_POSITION_Z || instanceTargetPositions.z == DROP_POSITION_Z);\n        ", "vs:DECKGL_FILTER_COLOR": (e.inject?.["vs:DECKGL_FILTER_COLOR"] || "") + "\n          color.a = color.a * instanceOpacities;\n        ", "fs:#decl": (e.inject?.["fs:#decl"] || "") + "\n          in float drop;\n        ", "fs:#main-start": (e.inject?.["fs:#main-start"] || "") + "\n          if (drop > 0.5) discard;\n        " } };
  }
  initializeState() {
    super.initializeState(), this._setupTransformFeedback();
    const e = this.getAttributeManager();
    e.remove(["instanceSourcePositions", "instanceTargetPositions", "instanceColors", "instanceWidths"]), e.addInstanced({ instanceSourcePositions: { size: 3, type: "float32", noAlloc: true }, instanceTargetPositions: { size: 3, type: "float32", noAlloc: true }, instanceColors: { size: 4, type: "float32", noAlloc: true }, instanceOpacities: { size: 1, type: "float32", noAlloc: true } });
  }
  updateState(e) {
    const { imageType: t, numParticles: n, maxAge: a, width: i, palette: o } = e.props;
    super.updateState(e), t === Ae.VECTOR && n && a && i ? (t === e.oldProps.imageType && n === e.oldProps.numParticles && a === e.oldProps.maxAge && i === e.oldProps.width || this._setupTransformFeedback(), o !== e.oldProps.palette && this._updatePalette()) : this._deleteTransformFeedback();
  }
  finalizeState(e) {
    this._deleteTransformFeedback(), super.finalizeState(e);
  }
  draw(e) {
    const { initialized: t } = this.state;
    if (!t) return;
    const { viewport: n } = this.context, { model: a } = this.state, { minZoom: i, maxZoom: o, width: r, animate: A2 } = X(this.props, Zn), { sourcePositions: s, targetPositions: l, sourceColors: c, opacities: g, transform: u } = this.state;
    s && l && c && g && u && a && We(n, i, o) && (a.setAttributes({ instanceSourcePositions: s, instanceTargetPositions: l, instanceColors: c, instanceOpacities: g }), a.setConstantAttributes({ instanceSourcePositions64Low: new Float32Array([0, 0, 0]), instanceTargetPositions64Low: new Float32Array([0, 0, 0]), instanceWidths: new Float32Array([r]) }), a.setParameters({ ...a.parameters, cullMode: "front", depthCompare: "always", ...this.props.parameters }), super.draw(e), A2 && this.step());
  }
  _setupTransformFeedback() {
    const { device: e } = this.context, { initialized: t } = this.state;
    t && this._deleteTransformFeedback();
    const { numParticles: n, maxAge: a } = X(this.props, Zn), i = n * a, o = n * (a - 1), r = e.createBuffer(new Float32Array(3 * i)), A2 = e.createBuffer(new Float32Array(3 * i)), s = e.createBuffer(new Float32Array(4 * i)), l = e.createBuffer(new Float32Array(4 * i)), c = e.createBuffer(new Float32Array(new Array(i).fill(void 0).map(((e2, t2) => 1 - Math.floor(t2 / n) / a)))), g = new BufferTransform(e, { vs: "#version 300 es\n#define SHADER_NAME  particle-line-layer-update-vertex-shader\n#ifdef GL_ES\nprecision highp float;\n#endif\nvec4 AA(sampler2D AB,vec2 AC,vec2 AD,vec2 AE){vec2 uv=(AD+AE+0.5)/AC;return texture(AB,uv);}const vec4 AF=vec4(3.,-6.,0.,4.)/6.;const vec4 AG=vec4(-1.,6.,-12.,8.)/6.;vec4 AH(float J){return vec4(J*J*J,J*J,J,1.);}vec4 AI(vec4 AJ,vec4 AK,vec4 AL,vec4 AM,float AN){vec4 O=AJ*dot(AG,AH(AN+1.))+AK*dot(AF,AH(AN))+AL*dot(AF,AH(1.-AN))+AM*dot(AG,AH(2.-AN));O.a=(AJ.a>0.&&AK.a>0.&&AL.a>0.&&AM.a>0.)?max(max(max(AJ.a,AK.a),AL.a),AM.a):0.;return O;}vec4 AO(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP);vec2 AQ=fract(AP);return AI(AI(AA(AB,AC,AD,vec2(-1,-1)),AA(AB,AC,AD,vec2(0,-1)),AA(AB,AC,AD,vec2(1,-1)),AA(AB,AC,AD,vec2(2,-1)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,0)),AA(AB,AC,AD,vec2(0,0)),AA(AB,AC,AD,vec2(1,0)),AA(AB,AC,AD,vec2(2,0)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,1)),AA(AB,AC,AD,vec2(0,1)),AA(AB,AC,AD,vec2(1,1)),AA(AB,AC,AD,vec2(2,1)),AQ.x),AI(AA(AB,AC,AD,vec2(-1,2)),AA(AB,AC,AD,vec2(0,2)),AA(AB,AC,AD,vec2(1,2)),AA(AB,AC,AD,vec2(2,2)),AQ.x),AQ.y);}vec4 AR(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP);vec2 AQ=fract(AP);return mix(mix(AA(AB,AC,AD,vec2(0,0)),AA(AB,AC,AD,vec2(1,0)),AQ.x),mix(AA(AB,AC,AD,vec2(0,1)),AA(AB,AC,AD,vec2(1,1)),AQ.x),AQ.y);}vec4 AS(sampler2D AB,vec2 AC,vec2 uv){vec2 AP=uv*AC-0.5;vec2 AD=floor(AP+0.5);return AA(AB,AC,AD,vec2(0,0));}vec4 AT(sampler2D AB,vec2 AC,float a,vec2 uv){if(a==2.){return AO(AB,AC,uv);}if(a==1.){return AR(AB,AC,uv);}else{return AS(AB,AC,uv);}}vec4 AU(sampler2D AB,sampler2D AV,vec2 AC,float a,float b,bool B,vec2 uv){vec2 AW;AW.x=B?uv.x+0.5/AC.x:mix(0.+0.5/AC.x,1.-0.5/AC.x,uv.x);AW.y=mix(0.+0.5/AC.y,1.-0.5/AC.y,uv.y);if(b>0.){vec4 AX=AT(AB,AC,a,AW);vec4 AY=AT(AV,AC,a,AW);return mix(AX,AY,b);}else{return AT(AB,AC,a,AW);}}vec4 AZ(sampler2D AB,sampler2D AV,vec2 Y,float Z,float a,float b,bool B,vec2 uv){float Aa=1.+max(0.,Z);vec2 AC=Y/Aa;return AU(AB,AV,AC,a,b,B,uv);}float Ab(float K,float J){return J==0.?sign(K)*F/2.:atan(K,J);}bool Ac(float k){uint Ad=floatBitsToUint(k);return(Ad&0x7fffffffu)>0x7f800000u;}bool Ae(vec4 AX,vec2 d){if(d[0]<d[1]){return AX.a>=1.;}else{return!Ac(AX.x);}}float Af(vec4 AX,float c,vec2 d){if(c==1.){return 0.;}else{if(d[0]<d[1]){return mix(d[0],d[1],AX.x);}else{return AX.x;}}}vec2 Ag(vec4 AX,float c,vec2 d){if(c==1.){if(d[0]<d[1]){return mix(vec2(d[0]),vec2(d[1]),AX.xy);}else{return AX.xy;}}else{return vec2(0.);}}float Ah(vec4 AX,float c,vec2 d){if(c==1.){vec2 k=Ag(AX,c,d);return length(k);}else{return Af(AX,c,d);}}float Ai(vec4 AX,float c,vec2 d){if(c==1.){vec2 k=Ag(AX,c,d);return mod((360.-(Ab(k.y,k.x)/F*180.+180.))-270.,360.)/360.;}else{return 0.;}}in vec3 sourcePosition;in vec4 sourceColor;out vec3 targetPosition;out vec4 targetColor;const float Aj=-1.;const vec4 Ak=vec4(0);const float Al=6370972.;vec2 Am(vec2 An,float Ao,float Ap){float Aq=Ao/Al;float Ar=radians(Ap);float As=radians(An.y);float At=radians(An.x);float Au=sin(As)*cos(Aq)+cos(As)*sin(Aq)*cos(Ar);float Av=asin(Au);float K=sin(Ar)*sin(Aq)*cos(As);float J=cos(Aq)-sin(As)*Au;float Aw=At+Ab(K,J);float Ax=degrees(Av);float Ay=degrees(Aw);return vec2(Ay,Ax);}float Az(float BA){float BB=mod(BA+180.,360.)-180.;return BB;}float Az(float BA,float BC){float BB=Az(BA);if(BB<BC){BB+=360.;}return BB;}float BD(vec2 z){return fract(sin(dot(z.xy,vec2(12.9898,78.233)))*43758.5453);}vec2 BE(vec2 z){return vec2(BD(z+1.3),BD(z+2.1));}vec2 BF(vec2 BG){if(particle.q==1.){BG.x+=0.0001;BG.x=sqrt(BG.x);float Ao=BG.x*particle.s;float Ap=BG.y*360.;return Am(particle.r,Ao,Ap);}else{BG.y=smoothstep(0.,1.,BG.y);vec2 BH=particle.t.xy;vec2 BI=particle.t.zw;return mix(BH,BI,BG);}}vec2 BJ(vec2 BK,vec2 BL){float BM=cos(radians(BK.y));vec2 AE;if(particle.q==1.){AE=vec2(BL.x/BM,BL.y);}else{AE=vec2(BL.x,BL.y*BM);}return BK+AE;}bool BN(vec2 BK,vec4 A){vec2 BO=A.xy;vec2 BP=A.zw;float BA=Az(BK.x,BO.x);float Ax=BK.y;return(BO.x<=BA&&BA<=BP.x&&BO.y<=Ax&&Ax<=BP.y);}void main(){float BQ=mod(float(gl_VertexID),particle.v);float BR=floor(float(gl_VertexID)/particle.v);if(BR>0.){return;}if(sourcePosition.z==Aj){vec2 BS=vec2(BQ*particle.z/particle.v);vec2 BG=BE(BS);vec2 BK=BF(BG);targetPosition.xy=BK;targetPosition.x=Az(targetPosition.x);targetColor=Ak;return;}if(particle.u>1.&&mod(BQ,particle.u)>=1.){targetPosition.xy=sourcePosition.xy;targetPosition.z=Aj;targetColor=Ak;return;}if(abs(mod(BQ,particle.w+2.)-mod(particle.y,particle.w+2.))<1.){targetPosition.xy=sourcePosition.xy;targetPosition.z=Aj;targetColor=Ak;return;}if(!BN(sourcePosition.xy,bitmap2.A)){targetPosition.xy=sourcePosition.xy;targetColor=Ak;return;}vec2 uv=Q(sourcePosition.xy);vec4 AX=AZ(W,X,raster.Y,raster.Z,raster.a,raster.b,bitmap2.B,uv);if(!Ae(AX,raster.d)){targetPosition.xy=sourcePosition.xy;targetColor=Ak;return;}float k=Ah(AX,raster.c,raster.d);if((!Ac(raster.e)&&k<raster.e)||(!Ac(raster.f)&&k>raster.f)){targetPosition.xy=sourcePosition.xy;targetColor=Ak;return;}vec2 BL=Ag(AX,raster.c,raster.d)*particle.x;targetPosition.xy=BJ(sourcePosition.xy,BL);targetPosition.x=Az(targetPosition.x);targetColor=sourceColor;targetColor=l(g,palette.h,palette.i,k);}", modules: [ht, xt, Ot, Un], vertexCount: n, attributes: { [Nn]: r, [Fn]: s }, bufferLayout: [{ name: Nn, format: "float32x3" }, { name: Fn, format: "float32x4" }], feedbackBuffers: { [Ln]: A2, [kn]: l }, varyings: [Ln, kn] });
    this.setState({ initialized: true, numInstances: i, numAgedInstances: o, sourcePositions: r, targetPositions: A2, sourceColors: s, targetColors: l, opacities: c, transform: g, previousViewportZoom: 0, previousTime: 0 });
  }
  _runTransformFeedback() {
    const { initialized: e } = this.state;
    if (!e) return;
    const { device: t, viewport: a, timeline: i } = this.context, { imageTexture: o, imageTexture2: r, imageSmoothing: A2, imageInterpolation: s, imageWeight: l, imageType: c, imageUnscale: g, imageMinValue: u, imageMaxValue: p, bounds: d, color: h, numParticles: m, maxAge: C, speedFactor: v } = X(this.props, Zn), { paletteTexture: f, paletteBounds: I, numAgedInstances: E, sourcePositions: B, targetPositions: Q, sourceColors: y2, targetColors: b2, transform: w2, previousViewportZoom: x2, previousTime: T2 } = this.state;
    if (!(o && "number" == typeof E && B && Q && y2 && b2 && w2)) return;
    const M2 = i.getTime();
    if ("number" == typeof T2 && M2 < T2 + 1e3 / 30) return;
    const P2 = Je(a), D2 = Je(a) ? qe(a) : void 0, O2 = Je(a) ? Xe(a) : void 0, S2 = Re(a) ? Ke(a) : void 0, V2 = 2 ** (4 * ("number" == typeof x2 ? x2 - Ge(a) : 0)), U2 = v / 2 ** (Ge(a) + 7);
    w2.model.shaderInputs.setProps({ [ht.name]: { viewportGlobe: P2, bounds: d, _imageCoordinateSystem: COORDINATE_SYSTEM.LNGLAT }, [xt.name]: { imageTexture: o ?? et(t), imageTexture2: r ?? et(t), imageSmoothing: A2, imageInterpolation: s, imageWeight: l, imageType: c, imageUnscale: g, imageMinValue: u, imageMaxValue: p }, [Ot.name]: { paletteTexture: f ?? et(t), paletteBounds: I, paletteColor: h }, [Un.name]: { viewportGlobe: P2, viewportGlobeCenter: D2, viewportGlobeRadius: O2, viewportBounds: S2, viewportZoomChangeFactor: V2, numParticles: m, maxAge: C, speedFactor: U2, time: M2, seed: Math.random() } }), w2.run({ clearColor: false, clearDepth: false, clearStencil: false, depthReadOnly: true, stencilReadOnly: true });
    const N2 = t.createCommandEncoder();
    N2.copyBufferToBuffer({ sourceBuffer: B, sourceOffset: 0, destinationBuffer: Q, destinationOffset: 4 * m * 3, size: 4 * E * 3 }), N2.copyBufferToBuffer({ sourceBuffer: y2, sourceOffset: 0, destinationBuffer: b2, destinationOffset: 4 * m * 4, size: 4 * E * 4 }), N2.finish(), N2.destroy(), this._swapTransformFeedback(), this.state.previousViewportZoom = Ge(a), this.state.previousTime = M2;
  }
  _swapTransformFeedback() {
    const { sourcePositions: e, targetPositions: t, sourceColors: n, targetColors: a, transform: i } = this.state;
    e && t && n && a && i && (this.state.sourcePositions = t, this.state.targetPositions = e, this.state.sourceColors = a, this.state.targetColors = n, i.model.setAttributes({ [Nn]: t, [Fn]: a }), i.transformFeedback.setBuffers({ [Ln]: e, [kn]: n }));
  }
  _resetTransformFeedback() {
    const { initialized: e } = this.state;
    if (!e) return;
    const { numInstances: t, sourcePositions: n, targetPositions: a, sourceColors: i, targetColors: o } = this.state;
    "number" == typeof t && n && a && i && o && (n.write(new Float32Array(3 * t)), a.write(new Float32Array(3 * t)), i.write(new Float32Array(4 * t)), o.write(new Float32Array(4 * t)));
  }
  _deleteTransformFeedback() {
    const { initialized: e } = this.state;
    if (!e) return;
    const { sourcePositions: t, targetPositions: n, sourceColors: a, targetColors: i, opacities: o, transform: r } = this.state;
    t && n && a && i && o && r && (t.destroy(), n.destroy(), a.destroy(), i.destroy(), o.destroy(), r.destroy(), this.setState({ initialized: false, sourcePositions: void 0, targetPositions: void 0, sourceColors: void 0, targetColors: void 0, opacities: void 0, transform: void 0 }));
  }
  _updatePalette() {
    const { device: e } = this.context, { palette: n } = X(this.props, Zn);
    if (!n) return void this.setState({ paletteTexture: void 0, paletteBounds: void 0 });
    const a = parsePalette(n), { paletteBounds: i, paletteTexture: o } = tt(e, a);
    this.setState({ paletteTexture: o, paletteBounds: i });
  }
  step() {
    this._runTransformFeedback(), this.setNeedsRedraw();
  }
  clear() {
    this._resetTransformFeedback(), this.setNeedsRedraw();
  }
};
Jn.layerName = "ParticleLineLayer", Jn.defaultProps = Zn;
var Rn = { ...Jn.defaultProps, imageTexture: void 0, imageTexture2: void 0, image: { type: "object", value: null }, image2: { type: "object", value: null } };
var Wn = class extends composite_layer_default {
  renderLayers() {
    const { device: e } = this.context, { props: t, imageTexture: n, imageTexture2: a } = this.state;
    return t && n ? [new Jn(this.props, this.getSubLayerProps({ id: "line", data: [], imageTexture: n, imageTexture2: a, image: et(e), image2: et(e) }))] : [];
  }
  updateState(e) {
    const { image: t, image2: n, imageUnscale: a, bounds: i } = e.props;
    if (super.updateState(e), t && a && !(t.data instanceof Uint8Array || t.data instanceof Uint8ClampedArray)) throw new Error("imageUnscale can be applied to Uint8 data only");
    if (t !== e.oldProps.image || n !== e.oldProps.image2) {
      const { device: e2 } = this.context, { image: t2, image2: n2 } = this.props, a2 = t2 ? He(e2, t2, Se(i)) : null, o = n2 ? He(e2, n2, Se(i)) : null;
      this.setState({ imageTexture: a2, imageTexture2: o });
    }
    this.setState({ props: e.props });
  }
};
Wn.layerName = "ParticleLayer", Wn.defaultProps = Rn;
var qn = class {
  addTo(e) {
    e.appendChild(this.onAdd());
  }
  prependTo(e) {
    e.prepend(this.onAdd());
  }
  remove() {
    this.onRemove();
  }
  updateConfig(e) {
    this.setConfig({ ...this.getConfig(), ...e });
  }
};
function Xn(e, t) {
  void 0 === t && (t = {});
  var n = t.insertAt;
  if (e && "undefined" != typeof document) {
    var a = document.head || document.getElementsByTagName("head")[0], i = document.createElement("style");
    i.type = "text/css", "top" === n && a.firstChild ? a.insertBefore(i, a.firstChild) : a.appendChild(i), i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(document.createTextNode(e));
  }
}
Xn(".weatherlayers-legend-control{margin:10px;pointer-events:auto}.weatherlayers-legend-control>div{background:hsla(0,0%,100%,.5);color:rgba(0,0,0,.75);display:inline-block;font-family:Helvetica Neue,Arial,Helvetica,sans-serif;font-size:12px;line-height:14px;width:100%}.weatherlayers-legend-control header,.weatherlayers-legend-control main{margin:5px 10px}.weatherlayers-legend-control header{font-weight:700}.weatherlayers-legend-control__legend{margin-top:5px;vertical-align:middle;width:100%}");
var Kn = "weatherlayers-legend-control";
var Gn = `${Kn}__text`;
var zn = class extends qn {
  constructor(e = {}) {
    super(), this._container = void 0, this._config = e;
  }
  onAdd() {
    return this._container = document.createElement("div"), this._container.classList.add(Kn), this.setConfig(this._config), this._container;
  }
  onRemove() {
    this._container && this._container.parentNode && (this._container.parentNode.removeChild(this._container), this._container = void 0);
  }
  getConfig() {
    return { ...this._config };
  }
  setConfig(n) {
    if (!this._container) return;
    if (!n.title || !n.unitFormat || !n.palette) return;
    if (this._container.children.length > 0 && this._config.width === n.width && this._config.ticksCount === n.ticksCount && this._config.title === n.title && this._config.unitFormat === n.unitFormat && this._config.palette === n.palette) return;
    this._config = n;
    const a = this._config.width ?? 300, i = this._config.ticksCount ?? 6, o = this._config.title, r = this._config.unitFormat, A2 = this._config.palette, s = parsePalette(A2), l = s.domain(), c = [l[0], l[l.length - 1]], g = colorRampCanvas(s).toDataURL();
    this._container.innerHTML = "", this._container.style.width = `${a}px`;
    const u = document.createElement("div");
    this._container.appendChild(u);
    const p = document.createElement("header");
    u.appendChild(p);
    const d = document.createElement("span");
    d.classList.add(Gn), d.innerHTML = `${o} [${O(r)}]`, p.appendChild(d);
    const h = document.createElement("main");
    u.appendChild(h);
    const m = "http://www.w3.org/2000/svg", C = document.createElementNS(m, "svg");
    C.setAttribute("height", "24px"), C.setAttribute("class", "weatherlayers-legend-control__legend"), h.appendChild(C);
    const v = document.createElementNS(m, "image");
    v.setAttribute("href", g), v.setAttribute("width", "100%"), v.setAttribute("height", "5"), v.setAttribute("preserveAspectRatio", "none"), C.appendChild(v);
    const f = (c[1] - c[0]) / (i - 1);
    for (let e = 0; e < i; e++) {
      const t = c[0] + e * f, n2 = D(t, r), a2 = document.createElementNS(m, "g");
      a2.style.transform = `translate(${(t - c[0]) / (c[1] - c[0]) * 100}%, 0)`, C.appendChild(a2);
      const o2 = document.createElementNS(m, "line");
      o2.setAttribute("y1", "0"), o2.setAttribute("y2", "10"), o2.style.stroke = "currentColor", 0 === e ? o2.style.transform = "translate(0.5px, 0)" : e === i - 1 && (o2.style.transform = "translate(-0.5px, 0)"), a2.appendChild(o2);
      const A3 = document.createElementNS(m, "text");
      A3.innerHTML = n2, A3.setAttribute("x", "0"), A3.setAttribute("y", "22"), A3.style.textAnchor = 0 === e ? "start" : e === i - 1 ? "end" : "middle", a2.appendChild(A3);
    }
  }
};
Xn(`.weatherlayers-tooltip-control{margin:10px;pointer-events:auto}.weatherlayers-tooltip-control>div{align-items:center;background:hsla(0,0%,100%,.5);color:rgba(0,0,0,.75);display:inline-flex;font-family:Helvetica Neue,Arial,Helvetica,sans-serif;font-size:12px;line-height:20px;padding:0 5px;white-space:nowrap}.weatherlayers-tooltip-control.follow-cursor{margin:0;pointer-events:none;position:absolute;z-index:1}.weatherlayers-tooltip-control.follow-cursor>div{position:absolute}.leaflet-map-pane .weatherlayers-tooltip-control.follow-cursor{z-index:101}.weatherlayers-tooltip-control.follow-cursor:before{content:"";height:0;position:absolute;width:0}.weatherlayers-tooltip-control.follow-cursor[data-follow-cursor-placement=BOTTOM]:before{border-bottom:5px solid hsla(0,0%,100%,.5);border-left:5px solid transparent;border-right:5px solid transparent;left:calc(50% - 5px);top:-5px}.weatherlayers-tooltip-control.follow-cursor[data-follow-cursor-placement=TOP]:before{border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid hsla(0,0%,100%,.5);left:calc(50% - 5px);top:0}.weatherlayers-tooltip-control.follow-cursor[data-follow-cursor-placement=RIGHT]:before{border-bottom:5px solid transparent;border-right:5px solid hsla(0,0%,100%,.5);border-top:5px solid transparent;left:-5px;top:calc(50% - 5px)}.weatherlayers-tooltip-control.follow-cursor[data-follow-cursor-placement=LEFT]:before{border-bottom:5px solid transparent;border-left:5px solid hsla(0,0%,100%,.5);border-top:5px solid transparent;left:0;top:calc(50% - 5px)}.weatherlayers-tooltip-control .weatherlayers-tooltip-control__direction{align-items:center;display:inline-flex;margin-left:4px}.weatherlayers-tooltip-control .weatherlayers-tooltip-control__direction-icon{background:no-repeat 50%/contain;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30' style='enable-background:new 0 0 30 30' xml:space='preserve'%3E%3Cpath d='M3.74 14.5c0-2.04.51-3.93 1.52-5.66s2.38-3.1 4.11-4.11 3.61-1.51 5.64-1.51c1.52 0 2.98.3 4.37.89s2.58 1.4 3.59 2.4 1.81 2.2 2.4 3.6.89 2.85.89 4.39c0 1.52-.3 2.98-.89 4.37s-1.4 2.59-2.4 3.59-2.2 1.8-3.59 2.39-2.84.89-4.37.89c-1.53 0-3-.3-4.39-.89s-2.59-1.4-3.6-2.4-1.8-2.2-2.4-3.58-.88-2.84-.88-4.37zm2.48 0c0 2.37.86 4.43 2.59 6.18 1.73 1.73 3.79 2.59 6.2 2.59 1.58 0 3.05-.39 4.39-1.18s2.42-1.85 3.21-3.2 1.19-2.81 1.19-4.39-.4-3.05-1.19-4.4-1.86-2.42-3.21-3.21-2.81-1.18-4.39-1.18-3.05.39-4.39 1.18S8.2 8.75 7.4 10.1s-1.18 2.82-1.18 4.4zm4.89 5.85 3.75-13.11c.01-.1.06-.15.15-.15s.14.05.15.15l3.74 13.11c.04.11.03.19-.02.25s-.13.06-.24 0l-3.47-1.3c-.1-.04-.2-.04-.29 0l-3.5 1.3c-.1.06-.17.06-.21 0s-.08-.15-.06-.25z'/%3E%3C/svg%3E");display:inline-block;height:20px;opacity:.75;vertical-align:middle;width:20px}.weatherlayers-tooltip-control .weatherlayers-tooltip-control__direction-text{margin-left:2px}.weatherlayers-tooltip-control:not(.has-direction) .weatherlayers-tooltip-control__direction,.weatherlayers-tooltip-control:not(.has-value){display:none}`);
var jn = "weatherlayers-tooltip-control";
var Yn = `${jn}__value`;
var _n = `${jn}__direction`;
var Hn = `${jn}__direction-icon`;
var $n = `${jn}__direction-text`;
var ea = class extends qn {
  constructor(e = {}) {
    super(), this._container = void 0, this._value = void 0, this._direction = void 0, this._directionIcon = void 0, this._directionText = void 0, this._config = e;
  }
  onAdd() {
    return this._container = document.createElement("div"), this._container.classList.add(jn), this.setConfig(this._config), this._container;
  }
  onRemove() {
    this._container && this._container.parentNode && (this._container.parentNode.removeChild(this._container), this._container = void 0);
  }
  getConfig() {
    return { ...this._config };
  }
  setConfig(e) {
    if (!this._container) return;
    if (!e.unitFormat) return;
    if (this._container.children.length > 0 && this._config.directionType === e.directionType && this._config.directionFormat === e.directionFormat && this._config.unitFormat === e.unitFormat && this._config.followCursor === e.followCursor && this._config.followCursorOffset === e.followCursorOffset && this._config.followCursorPlacement === e.followCursorPlacement) return;
    this._config = e, this._container.innerHTML = "";
    const t = document.createElement("div");
    this._container.appendChild(t), this._value = document.createElement("span"), this._value.classList.add(Yn), t.appendChild(this._value), this._direction = document.createElement("span"), this._direction.classList.add(_n), t.appendChild(this._direction), this._directionIcon = document.createElement("span"), this._directionIcon.classList.add(Hn), this._direction.appendChild(this._directionIcon), this._directionText = document.createElement("span"), this._directionText.classList.add($n), this._direction.appendChild(this._directionText);
  }
  update(e) {
    if (!(this._container && this._value && this._directionIcon && this._directionText)) return;
    const { value: t, direction: n } = e ?? {};
    this._container.classList.toggle("follow-cursor", this._config.followCursor ?? false), this._container.setAttribute("data-follow-cursor-placement", this._config.followCursorPlacement ?? le.BOTTOM), this._container.classList.toggle("has-value", void 0 !== t), this._container.classList.toggle("has-direction", void 0 !== n), this._value.innerHTML = void 0 !== t ? S(t, this._config.unitFormat) : "", void 0 !== n ? (this._directionIcon.style.transform = `rotate(${(n + 180) % 360}deg)`, this._directionText.innerHTML = V(n, this._config.directionType ?? T.INWARD, this._config.directionFormat ?? M.VALUE)) : (this._directionIcon.style.transform = "", this._directionText.innerHTML = "");
  }
  updatePickingInfo(e) {
    if (!this._container || !this._value || !this._direction) return;
    if (!e) return void this.update(void 0);
    this.update(e.raster);
    const t = void 0 !== e.raster?.direction, n = this._container.firstChild;
    if (this._config.followCursor) {
      const a = n.getBoundingClientRect(), i = this._value.getBoundingClientRect(), o = this._config.followCursorOffset ?? 16, r = this._config.followCursorPlacement ?? le.BOTTOM;
      let A2 = e.x, s = e.y;
      if (r === le.BOTTOM) s += o;
      else if (r === le.TOP) s -= o;
      else if (r === le.RIGHT) A2 += o;
      else {
        if (r !== le.LEFT) throw new Error(`Invalid placement ${r}`);
        A2 -= o;
      }
      if (this._container.style.left = `${A2}px`, this._container.style.top = `${s}px`, r === le.BOTTOM || r === le.TOP) {
        const e2 = parseFloat(window.getComputedStyle(n).paddingLeft), a2 = parseFloat(window.getComputedStyle(this._direction).marginLeft), o2 = -(e2 + (t ? i.width + a2 : i.width / 2));
        n.style.left = `${o2}px`;
      }
      if (r === le.RIGHT || r === le.LEFT) {
        const e2 = -a.height / 2;
        n.style.top = `${e2}px`;
      }
      if (r === le.TOP) {
        const e2 = -a.height;
        n.style.top = `${e2}px`;
      }
      if (r === le.LEFT) {
        const e2 = -a.width;
        n.style.left = `${e2}px`;
      }
      document.addEventListener("mousedown", (() => this.update(void 0)), { once: true });
    } else this._container.style.left = "", this._container.style.top = "", n.style.left = "", n.style.top = "";
  }
};
Xn(`.weatherlayers-timeline-control{margin:10px;pointer-events:auto}.weatherlayers-timeline-control>div{background:hsla(0,0%,100%,.5);color:rgba(0,0,0,.75);display:inline-block;font-family:Helvetica Neue,Arial,Helvetica,sans-serif;font-size:12px;line-height:14px;width:100%}.weatherlayers-timeline-control footer,.weatherlayers-timeline-control header,.weatherlayers-timeline-control main{margin:5px 10px;text-align:center}.weatherlayers-timeline-control header{font-weight:700}.weatherlayers-timeline-control footer{display:flex;gap:10px}.weatherlayers-timeline-control__progress-input{margin:-2px 0 2px;vertical-align:middle;width:100%}.weatherlayers-timeline-control__end-datetime,.weatherlayers-timeline-control__start-datetime{flex:0 0}.weatherlayers-timeline-control__buttons{flex:1 0}.weatherlayers-timeline-control__start-datetime{text-align:left}.weatherlayers-timeline-control__end-datetime{text-align:right}.weatherlayers-timeline-control__button{background:no-repeat 50%/contain;display:inline-block;height:16px;vertical-align:middle;width:16px}.weatherlayers-timeline-control__button+.weatherlayers-timeline-control__button{margin-left:5px}.weatherlayers-timeline-control__play-button{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='1792' height='1792' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1576 927 248 1665q-23 13-39.5 3t-16.5-36V160q0-26 16.5-36t39.5 3l1328 738q23 13 23 31t-23 31z'/%3E%3C/svg%3E")}.weatherlayers-timeline-control__pause-button{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='1792' height='1792' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1664 192v1408q0 26-19 45t-45 19h-512q-26 0-45-19t-19-45V192q0-26 19-45t45-19h512q26 0 45 19t19 45zm-896 0v1408q0 26-19 45t-45 19H192q-26 0-45-19t-19-45V192q0-26 19-45t45-19h512q26 0 45 19t19 45z'/%3E%3C/svg%3E")}.weatherlayers-timeline-control__step-backward-button{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='1792' height='1792' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1363 141q19-19 32-13t13 32v1472q0 26-13 32t-32-13L653 941q-9-9-13-19v678q0 26-19 45t-45 19H448q-26 0-45-19t-19-45V192q0-26 19-45t45-19h128q26 0 45 19t19 45v678q4-10 13-19z'/%3E%3C/svg%3E")}.weatherlayers-timeline-control__step-forward-button{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg width='1792' height='1792' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M429 1651q-19 19-32 13t-13-32V160q0-26 13-32t32 13l710 710q9 9 13 19V192q0-26 19-45t45-19h128q26 0 45 19t19 45v1408q0 26-19 45t-45 19h-128q-26 0-45-19t-19-45V922q-4 10-13 19z'/%3E%3C/svg%3E")}.weatherlayers-timeline-control__loader{display:block;margin-top:2px}.weatherlayers-timeline-control__loader-icon{background:no-repeat 50%/contain;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' style='margin:auto;background:0 0;display:block;shape-rendering:auto' width='16' height='16' viewBox='0 0 100 100' preserveAspectRatio='xMidYMid'%3E%3Ccircle cx='50' cy='50' fill='none' stroke='rgba(0, 0, 0, 0.4)' stroke-width='10' r='25' stroke-dasharray='117.80972450961724 41.269908169872416'%3E%3CanimateTransform attributeName='transform' type='rotate' repeatCount='indefinite' dur='1s' values='0 50 50;360 50 50' keyTimes='0;1'/%3E%3C/circle%3E%3C/svg%3E");display:inline-block;height:16px;vertical-align:middle;width:16px}.weatherlayers-timeline-control__loader-text{color:rgba(0,0,0,.4);margin-left:2px;vertical-align:middle}.weatherlayers-timeline-control.loading *{pointer-events:none}.weatherlayers-timeline-control.running .weatherlayers-timeline-control__play-button,.weatherlayers-timeline-control:not(.running) .weatherlayers-timeline-control__pause-button{display:none}.weatherlayers-timeline-control:not(.loading) .weatherlayers-timeline-control__loader{visibility:hidden}`);
var ta = "weatherlayers-timeline-control";
var na = `${ta}__current-datetime`;
var aa = `${ta}__progress-input`;
var ia = `${ta}__start-datetime`;
var oa = `${ta}__buttons`;
var ra = `${ta}__end-datetime`;
var Aa = `${ta}__button`;
var sa = `${ta}__step-backward-button`;
var la = `${ta}__play-button`;
var ca = `${ta}__pause-button`;
var ga = `${ta}__step-forward-button`;
var ua = `${ta}__loader`;
var pa = `${ta}__loader-icon`;
var da = `${ta}__loader-text`;
var ha = "loading";
var ma = "running";
var Ca = class extends qn {
  constructor(e = {}) {
    super(), this._container = void 0, this._currentDatetime = void 0, this._progressInput = void 0, this._loaderText = void 0, this._loading = false, this._config = e, this._animation = new K({ onUpdate: () => this._animationUpdated(), fps: this._config.fps ?? 15 });
  }
  onAdd() {
    return this._container = document.createElement("div"), this._container.classList.add(ta), this.setConfig(this._config), this._container;
  }
  onRemove() {
    this._container && this._container.parentNode && (this._container.parentNode.removeChild(this._container), this._container = void 0, this._currentDatetime = void 0, this._progressInput = void 0);
  }
  get loading() {
    return this._loading;
  }
  get running() {
    return this._running;
  }
  get _running() {
    return this._animation.running;
  }
  async toggle(e = !this._running) {
    return e ? await this.start() : this.pause();
  }
  async start() {
    !this._container || this._loading || this._running || (await this._preload(this._config.datetimes), this._animation.start(), this._container.classList.add(ma), this._updateProgress());
  }
  pause() {
    this._container && !this._loading && this._running && (this._animation.stop(), this._container.classList.remove(ma), this._updateProgress());
  }
  stop() {
    this._container && this._progressInput && !this._loading && this._running && (this._animation.stop(), this._container.classList.remove(ma), this._progressInput.valueAsNumber = 0, this._updateProgress());
  }
  reset() {
    !this._progressInput || this._loading || this._running || (this._progressInput.valueAsNumber = 0, this._updateProgress());
  }
  async stepBackward() {
    !this._progressInput || this._loading || this._running || (this._progressInput.value !== this._progressInput.min ? this._progressInput.stepDown() : this._progressInput.value = this._progressInput.max, await this._preload(this._startEndDatetimes), this._updateProgress());
  }
  async stepForward() {
    !this._progressInput || this._loading || this._running || (this._progressInput.value !== this._progressInput.max ? this._progressInput.stepUp() : this._progressInput.value = this._progressInput.min, await this._preload(this._startEndDatetimes), this._updateProgress());
  }
  get _startEndDatetimes() {
    if (!this._progressInput) return [];
    const e = this._config.datetimes[Math.floor(this._progressInput.valueAsNumber)], t = this._config.datetimes[Math.ceil(this._progressInput.valueAsNumber)];
    return e === t ? [e] : [e, t];
  }
  _updateProgress() {
    if (!this._progressInput || !this._currentDatetime) return;
    const e = $(this._config.datetimes[Math.floor(this._progressInput.valueAsNumber)], this._config.datetimes[Math.ceil(this._progressInput.valueAsNumber)], this._progressInput.valueAsNumber % 1);
    this._config.datetime = e;
    const t = this._config.datetimeFormatFunction ?? oe;
    this._currentDatetime.innerHTML = t(e), this._config.onUpdate && this._config.onUpdate(e);
  }
  async _progressInputClicked() {
    this._loading || this._running || (await this._preload(this._startEndDatetimes), this._updateProgress());
  }
  _animationUpdated() {
    this._progressInput && !this._loading && this._running && (this._progressInput.value !== this._progressInput.max ? this._progressInput.stepUp() : this._progressInput.value = this._progressInput.min, this._updateProgress());
  }
  async _preload(e) {
    if (!this._container || !this._loaderText || !this._config.onPreload) return;
    this._loading = true, this._container.classList.add(ha);
    const t = this._config.onPreload(e);
    if (Array.isArray(t)) {
      let e2 = 0;
      const n = () => {
        this._loaderText.innerHTML = `Loading... ${e2}/${t.length}`;
      };
      n();
      for (let a of t) a.then((() => {
        e2++, n();
      }));
      await Promise.all(t), this._loaderText.innerHTML = "";
    } else this._loaderText.innerHTML = "Loading...", await t, this._loaderText.innerHTML = "";
    this._loading = false, this._container.classList.remove(ha);
  }
  getConfig() {
    return { ...this._config };
  }
  setConfig(e) {
    if (!this._container) return;
    if (!e.datetimes || e.datetimes.length < 2 || !e.datetime || e.datetime < e.datetimes[0] || e.datetime > e.datetimes[e.datetimes.length - 1]) return;
    if (this._container.children.length > 0 && this._config.width === e.width && this._config.datetimes.length === e.datetimes.length && this._config.datetimes.every(((t2, n2) => t2 === e.datetimes[n2])) && this._config.datetime === e.datetime && this._config.datetimeInterpolate === e.datetimeInterpolate && this._config.datetimeFormatFunction === e.datetimeFormatFunction && this._config.onPreload === e.onPreload && this._config.onUpdate === e.onUpdate) return;
    this._config = e;
    const t = this._config.width ?? 300, n = this._config.datetimes, a = this._config.datetime, i = this._config.datetimeInterpolate ?? false, o = this._config.datetimeFormatFunction ?? oe, r = cn(n, ((e2) => e2 <= a));
    if (r < 0) throw new Error("Invalid state");
    const A2 = r < n.length - 1 ? r + 1 : null, s = ee(n[r], "number" == typeof A2 ? n[r + 1] : null, a), l = i ? 0.25 : 1, c = r + Math.floor(s / l) * l;
    this._container.innerHTML = "", this._container.style.width = `${t}px`;
    const g = document.createElement("div");
    this._container.appendChild(g);
    const u = document.createElement("header");
    g.appendChild(u), this._currentDatetime = document.createElement("span"), this._currentDatetime.classList.add(na), this._currentDatetime.innerHTML = o(a), u.appendChild(this._currentDatetime);
    const p = document.createElement("main");
    g.appendChild(p);
    const d = `${aa}-ticks-${Gt()}`;
    this._progressInput = document.createElement("input"), this._progressInput.classList.add(aa), this._progressInput.type = "range", this._progressInput.min = "0", this._progressInput.max = "" + (n.length - 1), this._progressInput.step = `${l}`, this._progressInput.valueAsNumber = c, this._progressInput.setAttribute("list", d), this._progressInput.addEventListener("input", (() => this._progressInputClicked())), p.appendChild(this._progressInput);
    const h = document.createElement("datalist");
    h.id = d, p.appendChild(h);
    for (let e2 = 0; e2 < n.length; e2++) {
      const t2 = document.createElement("option");
      t2.innerHTML = `${e2}`, h.appendChild(t2);
    }
    const m = document.createElement("footer");
    g.appendChild(m);
    const C = document.createElement("span");
    C.classList.add(ia), C.innerHTML = o(n[0]), m.appendChild(C);
    const v = document.createElement("span");
    v.classList.add(oa), m.appendChild(v);
    const f = document.createElement("span");
    f.classList.add(ra), f.innerHTML = o(n[n.length - 1]), m.appendChild(f);
    const I = document.createElement("a");
    I.href = "javascript:void(0)", I.classList.add(Aa), I.classList.add(sa), I.addEventListener("click", (() => this.stepBackward())), v.appendChild(I);
    const E = document.createElement("a");
    E.href = "javascript:void(0)", E.classList.add(Aa), E.classList.add(la), E.addEventListener("click", (() => this.start())), v.appendChild(E);
    const B = document.createElement("a");
    B.href = "javascript:void(0)", B.classList.add(Aa), B.classList.add(ca), B.addEventListener("click", (() => this.pause())), v.appendChild(B);
    const Q = document.createElement("a");
    Q.href = "javascript:void(0)", Q.classList.add(Aa), Q.classList.add(ga), Q.addEventListener("click", (() => this.stepForward())), v.appendChild(Q);
    const y2 = document.createElement("span");
    y2.classList.add(ua), v.appendChild(y2);
    const b2 = document.createElement("span");
    b2.classList.add(pa), y2.appendChild(b2), this._loaderText = document.createElement("span"), this._loaderText.classList.add(da), y2.appendChild(this._loaderText);
  }
};
Xn(".weatherlayers-attribution-control{margin-top:2px;pointer-events:auto}.weatherlayers-attribution-control>div{background:hsla(0,0%,100%,.5);color:rgba(0,0,0,.75);display:inline-block;font-family:Helvetica Neue,Arial,Helvetica,sans-serif;font-size:12px;line-height:20px;padding:0 5px}.weatherlayers-attribution-control a{color:rgba(0,0,0,.75);text-decoration:none}.weatherlayers-attribution-control a:hover{text-decoration:underline}");
var va = class extends qn {
  constructor(e = {}) {
    super(), this._container = void 0, this._config = e;
  }
  onAdd() {
    return this._container = document.createElement("div"), this._container.classList.add("weatherlayers-attribution-control"), this.setConfig(this._config), this._container;
  }
  onRemove() {
    this._container && this._container.parentNode && (this._container.parentNode.removeChild(this._container), this._container = void 0);
  }
  getConfig() {
    return { ...this._config };
  }
  setConfig(e) {
    if (!this._container) return;
    if (!e.attribution) return;
    if (this._container.children.length > 0 && this._config.attribution === e.attribution) return;
    this._config = e;
    const t = this._config.attribution;
    this._container.innerHTML = `<div>${t}</div>`;
  }
};
Xn(`.weatherlayers-logo-control{margin:10px;pointer-events:auto}.weatherlayers-logo-control a{background:no-repeat 50%/contain;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' xml:space='preserve' style='fill-rule:evenodd;clip-rule:evenodd;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:2' viewBox='0 0 131 23'%3E%3Cg opacity='.9'%3E%3Cpath d='M27.391 17.706h2.534l1.736-6.475h.132l1.765 6.475h2.52l2.761-10.569H36.07l-1.384 7.009h-.132l-1.75-7.009H30.65l-1.692 7.009h-.131L27.42 7.137h-2.79l2.761 10.569Zm15.092.19c2.615 0 3.611-1.53 3.846-2.504l.022-.088-2.373.007-.015.029c-.117.213-.564.711-1.428.711-.996 0-1.597-.674-1.619-1.839h5.486v-.747c0-2.49-1.56-4.101-4.014-4.101-2.461 0-4.021 1.633-4.021 4.262v.008c0 2.644 1.56 4.262 4.116 4.262Zm-.036-6.687c.805 0 1.377.52 1.501 1.495h-3.003c.125-.96.703-1.495 1.502-1.495Zm7.028 6.622c1.04 0 1.912-.44 2.271-1.136h.139v1.011h2.549v-5.559c0-1.758-1.282-2.783-3.531-2.783-2.204 0-3.611.989-3.757 2.49l-.007.088h2.351l.014-.037c.154-.41.572-.637 1.253-.637.718 0 1.128.33 1.128.879v.637l-1.78.103c-2.102.132-3.259.988-3.259 2.468v.015c0 1.486 1.069 2.461 2.629 2.461Zm-.132-2.644v-.015c0-.484.403-.791 1.172-.842l1.37-.088v.534c0 .703-.637 1.245-1.458 1.245-.652 0-1.084-.322-1.084-.834Zm9.944 2.534c.49 0 .966-.044 1.237-.103v-1.853a5.19 5.19 0 0 1-.651.029c-.674 0-.982-.293-.982-.908v-3.428h1.633V9.554h-1.633V7.687h-2.6v1.867h-1.245v1.904h1.245v4.014c0 1.597.85 2.249 2.996 2.249Zm2.267-.015h2.593v-4.658c0-.938.498-1.575 1.34-1.575.879 0 1.282.557 1.282 1.546v4.687h2.593V12.44c0-1.956-.945-3.076-2.754-3.076-1.15 0-1.97.571-2.322 1.465h-.139V6.5h-2.593v11.206Zm12.719.19c2.615 0 3.611-1.53 3.846-2.504l.022-.088-2.373.007-.015.029c-.117.213-.564.711-1.428.711-.996 0-1.597-.674-1.619-1.839h5.486v-.747c0-2.49-1.56-4.101-4.014-4.101-2.461 0-4.021 1.633-4.021 4.262v.008c0 2.644 1.56 4.262 4.116 4.262Zm-.036-6.687c.805 0 1.377.52 1.501 1.495h-3.003c.125-.96.703-1.495 1.502-1.495Zm4.816 6.497h2.593v-4.314c0-1.128.71-1.78 1.926-1.78.366 0 .74.052 1.084.139V9.562a2.733 2.733 0 0 0-.879-.132c-1.04 0-1.757.52-1.992 1.421h-.139V9.554h-2.593v8.152Zm6.443 0h7.177v-2.161h-4.489V7.137h-2.688v10.569Zm10.36.125c1.04 0 1.912-.44 2.271-1.136h.139v1.011h2.549v-5.559c0-1.758-1.282-2.783-3.53-2.783-2.205 0-3.611.989-3.758 2.49l-.007.088h2.351l.015-.037c.154-.41.571-.637 1.252-.637.718 0 1.128.33 1.128.879v.637l-1.78.103c-2.102.132-3.259.988-3.259 2.468v.015c0 1.486 1.069 2.461 2.629 2.461Zm-.131-2.644v-.015c0-.484.402-.791 1.171-.842l1.37-.088v.534c0 .703-.637 1.245-1.457 1.245-.652 0-1.084-.322-1.084-.834Zm7.233 5.397c2.3 0 3.589-.82 4.336-3.142l2.571-7.888h-2.74l-1.45 5.911h-.154l-1.45-5.911h-2.863l2.783 8.152-.037.227c-.08.476-.527.747-1.304.747-.212 0-.424 0-.571-.007v1.904c.293.007.586.007.879.007Zm10.896-2.688c2.614 0 3.61-1.53 3.845-2.504l.022-.088-2.373.007-.015.029c-.117.213-.564.711-1.428.711-.996 0-1.597-.674-1.619-1.839h5.486v-.747c0-2.49-1.56-4.101-4.014-4.101-2.461 0-4.021 1.633-4.021 4.262v.008c0 2.644 1.56 4.262 4.117 4.262Zm-.037-6.687c.806 0 1.377.52 1.501 1.495h-3.003c.125-.96.704-1.495 1.502-1.495Zm4.816 6.497h2.593v-4.314c0-1.128.711-1.78 1.926-1.78.367 0 .74.052 1.084.139V9.562a2.733 2.733 0 0 0-.879-.132c-1.04 0-1.757.52-1.992 1.421h-.139V9.554h-2.593v8.152Zm9.468.19c2.212 0 3.735-1.083 3.735-2.775v-.008c0-1.223-.769-1.911-2.454-2.248l-1.406-.279c-.776-.161-1.025-.373-1.025-.739v-.015c0-.454.432-.725 1.076-.725.718 0 1.121.381 1.202.718l.014.051h2.373v-.037c-.044-1.303-1.23-2.475-3.589-2.475-2.19 0-3.581 1.018-3.581 2.644v.007c0 1.245.805 2.066 2.38 2.381l1.406.278c.74.154 1.018.373 1.018.754v.008c0 .439-.446.71-1.142.71-.754 0-1.165-.315-1.318-.732l-.015-.044h-2.52v.051c.162 1.421 1.429 2.475 3.846 2.475Z' style='fill:none;fill-rule:nonzero;stroke:%23000;stroke-opacity:.3;stroke-width:3px' transform='translate(-2.33)'/%3E%3Cpath d='M27.391 17.706h2.534l1.736-6.475h.132l1.765 6.475h2.52l2.761-10.569H36.07l-1.384 7.009h-.132l-1.75-7.009H30.65l-1.692 7.009h-.131L27.42 7.137h-2.79l2.761 10.569Zm15.092.19c2.615 0 3.611-1.53 3.846-2.504l.022-.088-2.373.007-.015.029c-.117.213-.564.711-1.428.711-.996 0-1.597-.674-1.619-1.839h5.486v-.747c0-2.49-1.56-4.101-4.014-4.101-2.461 0-4.021 1.633-4.021 4.262v.008c0 2.644 1.56 4.262 4.116 4.262Zm-.036-6.687c.805 0 1.377.52 1.501 1.495h-3.003c.125-.96.703-1.495 1.502-1.495Zm7.028 6.622c1.04 0 1.912-.44 2.271-1.136h.139v1.011h2.549v-5.559c0-1.758-1.282-2.783-3.531-2.783-2.204 0-3.611.989-3.757 2.49l-.007.088h2.351l.014-.037c.154-.41.572-.637 1.253-.637.718 0 1.128.33 1.128.879v.637l-1.78.103c-2.102.132-3.259.988-3.259 2.468v.015c0 1.486 1.069 2.461 2.629 2.461Zm-.132-2.644v-.015c0-.484.403-.791 1.172-.842l1.37-.088v.534c0 .703-.637 1.245-1.458 1.245-.652 0-1.084-.322-1.084-.834Zm9.944 2.534c.49 0 .966-.044 1.237-.103v-1.853a5.19 5.19 0 0 1-.651.029c-.674 0-.982-.293-.982-.908v-3.428h1.633V9.554h-1.633V7.687h-2.6v1.867h-1.245v1.904h1.245v4.014c0 1.597.85 2.249 2.996 2.249Zm2.267-.015h2.593v-4.658c0-.938.498-1.575 1.34-1.575.879 0 1.282.557 1.282 1.546v4.687h2.593V12.44c0-1.956-.945-3.076-2.754-3.076-1.15 0-1.97.571-2.322 1.465h-.139V6.5h-2.593v11.206Zm12.719.19c2.615 0 3.611-1.53 3.846-2.504l.022-.088-2.373.007-.015.029c-.117.213-.564.711-1.428.711-.996 0-1.597-.674-1.619-1.839h5.486v-.747c0-2.49-1.56-4.101-4.014-4.101-2.461 0-4.021 1.633-4.021 4.262v.008c0 2.644 1.56 4.262 4.116 4.262Zm-.036-6.687c.805 0 1.377.52 1.501 1.495h-3.003c.125-.96.703-1.495 1.502-1.495Zm4.816 6.497h2.593v-4.314c0-1.128.71-1.78 1.926-1.78.366 0 .74.052 1.084.139V9.562a2.733 2.733 0 0 0-.879-.132c-1.04 0-1.757.52-1.992 1.421h-.139V9.554h-2.593v8.152Zm6.443 0h7.177v-2.161h-4.489V7.137h-2.688v10.569Zm10.36.125c1.04 0 1.912-.44 2.271-1.136h.139v1.011h2.549v-5.559c0-1.758-1.282-2.783-3.53-2.783-2.205 0-3.611.989-3.758 2.49l-.007.088h2.351l.015-.037c.154-.41.571-.637 1.252-.637.718 0 1.128.33 1.128.879v.637l-1.78.103c-2.102.132-3.259.988-3.259 2.468v.015c0 1.486 1.069 2.461 2.629 2.461Zm-.131-2.644v-.015c0-.484.402-.791 1.171-.842l1.37-.088v.534c0 .703-.637 1.245-1.457 1.245-.652 0-1.084-.322-1.084-.834Zm7.233 5.397c2.3 0 3.589-.82 4.336-3.142l2.571-7.888h-2.74l-1.45 5.911h-.154l-1.45-5.911h-2.863l2.783 8.152-.037.227c-.08.476-.527.747-1.304.747-.212 0-.424 0-.571-.007v1.904c.293.007.586.007.879.007Zm10.896-2.688c2.614 0 3.61-1.53 3.845-2.504l.022-.088-2.373.007-.015.029c-.117.213-.564.711-1.428.711-.996 0-1.597-.674-1.619-1.839h5.486v-.747c0-2.49-1.56-4.101-4.014-4.101-2.461 0-4.021 1.633-4.021 4.262v.008c0 2.644 1.56 4.262 4.117 4.262Zm-.037-6.687c.806 0 1.377.52 1.501 1.495h-3.003c.125-.96.704-1.495 1.502-1.495Zm4.816 6.497h2.593v-4.314c0-1.128.711-1.78 1.926-1.78.367 0 .74.052 1.084.139V9.562a2.733 2.733 0 0 0-.879-.132c-1.04 0-1.757.52-1.992 1.421h-.139V9.554h-2.593v8.152Zm9.468.19c2.212 0 3.735-1.083 3.735-2.775v-.008c0-1.223-.769-1.911-2.454-2.248l-1.406-.279c-.776-.161-1.025-.373-1.025-.739v-.015c0-.454.432-.725 1.076-.725.718 0 1.121.381 1.202.718l.014.051h2.373v-.037c-.044-1.303-1.23-2.475-3.589-2.475-2.19 0-3.581 1.018-3.581 2.644v.007c0 1.245.805 2.066 2.38 2.381l1.406.278c.74.154 1.018.373 1.018.754v.008c0 .439-.446.71-1.142.71-.754 0-1.165-.315-1.318-.732l-.015-.044h-2.52v.051c.162 1.421 1.429 2.475 3.846 2.475Z' style='fill:%23fff;fill-rule:nonzero' transform='translate(-2.33)'/%3E%3Cpath d='m6.107 9.12-2.749 1.193a.68.68 0 0 0-.408.628c0 .275.16.522.407.629l2.75 1.193-2.749 1.192a.684.684 0 0 0-.408.63c0 .275.16.521.407.628l6.213 2.696a1.103 1.103 0 0 0 .877 0l6.212-2.695a.683.683 0 0 0 .408-.629.682.682 0 0 0-.407-.629l-2.75-1.193 2.749-1.193a.683.683 0 0 0 .409-.629.68.68 0 0 0-.408-.628l-2.75-1.194-1.144.497 3.054 1.326-5.736 2.488a.181.181 0 0 1-.151 0l-5.736-2.489 3.054-1.325-1.144-.496Zm9.713 5.465-5.736 2.489a.189.189 0 0 1-.151 0l-5.736-2.49 3.054-1.325 2.319 1.006a1.09 1.09 0 0 0 .877 0l2.319-1.006 3.054 1.326Zm-2.289-7.966c-.011.04-.039.066-.083.079l-1.207.378v1.206a.122.122 0 0 1-.054.103.128.128 0 0 1-.12.016L10.86 8.03l-.744.978a.13.13 0 0 1-.107.051.134.134 0 0 1-.108-.051l-.744-.978-1.207.371c-.038.015-.078.01-.12-.016a.121.121 0 0 1-.053-.103V7.076l-1.208-.378c-.044-.013-.071-.039-.082-.079-.014-.045-.008-.083.016-.114l.744-.978-.744-.977a.121.121 0 0 1-.016-.114c.011-.04.038-.066.082-.079l1.208-.378V2.773c0-.042.017-.077.053-.103.042-.026.082-.032.12-.016l1.207.371.744-.978A.131.131 0 0 1 10.009 2c.047 0 .083.016.107.047l.744.978 1.207-.371c.039-.016.079-.01.12.016a.122.122 0 0 1 .054.103v1.206l1.207.378c.044.013.072.039.083.079a.119.119 0 0 1-.017.114l-.744.977.744.978c.025.031.031.069.017.114M12.39 5.527c0-.307-.063-.601-.188-.88a2.287 2.287 0 0 0-1.269-1.21 2.422 2.422 0 0 0-.924-.18c-.323 0-.631.06-.924.18a2.284 2.284 0 0 0-1.269 1.21 2.115 2.115 0 0 0-.188.88c0 .308.062.602.188.881a2.284 2.284 0 0 0 1.269 1.21c.293.12.601.18.924.18.322 0 .63-.06.924-.18a2.287 2.287 0 0 0 1.269-1.21c.125-.279.188-.573.188-.881' style='fill:none;fill-rule:nonzero;stroke:%23000;stroke-opacity:.3;stroke-width:2.4px' transform='matrix(1.25 0 0 1.25 -2.188 -1)'/%3E%3Cpath d='m6.107 9.12-2.749 1.193a.68.68 0 0 0-.408.628c0 .275.16.522.407.629l2.75 1.193-2.749 1.192a.684.684 0 0 0-.408.63c0 .275.16.521.407.628l6.213 2.696a1.103 1.103 0 0 0 .877 0l6.212-2.695a.683.683 0 0 0 .408-.629.682.682 0 0 0-.407-.629l-2.75-1.193 2.749-1.193a.683.683 0 0 0 .409-.629.68.68 0 0 0-.408-.628l-2.75-1.194-1.144.497 3.054 1.326-5.736 2.488a.181.181 0 0 1-.151 0l-5.736-2.489 3.054-1.325-1.144-.496Zm9.713 5.465-5.736 2.489a.189.189 0 0 1-.151 0l-5.736-2.49 3.054-1.325 2.319 1.006a1.09 1.09 0 0 0 .877 0l2.319-1.006 3.054 1.326Zm-2.289-7.966c-.011.04-.039.066-.083.079l-1.207.378v1.206a.122.122 0 0 1-.054.103.128.128 0 0 1-.12.016L10.86 8.03l-.744.978a.13.13 0 0 1-.107.051.134.134 0 0 1-.108-.051l-.744-.978-1.207.371c-.038.015-.078.01-.12-.016a.121.121 0 0 1-.053-.103V7.076l-1.208-.378c-.044-.013-.071-.039-.082-.079-.014-.045-.008-.083.016-.114l.744-.978-.744-.977a.121.121 0 0 1-.016-.114c.011-.04.038-.066.082-.079l1.208-.378V2.773c0-.042.017-.077.053-.103.042-.026.082-.032.12-.016l1.207.371.744-.978A.131.131 0 0 1 10.009 2c.047 0 .083.016.107.047l.744.978 1.207-.371c.039-.016.079-.01.12.016a.122.122 0 0 1 .054.103v1.206l1.207.378c.044.013.072.039.083.079a.119.119 0 0 1-.017.114l-.744.977.744.978c.025.031.031.069.017.114M12.39 5.527c0-.307-.063-.601-.188-.88a2.287 2.287 0 0 0-1.269-1.21 2.422 2.422 0 0 0-.924-.18c-.323 0-.631.06-.924.18a2.284 2.284 0 0 0-1.269 1.21 2.115 2.115 0 0 0-.188.88c0 .308.062.602.188.881a2.284 2.284 0 0 0 1.269 1.21c.293.12.601.18.924.18.322 0 .63-.06.924-.18a2.287 2.287 0 0 0 1.269-1.21c.125-.279.188-.573.188-.881' style='fill:%23fff;fill-rule:nonzero' transform='matrix(1.25 0 0 1.25 -2.188 -1)'/%3E%3C/g%3E%3C/svg%3E");display:inline-block;height:23px;margin:-1.5px;vertical-align:middle;width:131px}`);
var fa = class extends qn {
  constructor(e = {}) {
    super(), this._container = void 0, this._config = e;
  }
  onAdd() {
    return this._container = document.createElement("div"), this._container.classList.add("weatherlayers-logo-control"), this.setConfig(this._config), this._container;
  }
  onRemove() {
    this._container && this._container.parentNode && (this._container.parentNode.removeChild(this._container), this._container = void 0);
  }
  getConfig() {
    return { ...this._config };
  }
  setConfig(e) {
    if (!this._container) return;
    this._config = e, this._container.innerHTML = "";
    const t = document.createElement("a");
    t.href = "https://weatherlayers.com", t.target = "_blank", t.ariaLabel = "WeatherLayers", this._container.appendChild(t);
  }
};
export {
  K as Animation,
  va as AttributionControl,
  Xt as ContourLayer,
  b as DATETIME,
  q as DEFAULT_ICON_COLOR,
  W as DEFAULT_ICON_SIZE,
  N as DEFAULT_LINE_COLOR,
  U as DEFAULT_LINE_WIDTH,
  k as DEFAULT_TEXT_COLOR,
  L as DEFAULT_TEXT_FONT_FAMILY,
  R as DEFAULT_TEXT_FORMAT_FUNCTION,
  J as DEFAULT_TEXT_OUTLINE_COLOR,
  Z as DEFAULT_TEXT_OUTLINE_WIDTH,
  F as DEFAULT_TEXT_SIZE,
  M as DirectionFormat,
  T as DirectionType,
  dn as FrontLayer,
  sn as FrontType,
  Qn as GridLayer,
  vn as GridStyle,
  An as HighLowLayer,
  re as ImageInterpolation,
  Ae as ImageType,
  zn as LegendControl,
  fa as LogoControl,
  Wn as ParticleLayer,
  le as Placement,
  Nt as RasterLayer,
  Ca as TimelineControl,
  ea as TooltipControl,
  se as UnitSystem,
  y as VERSION,
  colorRampCanvas,
  X as ensureDefaultProps,
  oe as formatDatetime,
  V as formatDirection,
  O as formatUnit,
  D as formatValue,
  S as formatValueWithUnit,
  ne as getClosestEndDatetime,
  te as getClosestStartDatetime,
  ee as getDatetimeWeight,
  Le as getRasterMagnitudeData,
  Ne as getRasterPoints,
  $ as interpolateDatetime,
  H as loadJson,
  _ as loadTextureData,
  ae as offsetDatetime,
  ie as offsetDatetimeRange,
  parsePalette,
  x as setLibrary
};
//# sourceMappingURL=weatherlayers-gl.js.map
