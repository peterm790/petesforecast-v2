{
  "version": 3,
  "sources": ["../../npyjs/src/index.ts"],
  "sourcesContent": ["export type DType =\n    | \"i1\" | \"u1\" | \"i2\" | \"u2\" | \"i4\" | \"u4\" | \"i8\" | \"u8\"\n    | \"f2\" | \"f4\" | \"f8\" | \"b1\" | `U${number}`; // e.g., U10 for strings of length 10\n\nexport type TypedArray =\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | BigInt64Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | Uint16Array\n    | Uint32Array\n    | BigUint64Array\n    | Float32Array\n    | Float64Array;\n\nexport interface NpyArray<T extends ArrayBufferView = ArrayBufferView> {\n    data: T;\n    shape: number[];\n    dtype: DType;\n    fortranOrder: boolean;\n}\n\nexport interface Options {\n    /** Convert float16 to float32. Default true. */\n    convertFloat16?: boolean;\n}\n\nclass StringFromCodePoint extends String {\n    constructor(buf: ArrayBufferLike, byteOffset?: number, length?: number) {\n        const uint32 = new Uint32Array(buf, byteOffset, length);\n        const number_arr = Array.from(uint32);\n        const str = String.fromCodePoint(...number_arr);\n        super(str);\n    }\n}\n\nconst textDecoder = new TextDecoder(\"latin1\");\n\nfunction readHeader(buf: ArrayBufferLike) {\n    const view = new DataView(buf);\n    const magic = String.fromCharCode(\n        view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3),\n        view.getUint8(4), view.getUint8(5)\n    );\n    if (magic !== \"\\x93NUMPY\") throw new Error(\"Not an .npy file\");\n\n    const major = view.getUint8(6);\n    const minor = view.getUint8(7);\n\n    let headerLen: number;\n    if (major <= 1) {\n        headerLen = view.getUint16(8, true);\n        return { headerOffset: 10, headerLen, version: [major, minor] as const };\n    } else {\n        headerLen = Number(view.getUint32(8, true));\n        return { headerOffset: 12, headerLen, version: [major, minor] as const };\n    }\n}\n\nfunction parseDict(dictStr: string) {\n    // very small parser for the NumPy header dict (single quotes, Python-likes)\n    // matches keys: descr, fortran_order, shape\n    const dtype = /'descr'\\s*:\\s*'([^']+)'/.exec(dictStr)?.[1];\n    const fortran = /'fortran_order'\\s*:\\s*(True|False)/.exec(dictStr)?.[1] === \"True\";\n    const shapeMatch = /'shape'\\s*:\\s*\\(([^)]*)\\)/.exec(dictStr)?.[1] ?? \"\";\n    const shape = shapeMatch.split(\",\").map(s => s.trim()).filter(Boolean).map(n => Number(n));\n    if (shape.length === 1 && dictStr.includes(\"(n,)\")) {/* ok */ }\n    return { dtype, fortranOrder: fortran, shape };\n}\n\nfunction dtypeToArray(dtype: string, buf: ArrayBufferLike, offset: number, opts: Options) {\n    const little = dtype.startsWith(\"<\") || dtype.startsWith(\"|\"); // | = not applicable\n    const code = dtype.substring(dtype.length -2); // e.g., 'f8', 'i8'\n    //parse unicode dtype. The format is a 'U' character followed by a number that is the number of unicode characters in the string\n    if (code[0] === \"U\") {\n        const size = parseInt(code.substring(1))\n        const _string = String(new StringFromCodePoint(buf, offset));\n        const strings : string[] = [];\n        //split the string into an array of strings with length dtype.size\n        for (let i = 0; i < _string.length; i += size) {\n            strings.push(_string.substring(i, i + size).replace(/\\0/g, ''));\n        }\n        return strings;\n    }\n    switch (code) {\n        case \"b1\":\n            {\n                // Numpy saves bools in the header as |b1\n                if (little) {\n                    const u8 = new Uint8Array(buf, offset);\n                    const bools = new Array(u8.length);\n                    for (let i = 0; i < u8.length; i++) bools[i] = u8[i] !== 0;\n                    return bools;\n                } else {\n                    return new Uint8Array(buf, offset);\n                }\n            }\n        case \"i1\": return new Int8Array(buf, offset);\n        case \"u1\": return new Uint8Array(buf, offset);\n        case \"i2\": return new Int16Array(buf, offset);\n        case \"u2\": return new Uint16Array(buf, offset);\n        case \"i4\": return new Int32Array(buf, offset);\n        case \"u4\": return new Uint32Array(buf, offset);\n        case \"i8\": return new BigInt64Array(buf, offset);\n        case \"u8\": return new BigUint64Array(buf, offset);\n        case \"f4\": return new Float32Array(buf, offset);\n        case \"f8\": return new Float64Array(buf, offset);\n        case \"f2\": {\n            if (opts.convertFloat16 !== false) {\n                const u16 = new Uint16Array(buf, offset);\n                const f32 = new Float32Array(u16.length);\n                for (let i = 0; i < u16.length; i++) f32[i] = f16toF32(u16[i]);\n                return f32;\n            }\n            return new Uint16Array(buf, offset);\n        }\n        default: throw new Error(`Unsupported dtype: ${dtype}`);\n    }\n}\n\n// Kahan-friendly f16â†’f32 (IEEE 754)\nfunction f16toF32(u16: number): number {\n    const s = (u16 & 0x8000) >> 15;\n    const e = (u16 & 0x7C00) >> 10;\n    const f = u16 & 0x03FF;\n    if (e === 0) return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n    if (e === 0x1F) return f ? NaN : (s ? -Infinity : Infinity);\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n\nexport async function load(source: string | ArrayBuffer | ArrayBufferView | Blob, opts: Options = {}): Promise<NpyArray> {\n    let buf: ArrayBufferLike;\n    if (typeof source === \"string\") {\n        const res = await fetch(source);\n        buf = await res.arrayBuffer();\n    } else if (source instanceof ArrayBuffer) {\n        buf = source;\n    } else if (source instanceof Blob) {\n        buf = await source.arrayBuffer();\n    } else {\n        buf = source.buffer;\n    }\n\n    const { headerOffset, headerLen } = readHeader(buf);\n    const headerBytes = new Uint8Array(buf, headerOffset, headerLen);\n    const header = textDecoder.decode(headerBytes).trim();\n\n    const { dtype, fortranOrder, shape } = parseDict(header);\n    if (!dtype || !shape) throw new Error(\"Malformed .npy header\");\n\n    // Data starts at headerOffset + headerLen, already padded to 16-byte boundary by format spec\n    const dataOffset = headerOffset + headerLen;\n    const data = dtypeToArray(dtype, buf, dataOffset, opts);\n\n    return { data, shape, dtype: dtype.slice(1) as DType, fortranOrder } as NpyArray;\n}\n\n\n// Back-compat:\n\n// keep existing named exports above (load, types, etc.)\nexport function float16ToFloat32(u16: number): number {\n    return f16toF32(u16);\n}\n\nfunction arrayToDtype(array: unknown): DType {\n    if (array instanceof Uint8Array) {\n        return \"u1\";\n    }\n    if (array instanceof Uint8ClampedArray) {\n        return \"u1\";\n    }\n    if (array instanceof Int8Array) {\n        return \"i1\";\n    }\n    if (array instanceof Uint16Array) {\n        return \"u2\";\n    }\n    if (array instanceof Int16Array) {\n        return \"i2\";\n    }\n    if (array instanceof Uint32Array) {\n        return \"u4\";\n    }\n    if (array instanceof Int32Array) {\n        return \"i4\";\n    }\n    if (array instanceof Float32Array) {\n        return \"f4\";\n    }\n    if (array instanceof BigUint64Array) {\n        return \"u8\";\n    }\n    if (array instanceof BigInt64Array) {\n        return \"i8\";\n    }\n    if (array instanceof Float64Array) {\n        return \"f8\";\n    }\n    const kind = typeof array === \"object\" ? array?.constructor?.name : typeof array;\n    throw new TypeError(`Unsupported dtype for ${kind}`);\n}\n\nexport function arrayToTypedArray(dtype: DType, array: ArrayLike<number | string>): TypedArray { \n    if (!Array.isArray(array)) throw new TypeError(\"Expected an array\");\n\n    if (dtype.startsWith(\"U\")) {\n        // Unicode string array\n        const size = parseInt(dtype.substring(1));\n        const buf = new ArrayBuffer(array.length * size * 4);\n        const uint32 = new Uint32Array(buf);\n        for (let i = 0; i < array.length; i++) {\n            const str = array[i] as string;\n            for (let j = 0; j < size; j++) {\n                const code = j < str.length ? str.codePointAt(j) ?? 0 : 0;\n                uint32[i * size + j] = code!;\n            }\n        }\n        return new Uint8Array(buf);\n    }\n\n    switch (dtype) {\n        case \"b1\": return new Uint8Array(array);\n        case \"i1\": return new Int8Array(array);\n        case \"u1\": return new Uint8Array(array);\n        case \"i2\": return new Int16Array(array);\n        case \"u2\": return new Uint16Array(array);\n        case \"i4\": return new Int32Array(array);\n        case \"u4\": return new Uint32Array(array);\n        case \"i8\": return new BigInt64Array(array);\n        case \"u8\": return new BigUint64Array(array);\n        case \"f4\": return new Float32Array(array);\n        case \"f8\": return new Float64Array(array);\n        default: throw new Error(`Unsupported dtype: ${dtype}`);\n    }\n}\n\nfunction inferUnicodeDtypeFromStringArray(array: string[]): DType {\n    let longestStringLength = array[0].length;\n    for (let i = 1; i < array.length; i++) {\n        const element = array[i];\n        if (typeof element === \"string\" && element.length > longestStringLength) {\n            longestStringLength = element.length;\n        }\n    }\n    return `U${Math.max(1, longestStringLength)}` as DType; // e.g., U10 for strings of length 10\n}\n\nfunction inferDtypeFromNumberArray(array: number[]): DType {\n    let isInteger = true;\n    let isNonNegative = true;\n    let maxAbsValue = 0;\n\n    for (const num of array) {\n        if (!Number.isInteger(num)) {\n            isInteger = false;\n        }\n        if (num < 0) {\n            isNonNegative = false;\n        }\n        const absNum = Math.abs(num);\n        if (absNum > maxAbsValue) {\n            maxAbsValue = absNum;\n        }\n    }\n\n    if (!isInteger) {\n        if (maxAbsValue <= 3.40282347e+38) return \"f4\"; // max representable float32\n        return \"f8\"; // default to float64\n    }\n\n    // Integer array, determine smallest fitting dtype\n    if (isNonNegative) {\n        // Unsigned integers\n        if (maxAbsValue <= 0xFF) return \"u1\";\n        if (maxAbsValue <= 0xFFFF) return \"u2\";\n        if (maxAbsValue <= 0xFFFFFFFF) return \"u4\";\n        return \"u8\";\n    } else {\n        // Signed integers\n        if (maxAbsValue <= 0x7F) return \"i1\";\n        if (maxAbsValue <= 0x7FFF) return \"i2\";\n        if (maxAbsValue <= 0x7FFFFFFF) return \"i4\";\n        return \"i8\";\n    }\n}\n\nexport function inferDtypeFromArray(array: Array<number | number[] | string | string[]>): DType {\n    if (array.length === 0) return \"f8\"; // default to float64 for empty arrays\n    const first = array[0];\n\n    if (typeof first === \"number\") {\n        return inferDtypeFromNumberArray(array as number[]);\n    }\n\n    if (typeof first === \"string\") {\n        return inferUnicodeDtypeFromStringArray(array as string[]);\n    }\n\n    if (Array.isArray(first)) {\n        // Nested array, infer from first sub-array\n        return inferDtypeFromArray(first);\n    }\n\n    if (typeof first === \"boolean\") {\n        return \"b1\";\n    }\n\n    throw new TypeError(\"Array elements must be numbers, strings or booleans\");\n}\n\n/**\n * True if the system is little endian.\n */\nfunction isLittleEndian(): boolean {\n    // The result could be cached\n    return ((new Uint32Array((new Uint8Array([1, 0, 0, 0])).buffer))[0] === 1);\n}\n\nfunction createPyDescription(dtype : DType, shape: number[]) : string {\n\n    const isByte = dtype == 'u1' || dtype == 'i1';\n    const endianness = isByte ? '|' : (isLittleEndian() ? '<' : '>');\n    const descr = `${endianness}${dtype}`;\n    let pyShape = shape.map((v) => { return `${v}`; }).join(\",\");\n    if (shape.length === 1) pyShape += \",\";\n\n    return `{'descr':'${descr}','fortran_order':False,'shape':(${pyShape})}`;\n}\n\nexport function dump(array: TypedArray | Array<number | string>, shape: number[] | undefined) : ArrayBuffer{\n    const dtype = array instanceof Array ? inferDtypeFromArray(array) : arrayToDtype(array);\n    array = array instanceof Array ? arrayToTypedArray(dtype, array) : array;\n    \n    let pyDesc = createPyDescription(dtype, shape ?? [array.length]);\n    let headerSize = 10 + pyDesc.length;\n    const pad = 8 - ((headerSize + 1) % 8);\n    pyDesc = pyDesc + \" \".repeat(pad) + \"\\x0A\";\n    headerSize += pad + 1;\n    const buffer = new ArrayBuffer(headerSize + array.byteLength);\n    const view = new DataView(buffer);\n    view.setUint32(0, 2471384397, false);\n    view.setUint32(4, 1348010240, false);\n    view.setUint16(8, pyDesc.length, true);\n    const encoder = new TextEncoder();\n    const header = new Uint8Array(buffer, 10, pyDesc.length);\n    encoder.encodeInto(pyDesc, header);\n    const data = new Uint8Array(buffer, 10 + pyDesc.length);\n    data.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\n    return buffer;\n}\n\n// Back-compat class API (matches old tests)\nexport default class N {\n    private opts: Options;\n    constructor(opts: Options = {}) {\n        this.opts = opts;\n    }\n    async load(source: string | ArrayBuffer | ArrayBufferView) {\n        return load(source, this.opts);\n    }\n    \n    static float16ToFloat32(u16: number) {\n        return f16toF32(u16);\n    }\n\n    dump(array: TypedArray | Array<number | string>, shape: number[]) {\n        return dump(array, shape);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
