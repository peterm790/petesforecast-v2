// node_modules/cpt2js/dist/cpt2js.js
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var limit;
var hasRequiredLimit;
function requireLimit() {
  if (hasRequiredLimit) return limit;
  hasRequiredLimit = 1;
  limit = (x, min = 0, max = 1) => {
    return x < min ? min : x > max ? max : x;
  };
  return limit;
}
var clip_rgb;
var hasRequiredClip_rgb;
function requireClip_rgb() {
  if (hasRequiredClip_rgb) return clip_rgb;
  hasRequiredClip_rgb = 1;
  const limit2 = requireLimit();
  clip_rgb = (rgb2) => {
    rgb2._clipped = false;
    rgb2._unclipped = rgb2.slice(0);
    for (let i = 0; i <= 3; i++) {
      if (i < 3) {
        if (rgb2[i] < 0 || rgb2[i] > 255) rgb2._clipped = true;
        rgb2[i] = limit2(rgb2[i], 0, 255);
      } else if (i === 3) {
        rgb2[i] = limit2(rgb2[i], 0, 1);
      }
    }
    return rgb2;
  };
  return clip_rgb;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  const classToType = {};
  for (let name of ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]) {
    classToType[`[object ${name}]`] = name.toLowerCase();
  }
  type = function(obj) {
    return classToType[Object.prototype.toString.call(obj)] || "object";
  };
  return type;
}
var unpack;
var hasRequiredUnpack;
function requireUnpack() {
  if (hasRequiredUnpack) return unpack;
  hasRequiredUnpack = 1;
  const type2 = requireType();
  unpack = (args, keyOrder = null) => {
    if (args.length >= 3) return Array.prototype.slice.call(args);
    if (type2(args[0]) == "object" && keyOrder) {
      return keyOrder.split("").filter((k) => args[0][k] !== void 0).map((k) => args[0][k]);
    }
    return args[0];
  };
  return unpack;
}
var last;
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast) return last;
  hasRequiredLast = 1;
  const type2 = requireType();
  last = (args) => {
    if (args.length < 2) return null;
    const l = args.length - 1;
    if (type2(args[l]) == "string") return args[l].toLowerCase();
    return null;
  };
  return last;
}
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  const PI = Math.PI;
  utils = {
    clip_rgb: requireClip_rgb(),
    limit: requireLimit(),
    type: requireType(),
    unpack: requireUnpack(),
    last: requireLast(),
    PI,
    TWOPI: PI * 2,
    PITHIRD: PI / 3,
    DEG2RAD: PI / 180,
    RAD2DEG: 180 / PI
  };
  return utils;
}
var input;
var hasRequiredInput;
function requireInput() {
  if (hasRequiredInput) return input;
  hasRequiredInput = 1;
  input = {
    format: {},
    autodetect: []
  };
  return input;
}
var Color_1;
var hasRequiredColor;
function requireColor() {
  if (hasRequiredColor) return Color_1;
  hasRequiredColor = 1;
  const { last: last2, clip_rgb: clip_rgb2, type: type2 } = requireUtils();
  const _input = requireInput();
  class Color {
    constructor(...args) {
      const me = this;
      if (type2(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
        return args[0];
      }
      let mode = last2(args);
      let autodetect = false;
      if (!mode) {
        autodetect = true;
        if (!_input.sorted) {
          _input.autodetect = _input.autodetect.sort((a, b) => b.p - a.p);
          _input.sorted = true;
        }
        for (let chk of _input.autodetect) {
          mode = chk.test(...args);
          if (mode) break;
        }
      }
      if (_input.format[mode]) {
        const rgb2 = _input.format[mode].apply(null, autodetect ? args : args.slice(0, -1));
        me._rgb = clip_rgb2(rgb2);
      } else {
        throw new Error("unknown format: " + args);
      }
      if (me._rgb.length === 3) me._rgb.push(1);
    }
    toString() {
      if (type2(this.hex) == "function") return this.hex();
      return `[${this._rgb.join(",")}]`;
    }
  }
  Color_1 = Color;
  return Color_1;
}
var chroma_1;
var hasRequiredChroma;
function requireChroma() {
  if (hasRequiredChroma) return chroma_1;
  hasRequiredChroma = 1;
  const chroma2 = (...args) => {
    return new chroma2.Color(...args);
  };
  chroma2.Color = requireColor();
  chroma2.version = "@@version";
  chroma_1 = chroma2;
  return chroma_1;
}
var chromaExports = requireChroma();
var chroma = getDefaultExportFromCjs(chromaExports);
var css = {};
var hsl2css_1;
var hasRequiredHsl2css;
function requireHsl2css() {
  if (hasRequiredHsl2css) return hsl2css_1;
  hasRequiredHsl2css = 1;
  const { unpack: unpack2, last: last2 } = requireUtils();
  const rnd = (a) => Math.round(a * 100) / 100;
  const hsl2css = (...args) => {
    const hsla = unpack2(args, "hsla");
    let mode = last2(args) || "lsa";
    hsla[0] = rnd(hsla[0] || 0);
    hsla[1] = rnd(hsla[1] * 100) + "%";
    hsla[2] = rnd(hsla[2] * 100) + "%";
    if (mode === "hsla" || hsla.length > 3 && hsla[3] < 1) {
      hsla[3] = hsla.length > 3 ? hsla[3] : 1;
      mode = "hsla";
    } else {
      hsla.length = 3;
    }
    return `${mode}(${hsla.join(",")})`;
  };
  hsl2css_1 = hsl2css;
  return hsl2css_1;
}
var rgb2hsl_1;
var hasRequiredRgb2hsl;
function requireRgb2hsl() {
  if (hasRequiredRgb2hsl) return rgb2hsl_1;
  hasRequiredRgb2hsl = 1;
  const { unpack: unpack2 } = requireUtils();
  const rgb2hsl = (...args) => {
    args = unpack2(args, "rgba");
    let [r, g, b] = args;
    r /= 255;
    g /= 255;
    b /= 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const l = (max + min) / 2;
    let s, h;
    if (max === min) {
      s = 0;
      h = Number.NaN;
    } else {
      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
    }
    if (r == max) h = (g - b) / (max - min);
    else if (g == max) h = 2 + (b - r) / (max - min);
    else if (b == max) h = 4 + (r - g) / (max - min);
    h *= 60;
    if (h < 0) h += 360;
    if (args.length > 3 && args[3] !== void 0) return [h, s, l, args[3]];
    return [h, s, l];
  };
  rgb2hsl_1 = rgb2hsl;
  return rgb2hsl_1;
}
var rgb2css_1;
var hasRequiredRgb2css;
function requireRgb2css() {
  if (hasRequiredRgb2css) return rgb2css_1;
  hasRequiredRgb2css = 1;
  const { unpack: unpack2, last: last2 } = requireUtils();
  const hsl2css = requireHsl2css();
  const rgb2hsl = requireRgb2hsl();
  const { round } = Math;
  const rgb2css = (...args) => {
    const rgba = unpack2(args, "rgba");
    let mode = last2(args) || "rgb";
    if (mode.substr(0, 3) == "hsl") {
      return hsl2css(rgb2hsl(rgba), mode);
    }
    rgba[0] = round(rgba[0]);
    rgba[1] = round(rgba[1]);
    rgba[2] = round(rgba[2]);
    if (mode === "rgba" || rgba.length > 3 && rgba[3] < 1) {
      rgba[3] = rgba.length > 3 ? rgba[3] : 1;
      mode = "rgba";
    }
    return `${mode}(${rgba.slice(0, mode === "rgb" ? 3 : 4).join(",")})`;
  };
  rgb2css_1 = rgb2css;
  return rgb2css_1;
}
var hsl2rgb_1;
var hasRequiredHsl2rgb;
function requireHsl2rgb() {
  if (hasRequiredHsl2rgb) return hsl2rgb_1;
  hasRequiredHsl2rgb = 1;
  const { unpack: unpack2 } = requireUtils();
  const { round } = Math;
  const hsl2rgb = (...args) => {
    args = unpack2(args, "hsl");
    const [h, s, l] = args;
    let r, g, b;
    if (s === 0) {
      r = g = b = l * 255;
    } else {
      const t3 = [0, 0, 0];
      const c = [0, 0, 0];
      const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const t1 = 2 * l - t2;
      const h_ = h / 360;
      t3[0] = h_ + 1 / 3;
      t3[1] = h_;
      t3[2] = h_ - 1 / 3;
      for (let i = 0; i < 3; i++) {
        if (t3[i] < 0) t3[i] += 1;
        if (t3[i] > 1) t3[i] -= 1;
        if (6 * t3[i] < 1)
          c[i] = t1 + (t2 - t1) * 6 * t3[i];
        else if (2 * t3[i] < 1)
          c[i] = t2;
        else if (3 * t3[i] < 2)
          c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;
        else
          c[i] = t1;
      }
      [r, g, b] = [round(c[0] * 255), round(c[1] * 255), round(c[2] * 255)];
    }
    if (args.length > 3) {
      return [r, g, b, args[3]];
    }
    return [r, g, b, 1];
  };
  hsl2rgb_1 = hsl2rgb;
  return hsl2rgb_1;
}
var css2rgb_1;
var hasRequiredCss2rgb;
function requireCss2rgb() {
  if (hasRequiredCss2rgb) return css2rgb_1;
  hasRequiredCss2rgb = 1;
  const hsl2rgb = requireHsl2rgb();
  const input2 = requireInput();
  const RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
  const RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
  const RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
  const RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
  const RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
  const RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
  const { round } = Math;
  const css2rgb = (css2) => {
    css2 = css2.toLowerCase().trim();
    let m;
    if (input2.format.named) {
      try {
        return input2.format.named(css2);
      } catch (e) {
      }
    }
    if (m = css2.match(RE_RGB)) {
      const rgb2 = m.slice(1, 4);
      for (let i = 0; i < 3; i++) {
        rgb2[i] = +rgb2[i];
      }
      rgb2[3] = 1;
      return rgb2;
    }
    if (m = css2.match(RE_RGBA)) {
      const rgb2 = m.slice(1, 5);
      for (let i = 0; i < 4; i++) {
        rgb2[i] = +rgb2[i];
      }
      return rgb2;
    }
    if (m = css2.match(RE_RGB_PCT)) {
      const rgb2 = m.slice(1, 4);
      for (let i = 0; i < 3; i++) {
        rgb2[i] = round(rgb2[i] * 2.55);
      }
      rgb2[3] = 1;
      return rgb2;
    }
    if (m = css2.match(RE_RGBA_PCT)) {
      const rgb2 = m.slice(1, 5);
      for (let i = 0; i < 3; i++) {
        rgb2[i] = round(rgb2[i] * 2.55);
      }
      rgb2[3] = +rgb2[3];
      return rgb2;
    }
    if (m = css2.match(RE_HSL)) {
      const hsl2 = m.slice(1, 4);
      hsl2[1] *= 0.01;
      hsl2[2] *= 0.01;
      const rgb2 = hsl2rgb(hsl2);
      rgb2[3] = 1;
      return rgb2;
    }
    if (m = css2.match(RE_HSLA)) {
      const hsl2 = m.slice(1, 4);
      hsl2[1] *= 0.01;
      hsl2[2] *= 0.01;
      const rgb2 = hsl2rgb(hsl2);
      rgb2[3] = +m[4];
      return rgb2;
    }
  };
  css2rgb.test = (s) => {
    return RE_RGB.test(s) || RE_RGBA.test(s) || RE_RGB_PCT.test(s) || RE_RGBA_PCT.test(s) || RE_HSL.test(s) || RE_HSLA.test(s);
  };
  css2rgb_1 = css2rgb;
  return css2rgb_1;
}
var hasRequiredCss;
function requireCss() {
  if (hasRequiredCss) return css;
  hasRequiredCss = 1;
  const chroma2 = requireChroma();
  const Color = requireColor();
  const input2 = requireInput();
  const { type: type2 } = requireUtils();
  const rgb2css = requireRgb2css();
  const css2rgb = requireCss2rgb();
  Color.prototype.css = function(mode) {
    return rgb2css(this._rgb, mode);
  };
  chroma2.css = (...args) => new Color(...args, "css");
  input2.format.css = css2rgb;
  input2.autodetect.push({
    p: 5,
    test: (h, ...rest) => {
      if (!rest.length && type2(h) === "string" && css2rgb.test(h)) {
        return "css";
      }
    }
  });
  return css;
}
requireCss();
var hex = {};
var rgb2hex_1;
var hasRequiredRgb2hex;
function requireRgb2hex() {
  if (hasRequiredRgb2hex) return rgb2hex_1;
  hasRequiredRgb2hex = 1;
  const { unpack: unpack2, last: last2 } = requireUtils();
  const { round } = Math;
  const rgb2hex = (...args) => {
    let [r, g, b, a] = unpack2(args, "rgba");
    let mode = last2(args) || "auto";
    if (a === void 0) a = 1;
    if (mode === "auto") {
      mode = a < 1 ? "rgba" : "rgb";
    }
    r = round(r);
    g = round(g);
    b = round(b);
    const u = r << 16 | g << 8 | b;
    let str = "000000" + u.toString(16);
    str = str.substr(str.length - 6);
    let hxa = "0" + round(a * 255).toString(16);
    hxa = hxa.substr(hxa.length - 2);
    switch (mode.toLowerCase()) {
      case "rgba":
        return `#${str}${hxa}`;
      case "argb":
        return `#${hxa}${str}`;
      default:
        return `#${str}`;
    }
  };
  rgb2hex_1 = rgb2hex;
  return rgb2hex_1;
}
var hex2rgb_1;
var hasRequiredHex2rgb;
function requireHex2rgb() {
  if (hasRequiredHex2rgb) return hex2rgb_1;
  hasRequiredHex2rgb = 1;
  const RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
  const RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
  const hex2rgb = (hex2) => {
    if (hex2.match(RE_HEX)) {
      if (hex2.length === 4 || hex2.length === 7) {
        hex2 = hex2.substr(1);
      }
      if (hex2.length === 3) {
        hex2 = hex2.split("");
        hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2];
      }
      const u = parseInt(hex2, 16);
      const r = u >> 16;
      const g = u >> 8 & 255;
      const b = u & 255;
      return [r, g, b, 1];
    }
    if (hex2.match(RE_HEXA)) {
      if (hex2.length === 5 || hex2.length === 9) {
        hex2 = hex2.substr(1);
      }
      if (hex2.length === 4) {
        hex2 = hex2.split("");
        hex2 = hex2[0] + hex2[0] + hex2[1] + hex2[1] + hex2[2] + hex2[2] + hex2[3] + hex2[3];
      }
      const u = parseInt(hex2, 16);
      const r = u >> 24 & 255;
      const g = u >> 16 & 255;
      const b = u >> 8 & 255;
      const a = Math.round((u & 255) / 255 * 100) / 100;
      return [r, g, b, a];
    }
    throw new Error(`unknown hex color: ${hex2}`);
  };
  hex2rgb_1 = hex2rgb;
  return hex2rgb_1;
}
var hasRequiredHex;
function requireHex() {
  if (hasRequiredHex) return hex;
  hasRequiredHex = 1;
  const chroma2 = requireChroma();
  const Color = requireColor();
  const { type: type2 } = requireUtils();
  const input2 = requireInput();
  const rgb2hex = requireRgb2hex();
  Color.prototype.hex = function(mode) {
    return rgb2hex(this._rgb, mode);
  };
  chroma2.hex = (...args) => new Color(...args, "hex");
  input2.format.hex = requireHex2rgb();
  input2.autodetect.push({
    p: 4,
    test: (h, ...rest) => {
      if (!rest.length && type2(h) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h.length) >= 0) {
        return "hex";
      }
    }
  });
  return hex;
}
requireHex();
var hsl = {};
var hasRequiredHsl$1;
function requireHsl$1() {
  if (hasRequiredHsl$1) return hsl;
  hasRequiredHsl$1 = 1;
  const { unpack: unpack2, type: type2 } = requireUtils();
  const chroma2 = requireChroma();
  const Color = requireColor();
  const input2 = requireInput();
  const rgb2hsl = requireRgb2hsl();
  Color.prototype.hsl = function() {
    return rgb2hsl(this._rgb);
  };
  chroma2.hsl = (...args) => new Color(...args, "hsl");
  input2.format.hsl = requireHsl2rgb();
  input2.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack2(args, "hsl");
      if (type2(args) === "array" && args.length === 3) {
        return "hsl";
      }
    }
  });
  return hsl;
}
requireHsl$1();
var hsv = {};
var rgb2hsv;
var hasRequiredRgb2hsv;
function requireRgb2hsv() {
  if (hasRequiredRgb2hsv) return rgb2hsv;
  hasRequiredRgb2hsv = 1;
  const { unpack: unpack2 } = requireUtils();
  const { min, max } = Math;
  const rgb2hsl = (...args) => {
    args = unpack2(args, "rgb");
    let [r, g, b] = args;
    const min_ = min(r, g, b);
    const max_ = max(r, g, b);
    const delta = max_ - min_;
    let h, s, v;
    v = max_ / 255;
    if (max_ === 0) {
      h = Number.NaN;
      s = 0;
    } else {
      s = delta / max_;
      if (r === max_) h = (g - b) / delta;
      if (g === max_) h = 2 + (b - r) / delta;
      if (b === max_) h = 4 + (r - g) / delta;
      h *= 60;
      if (h < 0) h += 360;
    }
    return [h, s, v];
  };
  rgb2hsv = rgb2hsl;
  return rgb2hsv;
}
var hsv2rgb_1;
var hasRequiredHsv2rgb;
function requireHsv2rgb() {
  if (hasRequiredHsv2rgb) return hsv2rgb_1;
  hasRequiredHsv2rgb = 1;
  const { unpack: unpack2 } = requireUtils();
  const { floor } = Math;
  const hsv2rgb = (...args) => {
    args = unpack2(args, "hsv");
    let [h, s, v] = args;
    let r, g, b;
    v *= 255;
    if (s === 0) {
      r = g = b = v;
    } else {
      if (h === 360) h = 0;
      if (h > 360) h -= 360;
      if (h < 0) h += 360;
      h /= 60;
      const i = floor(h);
      const f = h - i;
      const p = v * (1 - s);
      const q = v * (1 - s * f);
      const t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          [r, g, b] = [v, t, p];
          break;
        case 1:
          [r, g, b] = [q, v, p];
          break;
        case 2:
          [r, g, b] = [p, v, t];
          break;
        case 3:
          [r, g, b] = [p, q, v];
          break;
        case 4:
          [r, g, b] = [t, p, v];
          break;
        case 5:
          [r, g, b] = [v, p, q];
          break;
      }
    }
    return [r, g, b, args.length > 3 ? args[3] : 1];
  };
  hsv2rgb_1 = hsv2rgb;
  return hsv2rgb_1;
}
var hasRequiredHsv$1;
function requireHsv$1() {
  if (hasRequiredHsv$1) return hsv;
  hasRequiredHsv$1 = 1;
  const { unpack: unpack2, type: type2 } = requireUtils();
  const chroma2 = requireChroma();
  const Color = requireColor();
  const input2 = requireInput();
  const rgb2hsv2 = requireRgb2hsv();
  Color.prototype.hsv = function() {
    return rgb2hsv2(this._rgb);
  };
  chroma2.hsv = (...args) => new Color(...args, "hsv");
  input2.format.hsv = requireHsv2rgb();
  input2.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack2(args, "hsv");
      if (type2(args) === "array" && args.length === 3) {
        return "hsv";
      }
    }
  });
  return hsv;
}
requireHsv$1();
var named = {};
var w3cx11_1;
var hasRequiredW3cx11;
function requireW3cx11() {
  if (hasRequiredW3cx11) return w3cx11_1;
  hasRequiredW3cx11 = 1;
  const w3cx11 = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflower: "#6495ed",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    laserlemon: "#ffff54",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrod: "#fafad2",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    maroon2: "#7f0000",
    maroon3: "#b03060",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    purple2: "#7f007f",
    purple3: "#a020f0",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  w3cx11_1 = w3cx11;
  return w3cx11_1;
}
var hasRequiredNamed;
function requireNamed() {
  if (hasRequiredNamed) return named;
  hasRequiredNamed = 1;
  const Color = requireColor();
  const input2 = requireInput();
  const { type: type2 } = requireUtils();
  const w3cx11 = requireW3cx11();
  const hex2rgb = requireHex2rgb();
  const rgb2hex = requireRgb2hex();
  Color.prototype.name = function() {
    const hex2 = rgb2hex(this._rgb, "rgb");
    for (let n of Object.keys(w3cx11)) {
      if (w3cx11[n] === hex2) return n.toLowerCase();
    }
    return hex2;
  };
  input2.format.named = (name) => {
    name = name.toLowerCase();
    if (w3cx11[name]) return hex2rgb(w3cx11[name]);
    throw new Error("unknown color name: " + name);
  };
  input2.autodetect.push({
    p: 5,
    test: (h, ...rest) => {
      if (!rest.length && type2(h) === "string" && w3cx11[h.toLowerCase()]) {
        return "named";
      }
    }
  });
  return named;
}
requireNamed();
var rgb = {};
var hasRequiredRgb$1;
function requireRgb$1() {
  if (hasRequiredRgb$1) return rgb;
  hasRequiredRgb$1 = 1;
  const chroma2 = requireChroma();
  const Color = requireColor();
  const input2 = requireInput();
  const { unpack: unpack2, type: type2 } = requireUtils();
  const { round } = Math;
  Color.prototype.rgb = function(rnd = true) {
    if (rnd === false) return this._rgb.slice(0, 3);
    return this._rgb.slice(0, 3).map(round);
  };
  Color.prototype.rgba = function(rnd = true) {
    return this._rgb.slice(0, 4).map((v, i) => {
      return i < 3 ? rnd === false ? v : round(v) : v;
    });
  };
  chroma2.rgb = (...args) => new Color(...args, "rgb");
  input2.format.rgb = (...args) => {
    const rgba = unpack2(args, "rgba");
    if (rgba[3] === void 0) rgba[3] = 1;
    return rgba;
  };
  input2.autodetect.push({
    p: 3,
    test: (...args) => {
      args = unpack2(args, "rgba");
      if (type2(args) === "array" && (args.length === 3 || args.length === 4 && type2(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
        return "rgb";
      }
    }
  });
  return rgb;
}
requireRgb$1();
var alpha = {};
var hasRequiredAlpha;
function requireAlpha() {
  if (hasRequiredAlpha) return alpha;
  hasRequiredAlpha = 1;
  const Color = requireColor();
  const { type: type2 } = requireUtils();
  Color.prototype.alpha = function(a, mutate = false) {
    if (a !== void 0 && type2(a) === "number") {
      if (mutate) {
        this._rgb[3] = a;
        return this;
      }
      return new Color([this._rgb[0], this._rgb[1], this._rgb[2], a], "rgb");
    }
    return this._rgb[3];
  };
  return alpha;
}
requireAlpha();
var _hsx;
var hasRequired_hsx;
function require_hsx() {
  if (hasRequired_hsx) return _hsx;
  hasRequired_hsx = 1;
  const Color = requireColor();
  _hsx = (col1, col2, f, m) => {
    let xyz0, xyz1;
    if (m === "hsl") {
      xyz0 = col1.hsl();
      xyz1 = col2.hsl();
    } else if (m === "hsv") {
      xyz0 = col1.hsv();
      xyz1 = col2.hsv();
    } else if (m === "hcg") {
      xyz0 = col1.hcg();
      xyz1 = col2.hcg();
    } else if (m === "hsi") {
      xyz0 = col1.hsi();
      xyz1 = col2.hsi();
    } else if (m === "lch" || m === "hcl") {
      m = "hcl";
      xyz0 = col1.hcl();
      xyz1 = col2.hcl();
    } else if (m === "oklch") {
      xyz0 = col1.oklch().reverse();
      xyz1 = col2.oklch().reverse();
    }
    let hue0, hue1, sat0, sat1, lbv0, lbv1;
    if (m.substr(0, 1) === "h" || m === "oklch") {
      [hue0, sat0, lbv0] = xyz0;
      [hue1, sat1, lbv1] = xyz1;
    }
    let sat, hue, lbv, dh;
    if (!isNaN(hue0) && !isNaN(hue1)) {
      if (hue1 > hue0 && hue1 - hue0 > 180) {
        dh = hue1 - (hue0 + 360);
      } else if (hue1 < hue0 && hue0 - hue1 > 180) {
        dh = hue1 + 360 - hue0;
      } else {
        dh = hue1 - hue0;
      }
      hue = hue0 + f * dh;
    } else if (!isNaN(hue0)) {
      hue = hue0;
      if ((lbv1 == 1 || lbv1 == 0) && m != "hsv") sat = sat0;
    } else if (!isNaN(hue1)) {
      hue = hue1;
      if ((lbv0 == 1 || lbv0 == 0) && m != "hsv") sat = sat1;
    } else {
      hue = Number.NaN;
    }
    if (sat === void 0) sat = sat0 + f * (sat1 - sat0);
    lbv = lbv0 + f * (lbv1 - lbv0);
    return m === "oklch" ? new Color([lbv, sat, hue], m) : new Color([hue, sat, lbv], m);
  };
  return _hsx;
}
var interpolator;
var hasRequiredInterpolator;
function requireInterpolator() {
  if (hasRequiredInterpolator) return interpolator;
  hasRequiredInterpolator = 1;
  interpolator = {};
  return interpolator;
}
var hsl_1;
var hasRequiredHsl;
function requireHsl() {
  if (hasRequiredHsl) return hsl_1;
  hasRequiredHsl = 1;
  requireHsl$1();
  const interpolate_hsx = require_hsx();
  const hsl2 = (col1, col2, f) => {
    return interpolate_hsx(col1, col2, f, "hsl");
  };
  requireInterpolator().hsl = hsl2;
  hsl_1 = hsl2;
  return hsl_1;
}
requireHsl();
var hsv_1;
var hasRequiredHsv;
function requireHsv() {
  if (hasRequiredHsv) return hsv_1;
  hasRequiredHsv = 1;
  requireHsv$1();
  const interpolate_hsx = require_hsx();
  const hsv2 = (col1, col2, f) => {
    return interpolate_hsx(col1, col2, f, "hsv");
  };
  requireInterpolator().hsv = hsv2;
  hsv_1 = hsv2;
  return hsv_1;
}
requireHsv();
var rgb_1;
var hasRequiredRgb;
function requireRgb() {
  if (hasRequiredRgb) return rgb_1;
  hasRequiredRgb = 1;
  const Color = requireColor();
  const rgb2 = (col1, col2, f) => {
    const xyz0 = col1._rgb;
    const xyz1 = col2._rgb;
    return new Color(
      xyz0[0] + f * (xyz1[0] - xyz0[0]),
      xyz0[1] + f * (xyz1[1] - xyz0[1]),
      xyz0[2] + f * (xyz1[2] - xyz0[2]),
      "rgb"
    );
  };
  requireInterpolator().rgb = rgb2;
  rgb_1 = rgb2;
  return rgb_1;
}
requireRgb();
var mix$1;
var hasRequiredMix;
function requireMix() {
  if (hasRequiredMix) return mix$1;
  hasRequiredMix = 1;
  const Color = requireColor();
  const { type: type2 } = requireUtils();
  const interpolator2 = requireInterpolator();
  mix$1 = (col1, col2, f = 0.5, ...rest) => {
    let mode = rest[0] || "lrgb";
    if (!interpolator2[mode] && !rest.length) {
      mode = Object.keys(interpolator2)[0];
    }
    if (!interpolator2[mode]) {
      throw new Error(`interpolation mode ${mode} is not defined`);
    }
    if (type2(col1) !== "object") col1 = new Color(col1);
    if (type2(col2) !== "object") col2 = new Color(col2);
    return interpolator2[mode](col1, col2, f).alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
  };
  return mix$1;
}
var mixExports = requireMix();
var mix = getDefaultExportFromCjs(mixExports);
var scale$1;
var hasRequiredScale;
function requireScale() {
  if (hasRequiredScale) return scale$1;
  hasRequiredScale = 1;
  const chroma2 = requireChroma();
  const { type: type2 } = requireUtils();
  const { pow } = Math;
  scale$1 = function(colors) {
    let _mode = "rgb";
    let _nacol = chroma2("#ccc");
    let _spread = 0;
    let _domain = [0, 1];
    let _pos = [];
    let _padding = [0, 0];
    let _classes = false;
    let _colors = [];
    let _out = false;
    let _min = 0;
    let _max = 1;
    let _correctLightness = false;
    let _colorCache = {};
    let _useCache = true;
    let _gamma = 1;
    const setColors = function(colors2) {
      colors2 = colors2 || ["#fff", "#000"];
      if (colors2 && type2(colors2) === "string" && chroma2.brewer && chroma2.brewer[colors2.toLowerCase()]) {
        colors2 = chroma2.brewer[colors2.toLowerCase()];
      }
      if (type2(colors2) === "array") {
        if (colors2.length === 1) {
          colors2 = [colors2[0], colors2[0]];
        }
        colors2 = colors2.slice(0);
        for (let c = 0; c < colors2.length; c++) {
          colors2[c] = chroma2(colors2[c]);
        }
        _pos.length = 0;
        for (let c = 0; c < colors2.length; c++) {
          _pos.push(c / (colors2.length - 1));
        }
      }
      resetCache();
      return _colors = colors2;
    };
    const getClass = function(value) {
      if (_classes != null) {
        const n = _classes.length - 1;
        let i = 0;
        while (i < n && value >= _classes[i]) {
          i++;
        }
        return i - 1;
      }
      return 0;
    };
    let tMapLightness = (t) => t;
    let tMapDomain = (t) => t;
    const getColor = function(val, bypassMap) {
      let col, t;
      if (bypassMap == null) {
        bypassMap = false;
      }
      if (isNaN(val) || val === null) {
        return _nacol;
      }
      if (!bypassMap) {
        if (_classes && _classes.length > 2) {
          const c = getClass(val);
          t = c / (_classes.length - 2);
        } else if (_max !== _min) {
          t = (val - _min) / (_max - _min);
        } else {
          t = 1;
        }
      } else {
        t = val;
      }
      t = tMapDomain(t);
      if (!bypassMap) {
        t = tMapLightness(t);
      }
      if (_gamma !== 1) {
        t = pow(t, _gamma);
      }
      t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
      t = Math.min(1, Math.max(0, t));
      const k = Math.floor(t * 1e4);
      if (_useCache && _colorCache[k]) {
        col = _colorCache[k];
      } else {
        if (type2(_colors) === "array") {
          for (let i = 0; i < _pos.length; i++) {
            const p = _pos[i];
            if (t <= p) {
              col = _colors[i];
              break;
            }
            if (t >= p && i === _pos.length - 1) {
              col = _colors[i];
              break;
            }
            if (t > p && t < _pos[i + 1]) {
              t = (t - p) / (_pos[i + 1] - p);
              col = chroma2.interpolate(_colors[i], _colors[i + 1], t, _mode);
              break;
            }
          }
        } else if (type2(_colors) === "function") {
          col = _colors(t);
        }
        if (_useCache) {
          _colorCache[k] = col;
        }
      }
      return col;
    };
    var resetCache = () => _colorCache = {};
    setColors(colors);
    const f = function(v) {
      const c = chroma2(getColor(v));
      if (_out && c[_out]) {
        return c[_out]();
      } else {
        return c;
      }
    };
    f.classes = function(classes) {
      if (classes != null) {
        if (type2(classes) === "array") {
          _classes = classes;
          _domain = [classes[0], classes[classes.length - 1]];
        } else {
          const d = chroma2.analyze(_domain);
          if (classes === 0) {
            _classes = [d.min, d.max];
          } else {
            _classes = chroma2.limits(d, "e", classes);
          }
        }
        return f;
      }
      return _classes;
    };
    f.domain = function(domain) {
      if (!arguments.length) {
        return _domain;
      }
      _min = domain[0];
      _max = domain[domain.length - 1];
      _pos = [];
      const k = _colors.length;
      if (domain.length === k && _min !== _max) {
        for (let d of Array.from(domain)) {
          _pos.push((d - _min) / (_max - _min));
        }
      } else {
        for (let c = 0; c < k; c++) {
          _pos.push(c / (k - 1));
        }
        if (domain.length > 2) {
          const tOut = domain.map((d, i) => i / (domain.length - 1));
          const tBreaks = domain.map((d) => (d - _min) / (_max - _min));
          if (!tBreaks.every((val, i) => tOut[i] === val)) {
            tMapDomain = (t) => {
              if (t <= 0 || t >= 1) return t;
              let i = 0;
              while (t >= tBreaks[i + 1]) i++;
              const f2 = (t - tBreaks[i]) / (tBreaks[i + 1] - tBreaks[i]);
              const out = tOut[i] + f2 * (tOut[i + 1] - tOut[i]);
              return out;
            };
          }
        }
      }
      _domain = [_min, _max];
      return f;
    };
    f.mode = function(_m) {
      if (!arguments.length) {
        return _mode;
      }
      _mode = _m;
      resetCache();
      return f;
    };
    f.range = function(colors2, _pos2) {
      setColors(colors2);
      return f;
    };
    f.out = function(_o) {
      _out = _o;
      return f;
    };
    f.spread = function(val) {
      if (!arguments.length) {
        return _spread;
      }
      _spread = val;
      return f;
    };
    f.correctLightness = function(v) {
      if (v == null) {
        v = true;
      }
      _correctLightness = v;
      resetCache();
      if (_correctLightness) {
        tMapLightness = function(t) {
          const L0 = getColor(0, true).lab()[0];
          const L1 = getColor(1, true).lab()[0];
          const pol = L0 > L1;
          let L_actual = getColor(t, true).lab()[0];
          const L_ideal = L0 + (L1 - L0) * t;
          let L_diff = L_actual - L_ideal;
          let t0 = 0;
          let t1 = 1;
          let max_iter = 20;
          while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
            (function() {
              if (pol) {
                L_diff *= -1;
              }
              if (L_diff < 0) {
                t0 = t;
                t += (t1 - t) * 0.5;
              } else {
                t1 = t;
                t += (t0 - t) * 0.5;
              }
              L_actual = getColor(t, true).lab()[0];
              return L_diff = L_actual - L_ideal;
            })();
          }
          return t;
        };
      } else {
        tMapLightness = (t) => t;
      }
      return f;
    };
    f.padding = function(p) {
      if (p != null) {
        if (type2(p) === "number") {
          p = [p, p];
        }
        _padding = p;
        return f;
      } else {
        return _padding;
      }
    };
    f.colors = function(numColors, out) {
      if (arguments.length < 2) {
        out = "hex";
      }
      let result = [];
      if (arguments.length === 0) {
        result = _colors.slice(0);
      } else if (numColors === 1) {
        result = [f(0.5)];
      } else if (numColors > 1) {
        const dm = _domain[0];
        const dd = _domain[1] - dm;
        result = __range__(0, numColors).map((i) => f(dm + i / (numColors - 1) * dd));
      } else {
        colors = [];
        let samples = [];
        if (_classes && _classes.length > 2) {
          for (let i = 1, end = _classes.length, asc = 1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
            samples.push((_classes[i - 1] + _classes[i]) * 0.5);
          }
        } else {
          samples = _domain;
        }
        result = samples.map((v) => f(v));
      }
      if (chroma2[out]) {
        result = result.map((c) => c[out]());
      }
      return result;
    };
    f.cache = function(c) {
      if (c != null) {
        _useCache = c;
        return f;
      } else {
        return _useCache;
      }
    };
    f.gamma = function(g) {
      if (g != null) {
        _gamma = g;
        return f;
      } else {
        return _gamma;
      }
    };
    f.nodata = function(d) {
      if (d != null) {
        _nacol = chroma2(d);
        return f;
      } else {
        return _nacol;
      }
    };
    return f;
  };
  function __range__(left, right, inclusive) {
    let range = [];
    let ascending = left < right;
    let end = right;
    for (let i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
      range.push(i);
    }
    return range;
  }
  return scale$1;
}
var scaleExports = requireScale();
var scale = getDefaultExportFromCjs(scaleExports);
chroma.mix = chroma.interpolate = mix;
chroma.scale = scale;
var LINE_SEPARATOR_REGEX = /[ ,\t:]+/g;
var COLOR_SEPARATOR_REGEX = /[\-\/]/g;
function isLineComment(line) {
  return line.startsWith("#");
}
function isGmt4Text(lines) {
  return lines.some((line) => {
    if (!isLineComment(line)) {
      if (line.split(LINE_SEPARATOR_REGEX).length >= 8) {
        return true;
      }
    }
    return false;
  });
}
function isGmt5Text(lines) {
  return lines.some((line) => {
    if (!isLineComment(line)) {
      if (line.match(/\d+\-\d+\-\d+/) || line.match(/\d+\/\d+\/\d+/)) {
        return true;
      }
    }
    return false;
  });
}
function getMode(lines) {
  const modeLine = lines.find((line) => isLineComment(line) && line.includes("COLOR_MODEL = "));
  if (modeLine) {
    const match = modeLine.match(/COLOR_MODEL = ([a-zA-Z]+)/);
    if (match) {
      return match[1].toLowerCase();
    }
  }
  return void 0;
}
function splitColor(color) {
  const colorArray = color.split(COLOR_SEPARATOR_REGEX);
  return colorArray.length === 1 ? colorArray[0] : colorArray;
}
function parsePaletteTextInternal(paletteText) {
  const lines = paletteText.trim().split("\n");
  const isGmt4 = isGmt4Text(lines);
  const isGmt5 = isGmt5Text(lines);
  const mode = getMode(lines);
  const paletteLines = lines.filter((x) => !!x && !x.startsWith("#"));
  const paletteArray = [];
  for (let paletteLine of paletteLines) {
    const fields = paletteLine.split(LINE_SEPARATOR_REGEX);
    if (isGmt4) {
      if (fields.length === 8 || fields.length === 9) {
        paletteArray.push([fields[0], [fields[1], fields[2], fields[3]]]);
        paletteArray.push([fields[4], [fields[5], fields[6], fields[7]]]);
      } else if (fields.length === 4 || fields.length === 5) {
        paletteArray.push([fields[0], [fields[1], fields[2], fields[3]]]);
      } else ;
    } else if (isGmt5) {
      if (fields.length === 4 || fields.length === 5) {
        paletteArray.push([fields[0], splitColor(fields[1])]);
        paletteArray.push([fields[2], splitColor(fields[3])]);
      } else if (fields.length === 2 || fields.length === 3) {
        paletteArray.push([fields[0], splitColor(fields[1])]);
      } else ;
    } else {
      if (fields.length === 5) {
        paletteArray.push([fields[0], [fields[1], fields[2], fields[3], fields[4]]]);
      } else if (fields.length === 4) {
        paletteArray.push([fields[0], [fields[1], fields[2], fields[3]]]);
      } else if (fields.length === 2) {
        paletteArray.push([fields[0], fields[1]]);
      } else ;
    }
  }
  return { paletteArray, mode };
}
var DEFAULT_MODE = "rgb";
function parseValue(value, bounds) {
  if (typeof value === "string") {
    if (value[value.length - 1] === "%") {
      const percentage = parseFloat(value) / 100;
      if (percentage < 0 || percentage > 1) {
        throw new Error(`Invalid value for a percentage ${value}`);
      }
      return bounds[0] + (bounds[1] - bounds[0]) * percentage;
    } else if (value === "N") {
      return null;
    } else if (value === "B") {
      return void 0;
    } else if (value === "F") {
      return void 0;
    } else if (value === "nv") {
      return null;
    } else if (value === "default") {
      return void 0;
    } else if (value === "null") {
      return null;
    } else if (value === "nodata") {
      return null;
    } else {
      return parseFloat(value);
    }
  } else if (typeof value === "number") {
    return value;
  } else {
    throw new Error("Invalid state");
  }
}
function parseColor(color, mode) {
  if (Array.isArray(color)) {
    if (color.length === 4) {
      return {
        [mode[0]]: parseFloat(color[0].toString()),
        [mode[1]]: parseFloat(color[1].toString()),
        [mode[2]]: parseFloat(color[2].toString()),
        a: parseFloat(color[3].toString()) / 255
      };
    } else if (color.length === 3) {
      return {
        [mode[0]]: parseFloat(color[0].toString()),
        [mode[1]]: parseFloat(color[1].toString()),
        [mode[2]]: parseFloat(color[2].toString())
      };
    } else {
      throw new Error(`Invalid color ${color}`);
    }
  } else if (typeof color === "string" || typeof color === "number") {
    if (color.toString().match(/^\d+$/) || typeof color === "number") {
      return {
        [mode[0]]: parseFloat(color.toString()),
        [mode[1]]: parseFloat(color.toString()),
        [mode[2]]: parseFloat(color.toString())
      };
    } else {
      return color;
    }
  } else {
    throw new Error(`Invalid color ${color}`);
  }
}
function parsePaletteArray(paletteArray, { bounds = [0, 1], mode = DEFAULT_MODE } = {}) {
  const colors = [];
  const domain = [];
  let nodata;
  for (let [value, color] of paletteArray) {
    const parsedValue = parseValue(value, bounds);
    const parsedColor = parseColor(color, mode);
    if (parsedValue != null) {
      colors.push(parsedColor);
      domain.push(parsedValue);
    } else if (parsedValue === null) {
      nodata = parsedColor;
    } else ;
  }
  let palette = chroma.scale(colors).domain(domain).mode(mode);
  if (typeof nodata !== "undefined") {
    palette = palette.nodata(nodata);
  }
  return palette;
}
function parsePaletteText(paletteText, { bounds = [0, 1] } = {}) {
  const { paletteArray, mode } = parsePaletteTextInternal(paletteText);
  return parsePaletteArray(paletteArray, { bounds, mode });
}
function parsePalette(palette, { bounds = [0, 1] } = {}) {
  if (typeof palette === "string") {
    return parsePaletteText(palette, { bounds });
  } else if (Array.isArray(palette)) {
    return parsePaletteArray(palette, { bounds });
  } else {
    throw new Error("Invalid format");
  }
}
function colorRampCanvas(scale2, { width = 256, height = 1 } = {}) {
  const colors = scale2.colors(width, "css");
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  canvas.style.imageRendering = "-moz-crisp-edges";
  canvas.style.imageRendering = "pixelated";
  const ctx = canvas.getContext("2d");
  for (let i = 0; i < width; i++) {
    ctx.fillStyle = colors[i];
    ctx.fillRect(i, 0, 1, height);
  }
  return canvas;
}

export {
  parsePalette,
  colorRampCanvas
};
/*! Bundled license information:

cpt2js/dist/cpt2js.js:
  (*!
  * Copyright (c) 2022 WeatherLayers.com
  *
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *)
*/
//# sourceMappingURL=chunk-DWCLB6OW.js.map
