{"version":3,"sources":["../src/reshape.ts"],"names":[],"mappings":";;;AAAO,SAAS,OAAA,CAAW,IAAA,EAAoB,KAAA,EAAiB,YAAA,GAAe,KAAA,EAAY;AAEvF,EAAA,IAAI,CAAC,KAAA,CAAM,MAAA,EAAQ,OAAO,KAAK,CAAC,CAAA;AAGhC,EAAA,MAAM,SAAA,GAAY,MAAM,MAAA,CAAO,CAAC,GAAG,CAAA,KAAM,CAAA,GAAI,GAAG,CAAC,CAAA;AACjD,EAAA,IAAI,IAAA,CAAK,WAAW,SAAA,EAAW;AAC3B,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,6BAAA,EAAgC,IAAA,CAAK,MAAM,gBAAgB,KAAA,CAAM,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA,CAAG,CAAA;AAAA,EAClG;AAIA,EAAA,MAAM,OAAA,GAAoB,IAAI,KAAA,CAAM,KAAA,CAAM,MAAM,CAAA;AAChD,EAAA,IAAI,MAAA,GAAS,CAAA;AAEb,EAAA,IAAI,YAAA,EAAc;AAEd,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACnC,MAAA,OAAA,CAAQ,CAAC,CAAA,GAAI,MAAA;AACb,MAAA,MAAA,IAAU,MAAM,CAAC,CAAA;AAAA,IACrB;AAAA,EACJ,CAAA,MAAO;AAEH,IAAA,KAAA,IAAS,IAAI,KAAA,CAAM,MAAA,GAAS,CAAA,EAAG,CAAA,IAAK,GAAG,CAAA,EAAA,EAAK;AACxC,MAAA,OAAA,CAAQ,CAAC,CAAA,GAAI,MAAA;AACb,MAAA,MAAA,IAAU,MAAM,CAAC,CAAA;AAAA,IACrB;AAAA,EACJ;AAGA,EAAA,SAAS,KAAA,CAAM,MAAgB,aAAA,EAA8B;AACzD,IAAA,MAAM,CAAC,UAAA,EAAY,GAAG,aAAa,CAAA,GAAI,IAAA;AAEvC,IAAA,IAAI,CAAC,cAAc,MAAA,EAAQ;AACvB,MAAA,OAAO,KAAA,CAAM,KAAK,EAAE,MAAA,EAAQ,YAAW,EAAG,CAAC,GAAG,CAAA,KAAM;AAChD,QAAA,MAAM,WAAA,GAAc,CAAC,GAAG,aAAA,EAAe,CAAC,CAAA;AAExC,QAAA,IAAI,SAAA,GAAY,CAAA;AAChB,QAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,WAAA,CAAY,QAAQ,CAAA,EAAA,EAAK;AACzC,UAAA,SAAA,IAAa,WAAA,CAAY,CAAC,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA;AAAA,QAC3C;AACA,QAAA,OAAO,KAAK,SAAS,CAAA;AAAA,MACzB,CAAC,CAAA;AAAA,IACL;AAEA,IAAA,OAAO,KAAA,CAAM,IAAA;AAAA,MAAK,EAAE,QAAQ,UAAA,EAAW;AAAA,MAAG,CAAC,GAAG,CAAA,KAC1C,KAAA,CAAM,eAAe,CAAC,GAAG,aAAA,EAAe,CAAC,CAAC;AAAA,KAC9C;AAAA,EACJ;AAEA,EAAA,OAAO,KAAA,CAAM,KAAA,EAAO,EAAE,CAAA;AAC1B","file":"reshape.cjs","sourcesContent":["export function reshape<T>(flat: ArrayLike<T>, shape: number[], fortranOrder = false): any {\n    // Return the single element if shape is empty\n    if (!shape.length) return flat[0];\n\n    // Check if the total number of elements matches\n    const totalSize = shape.reduce((a, b) => a * b, 1);\n    if (flat.length !== totalSize) {\n        throw new Error(`Cannot reshape array of size ${flat.length} into shape (${shape.join(', ')})`);\n    }\n\n    // Strides determine how many indices to jump in the flat array\n    // when we move one step along a given dimension.\n    const strides: number[] = new Array(shape.length);\n    let stride = 1;\n\n    if (fortranOrder) {\n        // Fortran-order (column-major): First index changes fastest\n        for (let i = 0; i < shape.length; i++) {\n            strides[i] = stride;\n            stride *= shape[i];\n        }\n    } else {\n        // C-order (row-major): Last index changes fastest\n        for (let i = shape.length - 1; i >= 0; i--) {\n            strides[i] = stride;\n            stride *= shape[i];\n        }\n    }\n\n    // Recursive function to build the nested array\n    function build(dims: number[], currentCoords: number[]): any {\n        const [currentDim, ...remainingDims] = dims;\n\n        if (!remainingDims.length) {\n            return Array.from({ length: currentDim }, (_, i) => {\n                const finalCoords = [...currentCoords, i];\n                // Calculate the index in the flat array\n                let flatIndex = 0;\n                for (let d = 0; d < finalCoords.length; d++) {\n                    flatIndex += finalCoords[d] * strides[d];\n                }\n                return flat[flatIndex];\n            });\n        }\n\n        return Array.from({ length: currentDim }, (_, i) =>\n            build(remainingDims, [...currentCoords, i])\n        );\n    }\n\n    return build(shape, []);\n}"]}