{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","file":"index.cjs","sourcesContent":["export type DType =\n    | \"i1\" | \"u1\" | \"i2\" | \"u2\" | \"i4\" | \"u4\" | \"i8\" | \"u8\"\n    | \"f2\" | \"f4\" | \"f8\" | \"b1\" | `U${number}`; // e.g., U10 for strings of length 10\n\nexport type TypedArray =\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | BigInt64Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | Uint16Array\n    | Uint32Array\n    | BigUint64Array\n    | Float32Array\n    | Float64Array;\n\nexport interface NpyArray<T extends ArrayBufferView = ArrayBufferView> {\n    data: T;\n    shape: number[];\n    dtype: DType;\n    fortranOrder: boolean;\n}\n\nexport interface Options {\n    /** Convert float16 to float32. Default true. */\n    convertFloat16?: boolean;\n}\n\nclass StringFromCodePoint extends String {\n    constructor(buf: ArrayBufferLike, byteOffset?: number, length?: number) {\n        const uint32 = new Uint32Array(buf, byteOffset, length);\n        const number_arr = Array.from(uint32);\n        const str = String.fromCodePoint(...number_arr);\n        super(str);\n    }\n}\n\nconst textDecoder = new TextDecoder(\"latin1\");\n\nfunction readHeader(buf: ArrayBufferLike) {\n    const view = new DataView(buf);\n    const magic = String.fromCharCode(\n        view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3),\n        view.getUint8(4), view.getUint8(5)\n    );\n    if (magic !== \"\\x93NUMPY\") throw new Error(\"Not an .npy file\");\n\n    const major = view.getUint8(6);\n    const minor = view.getUint8(7);\n\n    let headerLen: number;\n    if (major <= 1) {\n        headerLen = view.getUint16(8, true);\n        return { headerOffset: 10, headerLen, version: [major, minor] as const };\n    } else {\n        headerLen = Number(view.getUint32(8, true));\n        return { headerOffset: 12, headerLen, version: [major, minor] as const };\n    }\n}\n\nfunction parseDict(dictStr: string) {\n    // very small parser for the NumPy header dict (single quotes, Python-likes)\n    // matches keys: descr, fortran_order, shape\n    const dtype = /'descr'\\s*:\\s*'([^']+)'/.exec(dictStr)?.[1];\n    const fortran = /'fortran_order'\\s*:\\s*(True|False)/.exec(dictStr)?.[1] === \"True\";\n    const shapeMatch = /'shape'\\s*:\\s*\\(([^)]*)\\)/.exec(dictStr)?.[1] ?? \"\";\n    const shape = shapeMatch.split(\",\").map(s => s.trim()).filter(Boolean).map(n => Number(n));\n    if (shape.length === 1 && dictStr.includes(\"(n,)\")) {/* ok */ }\n    return { dtype, fortranOrder: fortran, shape };\n}\n\nfunction dtypeToArray(dtype: string, buf: ArrayBufferLike, offset: number, opts: Options) {\n    const little = dtype.startsWith(\"<\") || dtype.startsWith(\"|\"); // | = not applicable\n    const code = dtype.substring(dtype.length -2); // e.g., 'f8', 'i8'\n    //parse unicode dtype. The format is a 'U' character followed by a number that is the number of unicode characters in the string\n    if (code[0] === \"U\") {\n        const size = parseInt(code.substring(1))\n        const _string = String(new StringFromCodePoint(buf, offset));\n        const strings : string[] = [];\n        //split the string into an array of strings with length dtype.size\n        for (let i = 0; i < _string.length; i += size) {\n            strings.push(_string.substring(i, i + size).replace(/\\0/g, ''));\n        }\n        return strings;\n    }\n    switch (code) {\n        case \"b1\":\n            {\n                // Numpy saves bools in the header as |b1\n                if (little) {\n                    const u8 = new Uint8Array(buf, offset);\n                    const bools = new Array(u8.length);\n                    for (let i = 0; i < u8.length; i++) bools[i] = u8[i] !== 0;\n                    return bools;\n                } else {\n                    return new Uint8Array(buf, offset);\n                }\n            }\n        case \"i1\": return new Int8Array(buf, offset);\n        case \"u1\": return new Uint8Array(buf, offset);\n        case \"i2\": return new Int16Array(buf, offset);\n        case \"u2\": return new Uint16Array(buf, offset);\n        case \"i4\": return new Int32Array(buf, offset);\n        case \"u4\": return new Uint32Array(buf, offset);\n        case \"i8\": return new BigInt64Array(buf, offset);\n        case \"u8\": return new BigUint64Array(buf, offset);\n        case \"f4\": return new Float32Array(buf, offset);\n        case \"f8\": return new Float64Array(buf, offset);\n        case \"f2\": {\n            if (opts.convertFloat16 !== false) {\n                const u16 = new Uint16Array(buf, offset);\n                const f32 = new Float32Array(u16.length);\n                for (let i = 0; i < u16.length; i++) f32[i] = f16toF32(u16[i]);\n                return f32;\n            }\n            return new Uint16Array(buf, offset);\n        }\n        default: throw new Error(`Unsupported dtype: ${dtype}`);\n    }\n}\n\n// Kahan-friendly f16→f32 (IEEE 754)\nfunction f16toF32(u16: number): number {\n    const s = (u16 & 0x8000) >> 15;\n    const e = (u16 & 0x7C00) >> 10;\n    const f = u16 & 0x03FF;\n    if (e === 0) return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n    if (e === 0x1F) return f ? NaN : (s ? -Infinity : Infinity);\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n\nexport async function load(source: string | ArrayBuffer | ArrayBufferView | Blob, opts: Options = {}): Promise<NpyArray> {\n    let buf: ArrayBufferLike;\n    if (typeof source === \"string\") {\n        const res = await fetch(source);\n        buf = await res.arrayBuffer();\n    } else if (source instanceof ArrayBuffer) {\n        buf = source;\n    } else if (source instanceof Blob) {\n        buf = await source.arrayBuffer();\n    } else {\n        buf = source.buffer;\n    }\n\n    const { headerOffset, headerLen } = readHeader(buf);\n    const headerBytes = new Uint8Array(buf, headerOffset, headerLen);\n    const header = textDecoder.decode(headerBytes).trim();\n\n    const { dtype, fortranOrder, shape } = parseDict(header);\n    if (!dtype || !shape) throw new Error(\"Malformed .npy header\");\n\n    // Data starts at headerOffset + headerLen, already padded to 16-byte boundary by format spec\n    const dataOffset = headerOffset + headerLen;\n    const data = dtypeToArray(dtype, buf, dataOffset, opts);\n\n    return { data, shape, dtype: dtype.slice(1) as DType, fortranOrder } as NpyArray;\n}\n\n\n// Back-compat:\n\n// keep existing named exports above (load, types, etc.)\nexport function float16ToFloat32(u16: number): number {\n    return f16toF32(u16);\n}\n\nfunction arrayToDtype(array: unknown): DType {\n    if (array instanceof Uint8Array) {\n        return \"u1\";\n    }\n    if (array instanceof Uint8ClampedArray) {\n        return \"u1\";\n    }\n    if (array instanceof Int8Array) {\n        return \"i1\";\n    }\n    if (array instanceof Uint16Array) {\n        return \"u2\";\n    }\n    if (array instanceof Int16Array) {\n        return \"i2\";\n    }\n    if (array instanceof Uint32Array) {\n        return \"u4\";\n    }\n    if (array instanceof Int32Array) {\n        return \"i4\";\n    }\n    if (array instanceof Float32Array) {\n        return \"f4\";\n    }\n    if (array instanceof BigUint64Array) {\n        return \"u8\";\n    }\n    if (array instanceof BigInt64Array) {\n        return \"i8\";\n    }\n    if (array instanceof Float64Array) {\n        return \"f8\";\n    }\n    const kind = typeof array === \"object\" ? array?.constructor?.name : typeof array;\n    throw new TypeError(`Unsupported dtype for ${kind}`);\n}\n\nexport function arrayToTypedArray(dtype: DType, array: ArrayLike<number | string>): TypedArray { \n    if (!Array.isArray(array)) throw new TypeError(\"Expected an array\");\n\n    if (dtype.startsWith(\"U\")) {\n        // Unicode string array\n        const size = parseInt(dtype.substring(1));\n        const buf = new ArrayBuffer(array.length * size * 4);\n        const uint32 = new Uint32Array(buf);\n        for (let i = 0; i < array.length; i++) {\n            const str = array[i] as string;\n            for (let j = 0; j < size; j++) {\n                const code = j < str.length ? str.codePointAt(j) ?? 0 : 0;\n                uint32[i * size + j] = code!;\n            }\n        }\n        return new Uint8Array(buf);\n    }\n\n    switch (dtype) {\n        case \"b1\": return new Uint8Array(array);\n        case \"i1\": return new Int8Array(array);\n        case \"u1\": return new Uint8Array(array);\n        case \"i2\": return new Int16Array(array);\n        case \"u2\": return new Uint16Array(array);\n        case \"i4\": return new Int32Array(array);\n        case \"u4\": return new Uint32Array(array);\n        case \"i8\": return new BigInt64Array(array);\n        case \"u8\": return new BigUint64Array(array);\n        case \"f4\": return new Float32Array(array);\n        case \"f8\": return new Float64Array(array);\n        default: throw new Error(`Unsupported dtype: ${dtype}`);\n    }\n}\n\nfunction inferUnicodeDtypeFromStringArray(array: string[]): DType {\n    let longestStringLength = array[0].length;\n    for (let i = 1; i < array.length; i++) {\n        const element = array[i];\n        if (typeof element === \"string\" && element.length > longestStringLength) {\n            longestStringLength = element.length;\n        }\n    }\n    return `U${Math.max(1, longestStringLength)}` as DType; // e.g., U10 for strings of length 10\n}\n\nfunction inferDtypeFromNumberArray(array: number[]): DType {\n    let isInteger = true;\n    let isNonNegative = true;\n    let maxAbsValue = 0;\n\n    for (const num of array) {\n        if (!Number.isInteger(num)) {\n            isInteger = false;\n        }\n        if (num < 0) {\n            isNonNegative = false;\n        }\n        const absNum = Math.abs(num);\n        if (absNum > maxAbsValue) {\n            maxAbsValue = absNum;\n        }\n    }\n\n    if (!isInteger) {\n        if (maxAbsValue <= 3.40282347e+38) return \"f4\"; // max representable float32\n        return \"f8\"; // default to float64\n    }\n\n    // Integer array, determine smallest fitting dtype\n    if (isNonNegative) {\n        // Unsigned integers\n        if (maxAbsValue <= 0xFF) return \"u1\";\n        if (maxAbsValue <= 0xFFFF) return \"u2\";\n        if (maxAbsValue <= 0xFFFFFFFF) return \"u4\";\n        return \"u8\";\n    } else {\n        // Signed integers\n        if (maxAbsValue <= 0x7F) return \"i1\";\n        if (maxAbsValue <= 0x7FFF) return \"i2\";\n        if (maxAbsValue <= 0x7FFFFFFF) return \"i4\";\n        return \"i8\";\n    }\n}\n\nexport function inferDtypeFromArray(array: Array<number | number[] | string | string[]>): DType {\n    if (array.length === 0) return \"f8\"; // default to float64 for empty arrays\n    const first = array[0];\n\n    if (typeof first === \"number\") {\n        return inferDtypeFromNumberArray(array as number[]);\n    }\n\n    if (typeof first === \"string\") {\n        return inferUnicodeDtypeFromStringArray(array as string[]);\n    }\n\n    if (Array.isArray(first)) {\n        // Nested array, infer from first sub-array\n        return inferDtypeFromArray(first);\n    }\n\n    if (typeof first === \"boolean\") {\n        return \"b1\";\n    }\n\n    throw new TypeError(\"Array elements must be numbers, strings or booleans\");\n}\n\n/**\n * True if the system is little endian.\n */\nfunction isLittleEndian(): boolean {\n    // The result could be cached\n    return ((new Uint32Array((new Uint8Array([1, 0, 0, 0])).buffer))[0] === 1);\n}\n\nfunction createPyDescription(dtype : DType, shape: number[]) : string {\n\n    const isByte = dtype == 'u1' || dtype == 'i1';\n    const endianness = isByte ? '|' : (isLittleEndian() ? '<' : '>');\n    const descr = `${endianness}${dtype}`;\n    let pyShape = shape.map((v) => { return `${v}`; }).join(\",\");\n    if (shape.length === 1) pyShape += \",\";\n\n    return `{'descr':'${descr}','fortran_order':False,'shape':(${pyShape})}`;\n}\n\nexport function dump(array: TypedArray | Array<number | string>, shape: number[] | undefined) : ArrayBuffer{\n    const dtype = array instanceof Array ? inferDtypeFromArray(array) : arrayToDtype(array);\n    array = array instanceof Array ? arrayToTypedArray(dtype, array) : array;\n    \n    let pyDesc = createPyDescription(dtype, shape ?? [array.length]);\n    let headerSize = 10 + pyDesc.length;\n    const pad = 8 - ((headerSize + 1) % 8);\n    pyDesc = pyDesc + \" \".repeat(pad) + \"\\x0A\";\n    headerSize += pad + 1;\n    const buffer = new ArrayBuffer(headerSize + array.byteLength);\n    const view = new DataView(buffer);\n    view.setUint32(0, 2471384397, false);\n    view.setUint32(4, 1348010240, false);\n    view.setUint16(8, pyDesc.length, true);\n    const encoder = new TextEncoder();\n    const header = new Uint8Array(buffer, 10, pyDesc.length);\n    encoder.encodeInto(pyDesc, header);\n    const data = new Uint8Array(buffer, 10 + pyDesc.length);\n    data.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));\n    return buffer;\n}\n\n// Back-compat class API (matches old tests)\nexport default class N {\n    private opts: Options;\n    constructor(opts: Options = {}) {\n        this.opts = opts;\n    }\n    async load(source: string | ArrayBuffer | ArrayBufferView) {\n        return load(source, this.opts);\n    }\n    \n    static float16ToFloat32(u16: number) {\n        return f16toF32(u16);\n    }\n\n    dump(array: TypedArray | Array<number | string>, shape: number[]) {\n        return dump(array, shape);\n    }\n}\n"]}