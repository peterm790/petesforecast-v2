import { Color, DefaultProps, LayerProps, CompositeLayer, LayersList, UpdateParameters, CompositeLayerProps, Position, PickingInfo } from '@deck.gl/core';
import { Palette } from 'cpt2js';
export { Palette, Scale, colorRampCanvas, parsePalette } from 'cpt2js';
import { Texture } from '@luma.gl/core';
import { BitmapLayerProps, BitmapBoundingBox, LineLayerProps } from '@deck.gl/layers';

declare const VERSION: string;
declare const DATETIME: string;

declare function setLibrary(name: string, library: unknown): void;

interface UnitFormat {
    unit: string;
    scale?: number;
    offset?: number;
    decimals?: number;
}

type TextFormatFunction = (value: number, unitFormat: UnitFormat | null | undefined) => string;
declare const DEFAULT_LINE_WIDTH: number;
declare const DEFAULT_LINE_COLOR: Color;
declare const DEFAULT_TEXT_FONT_FAMILY: string;
declare const DEFAULT_TEXT_SIZE: number;
declare const DEFAULT_TEXT_COLOR: Color;
declare const DEFAULT_TEXT_OUTLINE_WIDTH: number;
declare const DEFAULT_TEXT_OUTLINE_COLOR: Color;
declare const DEFAULT_TEXT_FORMAT_FUNCTION: TextFormatFunction;
declare const DEFAULT_ICON_SIZE: number;
declare const DEFAULT_ICON_COLOR: Color;
declare function ensureDefaultProps<PropsT extends {}>(props: PropsT, defaultProps: DefaultProps<PropsT>): PropsT;

interface AnimationConfig {
    onUpdate: () => void;
    fps?: number;
}
declare class Animation {
    private _config;
    private _running;
    private _raf;
    private _lastFrameTime;
    constructor(config: AnimationConfig);
    getConfig(): AnimationConfig;
    setConfig(config: AnimationConfig): void;
    updateConfig(config: Partial<AnimationConfig>): void;
    get running(): boolean;
    toggle(running?: boolean): void;
    start(): void;
    stop(): void;
    step(): void;
}

declare const DirectionType: {
    readonly INWARD: "INWARD";
    readonly OUTWARD: "OUTWARD";
};
type DirectionType = (typeof DirectionType)[keyof typeof DirectionType];

declare const DirectionFormat: {
    readonly VALUE: "VALUE";
    readonly CARDINAL: "CARDINAL";
    readonly CARDINAL2: "CARDINAL2";
    readonly CARDINAL3: "CARDINAL3";
};
type DirectionFormat = (typeof DirectionFormat)[keyof typeof DirectionFormat];

declare function formatValue(value: number, unitFormat: UnitFormat | null | undefined): string;
declare function formatUnit(unitFormat: UnitFormat): string;
declare function formatValueWithUnit(value: number, unitFormat: UnitFormat): string;
declare function formatDirection(direction: number, directionType: DirectionType, directionFormat: DirectionFormat): string;

type TextureDataArray = Uint8Array | Uint8ClampedArray | Float32Array;
interface TextureData {
    data: TextureDataArray;
    width: number;
    height: number;
}
type FloatDataArray = Float32Array;
interface FloatData {
    data: FloatDataArray;
    width: number;
    height: number;
}
interface LoadOptions {
    headers?: Record<string, string>;
}
interface CachedLoadOptions<T> extends LoadOptions {
    cache?: Map<string, T | Promise<T>> | false;
}
type LoadFunction<T> = (url: string, options?: LoadOptions) => Promise<T>;
type CachedLoadFunction<T> = (url: string, options?: CachedLoadOptions<T>) => Promise<T>;
declare const loadTextureData: CachedLoadFunction<TextureData>;
declare const loadJson: CachedLoadFunction<any>;

type DatetimeISOString = string;
type DatetimeISOStringRange = [start: DatetimeISOString, end: DatetimeISOString];
type OpenDatetimeISOStringRange = [start: DatetimeISOString | null, end: DatetimeISOString | null];
type DatetimeFormatFunction = (value: DatetimeISOString) => DatetimeISOString;
type DurationISOString = string;
declare function interpolateDatetime(start: DatetimeISOString, end: DatetimeISOString | null, weight: number): string;
declare function getDatetimeWeight(start: DatetimeISOString, end: DatetimeISOString | null, middle: DatetimeISOString): number;
declare function getClosestStartDatetime(datetimes: DatetimeISOString[], datetime: DatetimeISOString): DatetimeISOString | undefined;
declare function getClosestEndDatetime(datetimes: DatetimeISOString[], datetime: DatetimeISOString): DatetimeISOString | undefined;
declare function offsetDatetime(datetime: DatetimeISOString, hour: number): DatetimeISOString;
declare function offsetDatetimeRange(datetime: DatetimeISOString, startHour: number, endHour: number): DatetimeISOStringRange;
declare function formatDatetime(value: DatetimeISOString): string;

declare const ImageInterpolation: {
    readonly NEAREST: "NEAREST";
    readonly LINEAR: "LINEAR";
    readonly CUBIC: "CUBIC";
};
type ImageInterpolation = (typeof ImageInterpolation)[keyof typeof ImageInterpolation];

declare const ImageType: {
    readonly SCALAR: "SCALAR";
    readonly VECTOR: "VECTOR";
};
type ImageType = (typeof ImageType)[keyof typeof ImageType];

type ImageUnscale = [min: number, max: number] | null;

declare const UnitSystem: {
    readonly METRIC: "METRIC";
    readonly METRIC_KILOMETERS: "METRIC_KILOMETERS";
    readonly IMPERIAL: "IMPERIAL";
    readonly NAUTICAL: "NAUTICAL";
};
type UnitSystem = (typeof UnitSystem)[keyof typeof UnitSystem];

declare const Placement: {
    readonly BOTTOM: "BOTTOM";
    readonly TOP: "TOP";
    readonly RIGHT: "RIGHT";
    readonly LEFT: "LEFT";
};
type Placement = (typeof Placement)[keyof typeof Placement];

interface ImageProperties {
    image: TextureData;
    image2: TextureData | null;
    imageSmoothing: number;
    imageInterpolation: ImageInterpolation;
    imageWeight: number;
    imageType: ImageType;
    imageUnscale: ImageUnscale;
    imageMinValue: number | null;
    imageMaxValue: number | null;
}

interface RasterPointProperties {
    value: number;
    direction?: number;
}
declare function getRasterPoints(imageProperties: ImageProperties, bounds: GeoJSON.BBox, positions: GeoJSON.Position[]): GeoJSON.FeatureCollection<GeoJSON.Point, RasterPointProperties>;
declare function getRasterMagnitudeData(imageProperties: ImageProperties, bounds: GeoJSON.BBox): FloatData;

type _RasterBitmapLayerProps = BitmapLayerProps & {
    imageTexture: Texture | null;
    imageTexture2: Texture | null;
    imageSmoothing: number;
    imageInterpolation: ImageInterpolation;
    imageWeight: number;
    imageType: ImageType;
    imageUnscale: ImageUnscale;
    imageMinValue: number | null;
    imageMaxValue: number | null;
    bounds: BitmapBoundingBox;
    minZoom: number | null;
    maxZoom: number | null;
    palette: Palette | null;
};
type RasterBitmapLayerProps = _RasterBitmapLayerProps & LayerProps;

type _RasterLayerProps = RasterBitmapLayerProps & {
    image: TextureData | null;
    image2: TextureData | null;
    gridEnabled: boolean | null;
};
type RasterLayerProps = _RasterLayerProps & LayerProps;
declare class RasterLayer<ExtraPropsT extends {} = {}> extends CompositeLayer<ExtraPropsT & Required<_RasterLayerProps>> {
    static layerName: string;
    static defaultProps: DefaultProps<RasterLayerProps>;
    state: CompositeLayer['state'] & {
        props?: RasterLayerProps;
        imageTexture?: Texture;
        imageTexture2?: Texture;
        positions?: GeoJSON.Position[];
    };
    renderLayers(): LayersList;
    updateState(params: UpdateParameters<this>): void;
    private _updateFeatures;
}

type _ContourBitmapLayerProps = BitmapLayerProps & {
    imageTexture: Texture | null;
    imageTexture2: Texture | null;
    imageSmoothing: number;
    imageInterpolation: ImageInterpolation;
    imageWeight: number;
    imageType: ImageType;
    imageUnscale: ImageUnscale;
    imageMinValue: number | null;
    imageMaxValue: number | null;
    bounds: BitmapBoundingBox;
    minZoom: number | null;
    maxZoom: number | null;
    palette: Palette | null;
    color: Color | null;
    interval: number;
    majorInterval: number;
    width: number;
};
type ContourBitmapLayerProps = _ContourBitmapLayerProps & LayerProps;

type _ContourLayerProps = ContourBitmapLayerProps & {
    image: TextureData | null;
    image2: TextureData | null;
};
type ContourLayerProps = _ContourLayerProps & LayerProps;
declare class ContourLayer<ExtraPropsT extends {} = {}> extends CompositeLayer<ExtraPropsT & Required<_ContourLayerProps>> {
    static layerName: string;
    static defaultProps: DefaultProps<ContourLayerProps>;
    state: CompositeLayer['state'] & {
        props?: ContourLayerProps;
        imageTexture?: Texture;
        imageTexture2?: Texture;
    };
    renderLayers(): LayersList;
    updateState(params: UpdateParameters<this>): void;
}

type _HighLowCompositeLayerProps = CompositeLayerProps & {
    image: TextureData | null;
    image2: TextureData | null;
    imageSmoothing: number;
    imageInterpolation: ImageInterpolation;
    imageWeight: number;
    imageType: ImageType;
    imageUnscale: ImageUnscale;
    imageMinValue: number | null;
    imageMaxValue: number | null;
    bounds: BitmapBoundingBox;
    minZoom: number | null;
    maxZoom: number | null;
    radius: number;
    unitFormat: UnitFormat | null;
    textFormatFunction: TextFormatFunction;
    textFontFamily: string;
    textSize: number;
    textColor: Color;
    textOutlineWidth: number;
    textOutlineColor: Color;
    palette: Palette | null;
};
type HighLowCompositeLayerProps = _HighLowCompositeLayerProps & LayerProps;

type _HighLowLayerProps = HighLowCompositeLayerProps;
type HighLowLayerProps = _HighLowLayerProps & LayerProps;
declare class HighLowLayer<ExtraPropsT extends {} = {}> extends CompositeLayer<ExtraPropsT & Required<_HighLowLayerProps>> {
    static layerName: string;
    static defaultProps: DefaultProps<HighLowLayerProps>;
    state: CompositeLayer['state'] & {
        props?: HighLowLayerProps;
    };
    renderLayers(): LayersList;
    updateState(params: UpdateParameters<this>): void;
}

declare const FrontType: {
    readonly COLD: "COLD";
    readonly WARM: "WARM";
    readonly OCCLUDED: "OCCLUDED";
    readonly STATIONARY: "STATIONARY";
};
type FrontType = (typeof FrontType)[keyof typeof FrontType];

type _FrontCompositeLayerProps<DataT> = CompositeLayerProps & {
    data: DataT[];
    minZoom: number | null;
    maxZoom: number | null;
    getType: ((d: DataT) => FrontType) | null;
    getPath: ((d: DataT) => Position[]) | null;
    width: number;
    coldColor: Color;
    warmColor: Color;
    occludedColor: Color;
    iconSize: number;
    _debug: boolean;
};
type FrontCompositeLayerProps<DataT> = _FrontCompositeLayerProps<DataT> & LayerProps;

type _FrontLayerProps<DataT> = FrontCompositeLayerProps<DataT>;
type FrontLayerProps<DataT> = _FrontLayerProps<DataT> & LayerProps;
declare class FrontLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<ExtraPropsT & Required<_FrontLayerProps<DataT>>> {
    static layerName: string;
    static defaultProps: DefaultProps<FrontLayerProps<any>>;
    state: CompositeLayer['state'] & {
        props?: FrontLayerProps<DataT>;
    };
    renderLayers(): LayersList;
}

declare const GridStyle: {
    readonly VALUE: "VALUE";
    readonly ARROW: "ARROW";
    readonly WIND_BARB: "WIND_BARB";
};
type GridStyle = (typeof GridStyle)[keyof typeof GridStyle];

type _GridCompositeLayerProps = CompositeLayerProps & {
    image: TextureData | null;
    image2: TextureData | null;
    imageSmoothing: number;
    imageInterpolation: ImageInterpolation;
    imageWeight: number;
    imageType: ImageType;
    imageUnscale: ImageUnscale;
    imageMinValue: number | null;
    imageMaxValue: number | null;
    bounds: BitmapBoundingBox;
    minZoom: number | null;
    maxZoom: number | null;
    style: GridStyle;
    density: number;
    unitFormat: UnitFormat | null;
    textFormatFunction: TextFormatFunction;
    textFontFamily: string;
    textSize: number;
    textColor: Color;
    textOutlineWidth: number;
    textOutlineColor: Color;
    iconBounds: [number, number] | null;
    iconSize: [number, number] | number;
    iconColor: Color;
    palette: Palette | null;
};
type GridCompositeLayerProps = _GridCompositeLayerProps & LayerProps;

type _GridLayerProps = GridCompositeLayerProps;
type GridLayerProps = _GridLayerProps & LayerProps;
declare class GridLayer<ExtraPropsT extends {} = {}> extends CompositeLayer<ExtraPropsT & Required<_GridLayerProps>> {
    static layerName: string;
    static defaultProps: DefaultProps<GridLayerProps>;
    state: CompositeLayer['state'] & {
        props?: GridLayerProps;
    };
    renderLayers(): LayersList;
    updateState(params: UpdateParameters<this>): void;
}

type _ParticleLineLayerProps = LineLayerProps<unknown> & {
    imageTexture: Texture | null;
    imageTexture2: Texture | null;
    imageSmoothing: number;
    imageInterpolation: ImageInterpolation;
    imageWeight: number;
    imageType: ImageType;
    imageUnscale: ImageUnscale;
    imageMinValue: number | null;
    imageMaxValue: number | null;
    bounds: BitmapBoundingBox;
    minZoom: number | null;
    maxZoom: number | null;
    palette: Palette | null;
    color: Color | null;
    numParticles: number;
    maxAge: number;
    speedFactor: number;
    width: number;
    animate: boolean;
};
type ParticleLineLayerProps = _ParticleLineLayerProps & LayerProps;

type _ParticleLayerProps = ParticleLineLayerProps & {
    image: TextureData | null;
    image2: TextureData | null;
};
type ParticleLayerProps = _ParticleLayerProps & LayerProps;
declare class ParticleLayer<ExtraPropsT extends {} = {}> extends CompositeLayer<ExtraPropsT & Required<_ParticleLayerProps>> {
    static layerName: string;
    static defaultProps: DefaultProps<ParticleLayerProps>;
    state: CompositeLayer['state'] & {
        props?: ParticleLayerProps;
        imageTexture?: Texture;
        imageTexture2?: Texture;
    };
    renderLayers(): LayersList;
    updateState(params: UpdateParameters<this>): void;
}

declare abstract class Control<ControlConfig> {
    addTo(target: HTMLElement): void;
    prependTo(target: HTMLElement): void;
    remove(): void;
    updateConfig(config: Partial<ControlConfig>): void;
    abstract getConfig(): ControlConfig;
    abstract setConfig(config: ControlConfig): void;
    protected abstract onAdd(): HTMLElement;
    protected abstract onRemove(): void;
}

interface LegendControlConfig {
    width?: number;
    ticksCount?: number;
    title: string;
    unitFormat: UnitFormat;
    palette: Palette;
}
declare class LegendControl extends Control<LegendControlConfig> {
    private _config;
    private _container;
    constructor(config?: LegendControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    getConfig(): LegendControlConfig;
    setConfig(config: LegendControlConfig): void;
}

interface TooltipControlConfig {
    unitFormat: UnitFormat;
    directionType?: DirectionType;
    directionFormat?: DirectionFormat;
    followCursor?: boolean;
    followCursorOffset?: number;
    followCursorPlacement?: Placement;
}
declare class TooltipControl extends Control<TooltipControlConfig> {
    private _config;
    private _container;
    private _value;
    private _direction;
    private _directionIcon;
    private _directionText;
    constructor(config?: TooltipControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    getConfig(): TooltipControlConfig;
    setConfig(config: TooltipControlConfig): void;
    update(rasterPointProperties: RasterPointProperties | undefined): void;
    updatePickingInfo(pickingInfo: PickingInfo & {
        raster?: RasterPointProperties;
    }): void;
}

interface TimelineControlConfig {
    width?: number;
    datetimes: DatetimeISOString[];
    datetime: DatetimeISOString;
    datetimeInterpolate?: boolean;
    datetimeFormatFunction?: DatetimeFormatFunction;
    onPreload?: (datetimes: DatetimeISOString[]) => Promise<void>[] | Promise<void>;
    onUpdate?: (datetime: DatetimeISOString) => void;
    fps?: number;
}
declare class TimelineControl extends Control<TimelineControlConfig> {
    private _config;
    private _container;
    private _currentDatetime;
    private _progressInput;
    private _loaderText;
    private _loading;
    private _animation;
    constructor(config?: TimelineControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    get loading(): boolean;
    get running(): boolean;
    get _running(): boolean;
    toggle(running?: boolean): Promise<void>;
    start(): Promise<void>;
    pause(): void;
    stop(): void;
    reset(): void;
    stepBackward(): Promise<void>;
    stepForward(): Promise<void>;
    get _startEndDatetimes(): DatetimeISOString[];
    private _updateProgress;
    private _progressInputClicked;
    private _animationUpdated;
    private _preload;
    getConfig(): TimelineControlConfig;
    setConfig(config: TimelineControlConfig): void;
}

interface AttributionControlConfig {
    attribution: string;
}
declare class AttributionControl extends Control<AttributionControlConfig> {
    private _config;
    private _container;
    constructor(config?: AttributionControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    getConfig(): AttributionControlConfig;
    setConfig(config: AttributionControlConfig): void;
}

interface LogoControlConfig {
}
declare class LogoControl extends Control<LogoControlConfig> {
    private _config;
    private _container;
    constructor(config?: LogoControlConfig);
    protected onAdd(): HTMLElement;
    protected onRemove(): void;
    getConfig(): LogoControlConfig;
    setConfig(config: LogoControlConfig): void;
}

export { Animation, AttributionControl, ContourLayer, DATETIME, DEFAULT_ICON_COLOR, DEFAULT_ICON_SIZE, DEFAULT_LINE_COLOR, DEFAULT_LINE_WIDTH, DEFAULT_TEXT_COLOR, DEFAULT_TEXT_FONT_FAMILY, DEFAULT_TEXT_FORMAT_FUNCTION, DEFAULT_TEXT_OUTLINE_COLOR, DEFAULT_TEXT_OUTLINE_WIDTH, DEFAULT_TEXT_SIZE, DirectionFormat, DirectionType, FrontLayer, FrontType, GridLayer, GridStyle, HighLowLayer, ImageInterpolation, ImageType, LegendControl, LogoControl, ParticleLayer, Placement, RasterLayer, TimelineControl, TooltipControl, UnitSystem, VERSION, ensureDefaultProps, formatDatetime, formatDirection, formatUnit, formatValue, formatValueWithUnit, getClosestEndDatetime, getClosestStartDatetime, getDatetimeWeight, getRasterMagnitudeData, getRasterPoints, interpolateDatetime, loadJson, loadTextureData, offsetDatetime, offsetDatetimeRange, setLibrary };
export type { AnimationConfig, AttributionControlConfig, CachedLoadFunction, CachedLoadOptions, ContourLayerProps, DatetimeFormatFunction, DatetimeISOString, DatetimeISOStringRange, DurationISOString, FloatData, FloatDataArray, FrontLayerProps, GridLayerProps, HighLowLayerProps, ImageUnscale, LegendControlConfig, LoadFunction, LoadOptions, LogoControlConfig, OpenDatetimeISOStringRange, ParticleLayerProps, RasterLayerProps, RasterPointProperties, TextFormatFunction, TextureData, TextureDataArray, TimelineControlConfig, TooltipControlConfig, UnitFormat };
